<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>《ECMAScript6标准入门》第三版--读书笔记</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="white"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-title" content="我的博客"><meta name="description" content="专注前端开发，前端开发技术博客"><meta name="keywords" content="前端开发，PHP开发，Javascript，前端开发博客"><link rel="dns-prefetch" href="//hm.baidu.com"><link rel="dns-prefetch" href="//sp0.baidu.com"><link rel="dns-prefetch" href="//zz.bdstatic.com"><link rel="dns-prefetch" href="//busuanzi.ibruce.info"><link rel="dns-prefetch" href="//imsun.github.io"><link rel="dns-prefetch" href="//api.github.io"><link rel="stylesheet" href="/blog/css/style.css"><link rel="shortcut icon" href="/blog/favicon.ico"><link rel="bookmark" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《ECMAScript6标准入门》第三版--读书笔记</h1><a id="logo" href="/blog/.">前端之路</a><p class="description">路漫漫其修远兮，吾将上下而求索</p></div><div id="nav-menu"><a href="/blog/." class="current"><i class="fa fa-home">首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索..."></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">《ECMAScript6标准入门》第三版--读书笔记</h1><div class="post-meta"><span class="date">2018-03-10</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i> Hits</i></i></span><a href="/blog/articles/2018/03/10.html#comments" class="comment-count"></a></div><div class="post-content"><p>2015年6月，ECMAScript 6正式通过，成为国际标准。尽管在目前的工作中还没有使用ES6，但是每项新技术出来总是忍不住想尝尝鲜，想知道ES6能为前端开发带来哪些变化？对自己的工作有哪些方面可以提升。刚好看到阮一峰的《ES6标准入门》，便顺着这本书尝试着ES6的各种新特性。<br><a id="more"></a><br>ES6的各种新特性的兼容性查询<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/</a><br>尽管我们的浏览器还不一定完全支持ES6代码，我们可以使用Babel转码器,在这里我们使用命令行转码<strong>babel-cli</strong>，命令行<code>$ npm install --global babel-cli</code>安装babel-cli</p><h3 id="第二章-let和const命令"><a href="#第二章-let和const命令" class="headerlink" title="第二章 let和const命令"></a>第二章 let和const命令</h3><h4 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h4><p>ES6新增了 let 命令，用来声明变量。它的用法类似于 var ，但是所声明的变量，只在 let 命令所在的代码块内有效。let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p></p><p>ES6明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。<br>let不允许在相同作用域内，重复声明同一个变量。let 实际上为JavaScript新增了块级作用域。 ES6引入了块级作用域，明确允许在块级作用域之中声明函数。</p><h4 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h4><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MAX); <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。 const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变<br></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">//123</span></span><br></pre></td></tr></table></figure><p></p><p>ES6规定var 命令和 function 命令声明的全局变量，依旧是全局对象的属性；let 命令、 const 命令、 class 命令声明的全局变量，不属于全局对象的属性。<br>ES5只有两种声明变量的方式，var和function命令，ES6有6种方式，var,function,let,const,class,import</p><h3 id="第三章-变量的解构赋值"><a href="#第三章-变量的解构赋值" class="headerlink" title="第三章 变量的解构赋值"></a>第三章 变量的解构赋值</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>解构赋值允许指定默认值。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure><p></p><p>注意，ES6内部使用严格相等运算符（ === ），判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined ，默认值是不会生效的。</p><h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function"><span class="keyword">function</span>(<span class="params">[a,b]</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;    </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[3,7]</span></span><br></pre></td></tr></table></figure><h4 id="变量解构赋值用途"><a href="#变量解构赋值用途" class="headerlink" title="变量解构赋值用途"></a>变量解构赋值用途</h4><ol><li>交换变量的值<code>[x, y] = [y, x];</code></li><li><p>提取JSON数据</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">    id: <span class="number">42</span>,</span><br><span class="line">    <span class="keyword">status</span>: <span class="string">"OK"</span>,</span><br><span class="line">    <span class="keyword">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; id, <span class="keyword">status</span>, <span class="keyword">data</span>: <span class="keyword">number</span> &#125; = jsonData;</span><br><span class="line">console.<span class="built_in">log</span>(id, <span class="keyword">status</span>, <span class="keyword">number</span>);// <span class="number">42</span>, <span class="string">"OK"</span>, [<span class="number">867</span>, <span class="number">5309</span>]</span><br></pre></td></tr></table></figure></li><li><p>函数参数的默认值</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">async</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    cache = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    complete = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    crossDomain = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    global = <span class="literal">true</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第四章-字符串的扩展"><a href="#第四章-字符串的扩展" class="headerlink" title="第四章 字符串的扩展"></a>第四章 字符串的扩展</h3><h4 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h4><p>es6为字符串添加了遍历器接口，使得字符串可以由for…of循环遍历<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>includes()：返回布尔值，表示是否找到了参数字符串。<br>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。<br>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p></p><p>使用第二个参数 n 时， endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。</p><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>返回一个新字符串，表示将原字符串重复 n 次。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br></pre></td></tr></table></figure><p></p><h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><p>padStart 用于头部补全， padEnd 用于尾部补全。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure><p></p><p>padStart 和 padEnd 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><p></p><h3 id="第六章-数值的扩展"><a href="#第六章-数值的扩展" class="headerlink" title="第六章 数值的扩展"></a>第六章 数值的扩展</h3><p>从ES5开始，在严格模式之中，八进制就不再允许使用前缀 0 表示，ES6进一步明确，要使用前缀 0o 表示。</p><h4 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite()"></a>Number.isFinite()</h4><p>Number.isFinite() 用来检查一个数值是否非无穷（infinity）。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p></p><h4 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h4><p>Number.isNaN() 用来检查一个值是否为 NaN 。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p></p><p>它们与传统的全局方法 isFinite() 和 isNaN() 的区别在于，传统方法先调用 Number() 将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回 false 。</p><h4 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h4><p>ES6将全局方法 parseInt() 和 parseFloat() ，移植到Number对象上面，行为完全保持不变。</p><h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p>Number.isInteger() 用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</p><h4 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h4><p>JavaScript能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。<br>ES6引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个<br>常量，用来表示这个范围的上下限。<br>Number.isSafeInteger() 则是用来判断一个整数是否落在这个范围之内。</p><h4 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h4><p>Math.trunc 方法用于去除一个数的小数部分，返回整数部分。<br>Math.sign 方法用来判断一个数到底是正数、负数、还是零。<br>Math.cbrt 方法用于计算一个数的立方根。<br>Math.fround方法返回一个数的单精度浮点数形式。<br>Math.hypot 方法返回所有参数的平方和的平方根。</p><h3 id="第七章-函数的扩展"><a href="#第七章-函数的扩展" class="headerlink" title="第七章 函数的扩展"></a>第七章 函数的扩展</h3><p>通常情况下，定义了默认值的参数应该是函数的尾参数，</p><h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p>ES6引入rest参数以用于获取函数的多余参数，这样就不需要使用arguments对象了<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> val <span class="keyword">of</span> values)&#123;</span><br><span class="line">        sum += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>) <span class="comment">//10</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p></p><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>如果箭头函数不需要参数或需要多个参数，就使用圆括号代表参数部分。只有一个参数则可以不使用圆括号<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v</span><br></pre></td></tr></table></figure><p></p><p>注意事项：</p><ol><li>函数体内的this对象是定义时所在的对象，而不是使用时所在的对象</li><li>不可以当做构造函数</li><li>不可以使用arguments，super, new.target，可以使用rest参数代替</li><li>不可以使用yield命令</li></ol><h4 id="绑定this"><a href="#绑定this" class="headerlink" title="绑定this"></a>绑定this</h4><p>函数绑定运算符是并排的双冒号，双冒号左边是一个对象，右边是一个函数，该运算符会自动将左边的对象作为上下文环境(this)绑定到右边的函数上<br>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上<br></p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">foo::bar</span><br><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">method</span> = :</span>:object.foo</span><br></pre></td></tr></table></figure><p></p><h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>尾调用是指某个函数最后一步是调用另一个函数，<br></p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">f</span>(x)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">g(x)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行尾调用优化</p><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>递归非常耗费内存，因为需要同时保存成百上千个调用帧，很容易发生栈溢出错误，但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生栈溢出<br></p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n,total)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>) <span class="keyword">return</span> total</span><br><span class="line">    <span class="keyword">return</span> fatorial(n<span class="number">-1</span>,n*total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span><span class="params">(n,ac1 = 1,ac2=2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;<span class="keyword">return</span> ac2&#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>,ac2,ac1+ac2)&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>将多参数的函数转换成单参数的形式<br></p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span><span class="params">(fn,n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.call(<span class="keyword">this</span>,m,n)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tailFactorial = currying(factorial,<span class="number">1</span>)</span><br><span class="line">tailFactorial(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p></p><p>ES6的尾调用优化只有在严格模式下有效，正常模式下arguments和caller会跟踪函数的调用栈</p><p>在正常模式下可通过蹦床函数实现尾递归优化<br></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span><span class="params">(f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(f &amp;&amp; f instranceof <span class="function"><span class="keyword">Function</span>)</span>&#123;</span><br><span class="line">        f = f()  <span class="comment">//只要f()执行后返回一个函数就继续执行    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>蹦床函数并不是真正的尾递归优化，下面的实现才是<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tco</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">accumulator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    accumulated.push(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span><br><span class="line">        value = f.apply(<span class="keyword">this</span>, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = tco(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure><p></p><h3 id="第八章-数组的扩展"><a href="#第八章-数组的扩展" class="headerlink" title="第八章 数组的扩展"></a>第八章 数组的扩展</h3><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>(…) 可以将一个数组转化为逗号分隔的参数序列<br></p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">console.log(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure><p></p><p>扩展运算符可以代替数组的apply方法<br></p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Math.max(...[<span class="number">14</span>,<span class="number">3</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure><p></p><p>可以合并数组<br></p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>].concat(more)</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,...more]</span><br></pre></td></tr></table></figure><p></p><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。<br>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的 arguments 对象。 Array.from 都可以将它们转为真正的数组。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>任何有length属性的对象，都可以通过Array.from方法转为数组，而这种情况扩展运算符无法转换<br>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>Array.of 方法用于将一组值，转换为数组。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure><p></p><h4 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h4><p>Array.prototype.copyWithin(target, start = 0, end = this.length)</p><ul><li>target（必需）：从该位置开始替换数据。</li><li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h4 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h4><p>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined 。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure><p></p><p>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1 。</p><h4 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h4><p>fill 方法使用给定值，填充一个数组。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)<span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure><p></p><h4 id="数组实例的entries-，keys-和values"><a href="#数组实例的entries-，keys-和values" class="headerlink" title="数组实例的entries()，keys()和values()"></a>数组实例的entries()，keys()和values()</h4><p>ES6提供三个新的方法—— entries() ， keys() 和 values() ——用于遍历数组。唯一的区别是 keys() 是对键名的遍历、 values() 是对键值的遍历， entries() 是对键值对的遍历。<br>他们都返回一个遍历器对象，可用for…of循环遍历</p><h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p>该方法返回一个布尔值，标表示某个数组是否包含给定的值与字符串includes方法类似<br></p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].includes(<span class="number">2</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p></p><p>相比indexOf方法<br>[NaN].indexOf(NaN) //-1<br>[NaN].includes(NaN) //true</p><h3 id="第九章-对象的扩展"><a href="#第九章-对象的扩展" class="headerlink" title="第九章 对象的扩展"></a>第九章 对象的扩展</h3><h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><p>ES6允许在对象之中，只写属性名，不写属性值。这时属性值等于属性名所代表的变量。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    <span class="comment">//等同于birth: birth</span></span><br><span class="line">    birth,</span><br><span class="line">    <span class="comment">// 等同于hello: function ()...</span></span><br><span class="line">    hello() &#123; <span class="built_in">console</span>.log(<span class="string">'我的名字是'</span>, <span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>ES5比较两个值是否相等，只有两个运算符，== 和 === ，前者会自动转换数据类型没后者的NaN不等于自身，+0等于-0<br>Object.is()则可以避免这个问题<br></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(+<span class="number">0</span>,<span class="number">-0</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(NaN,NaN) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p></p><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p>Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性<br>Object.assign 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。<br>Object.assign 方法有很多用处。</p><ol><li><p>为对象添加属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为对象添加方法</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Object</span><span class="selector-class">.assign</span>(SomeClass.prototype, &#123;</span><br><span class="line">    <span class="selector-tag">someMethod</span>(arg1, arg2) &#123;</span><br><span class="line">    ···</span><br><span class="line">    &#125;,</span><br><span class="line">    anotherMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>克隆对象</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">clone</span>(origin) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Object.assign(&#123;&#125;,</span> origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合并多个对象</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">const <span class="built_in">merge</span> = (<span class="keyword">target</span>, ...sources) =&gt; Object.<span class="keyword">assign</span>(<span class="keyword">target</span>, ...sources);</span><br></pre></td></tr></table></figure></li><li><p>为属性指定默认值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">    logLevel: <span class="number">0</span>,</span><br><span class="line">    outputFormat: <span class="string">'html'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="ES6属性的遍历5种方法"><a href="#ES6属性的遍历5种方法" class="headerlink" title="ES6属性的遍历5种方法"></a>ES6属性的遍历5种方法</h5><ol><li>for…in 循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</li><li>Object.keys(obj)返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</li><li>Object.getOwnPropertyNames(obj)返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</li><li>Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有Symbol属性。</li><li>Reflect.ownKeys(obj)返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</li></ol><h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p>该属性用来设置一个对象的prototype对象,返回参数对象本身<br></p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span>.setPrototypeOf(<span class="type">Object</span>,prototype)</span><br></pre></td></tr></table></figure><p></p><h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>该方法与setPrototypeOf()方法配套，用于读取一个对象的prototype对象,参数如果不是对象会自动转为对象<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rec = <span class="keyword">new</span> Rectangle();</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p></p><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>返回一个数组，成员是参数对象自身(不包含继承的)的所有可遍历属性的键名</p><h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p><h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h4><p>Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p><h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><p>ES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。<br>ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。<br>该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> foo(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target1, source);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(target1, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// &#123; value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="第十章-Symbol"><a href="#第十章-Symbol" class="headerlink" title="第十章 Symbol"></a>第十章 Symbol</h3><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。<br>注意，Symbol函数前不能使用new命令，否则会报错。Symbol值作为对象属性名时，不能用点运算符。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a.mySymbol = <span class="string">'Hello!'</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">'mySymbol'</span>] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure><p></p><p>因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个Symbol值。<br>Symbol作为属性名，该属性不会出现在 for…in 、 for…of 循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。<br>Reflect.ownKeys 方法可以返回所有类型的键名，包括常规键名和Symbol键名。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">    enum: <span class="number">2</span>,</span><br><span class="line">    nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)<span class="comment">// [Symbol(my_key), 'enum', 'nonEnum']</span></span><br></pre></td></tr></table></figure><p></p><h4 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h4><p>有时，我们希望重新使用同一个Symbol值， Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)<span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p></p><h3 id="第十一章-Set和Map数据结构"><a href="#第十一章-Set和Map数据结构" class="headerlink" title="第十一章 Set和Map数据结构"></a>第十一章 Set和Map数据结构</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p></p><p>可用于数组去重<br></p><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="meta">[</span><span class="params">...</span><span class="literal">new</span> <span class="built_in">set</span>(<span class="built_in">array</span>)<span class="meta">]</span></span><br></pre></td></tr></table></figure><p></p><p>Array.from(new set(1,2,3,4)) Array.from可以将set结构转为数组</p><h4 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h4><ol><li>Set.prototype.constructor ：构造函数，默认就是 Set 函数。</li><li>Set.prototype.size ：返回 Set 实例的成员总数。</li><li>add(value) ：添加某个值，返回Set结构本身。</li><li>delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。</li><li>has(value) ：返回一个布尔值，表示该值是否为 Set 的成员。</li><li>clear() ：清除所有成员，没有返回值。<h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4></li><li>keys() ：返回键名的遍历器。</li><li>values() ：返回键值的遍历器。</li><li>entries() ：返回所有成员的遍历器。</li><li>forEach() ：遍历Map的所有成员。<br>也可以直接使用for…of遍历set结构</li></ol><h4 id="Map结构的目的和基本用法"><a href="#Map结构的目的和基本用法" class="headerlink" title="Map结构的目的和基本用法"></a>Map结构的目的和基本用法</h4><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键<br>Map原生提供三个遍历器生成函数和一个遍历方法。</p><ol><li>keys() ：返回键名的遍历器。</li><li>values() ：返回键值的遍历器。</li><li>entries() ：返回所有成员的遍历器。</li><li>forEach() ：遍历Map的所有成员。</li></ol><h3 id="第12章-Proxy"><a href="#第12章-Proxy" class="headerlink" title="第12章 Proxy"></a>第12章 Proxy</h3><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<br>Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义<br></p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> Proxy(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">(target, property)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p></p><h4 id="proxy的实例方法"><a href="#proxy的实例方法" class="headerlink" title="proxy的实例方法"></a>proxy的实例方法</h4><ul><li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li><li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li><strong>has(target, propKey)</strong>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li><li><strong>deleteProperty(target, propKey)</strong>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li><li><strong>ownKeys(target)</strong>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li><li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li></ul><h3 id="第13章-Reflect"><a href="#第13章-Reflect" class="headerlink" title="第13章 Reflect"></a>第13章 Reflect</h3><p>Reflect对象的设计目的有这样几个。<br>1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。<br>2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。<br>3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。<br>4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p><h4 id="Reflect静态方法"><a href="#Reflect静态方法" class="headerlink" title="Reflect静态方法"></a>Reflect静态方法</h4><p>Reflect.apply(target, thisArg, args)<br>Reflect.construct(target, args)<br>Reflect.get(target, name, receiver)<br>Reflect.set(target, name, value, receiver)<br>Reflect.defineProperty(target, name, desc)<br>Reflect.deleteProperty(target, name)<br>Reflect.has(target, name)<br>Reflect.ownKeys(target)<br>Reflect.isExtensible(target)<br>Reflect.preventExtensions(target)<br>Reflect.getOwnPropertyDescriptor(target, name)<br>Reflect.getPrototypeOf(target)<br>Reflect.setPrototypeOf(target, prototype)</p><h3 id="第14章-Promise对象"><a href="#第14章-Promise对象" class="headerlink" title="第14章 Promise对象"></a>第14章 Promise对象</h3><p>Promise 是异步编程的一种解决方案，可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Primoise新建后就会立即执行<br>Promise实例生成以后，可以用 then 方法分别指定 Resolved 状态和 Reject 状态的回调函数。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">        client.onreadystatechange = handler;</span><br><span class="line">        client.responseType = <span class="string">"json"</span>;</span><br><span class="line">        client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">        client.send();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>then 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。<br>then 方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p><h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p>Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。<br>一般来说，不要在 then 方法里面定义Reject状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。</p><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p>promise.all方法将用于将多个promise实例包装成一个新的promise实例<br></p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">const</span> p = Promise.all([<span class="built_in">p1</span>, <span class="built_in">p2</span>, <span class="built_in">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure><p></p><p>p的状态由p1、p2、p3决定，分成两种情况。<br>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">const</span> p = Promise.race([<span class="built_in">p1</span>, <span class="built_in">p2</span>, <span class="built_in">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p><h3 id="第15章-lterator和for…of循环"><a href="#第15章-lterator和for…of循环" class="headerlink" title="第15章 lterator和for…of循环"></a>第15章 lterator和for…of循环</h3><p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费<br>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for…of循环遍历<br>原生具备 Iterator 接口的数据结构如下。</p><p>Array<br>Map<br>Set<br>String<br>TypedArray<br>函数的 arguments 对象<br>NodeList 对象</p><h3 id="第18章-async函数"><a href="#第18章-async函数" class="headerlink" title="第18章 async函数"></a>第18章 async函数</h3><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便<br>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p></p><p>async函数返回一个 Promise 对象<br>async函数内部return语句返回的值，会成为then方法回调函数的参数。<br>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到</p><p>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">  <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="function"><span class="params">v</span>=&gt;</span><span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></span><br></pre></td></tr></table></figure><p></p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure><p></p><p>防止出错的方法，也是将其放在try…catch代码块之中<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span>(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h4><p>第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br></pre></td></tr></table></figure><p></p><p>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错</p><h3 id="第19章-Class基本语法"><a href="#第19章-Class基本语法" class="headerlink" title="第19章 Class基本语法"></a>第19章 Class基本语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5的构造函数 Point ，对应ES6的 Point 类的构造方法。<br>由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。 Object.assign 方法可以很方便地一次向类添加多个方法。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">    toString()&#123;&#125;,</span><br><span class="line">    toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p><h4 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h4><p>constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。constructor 方法默认返回实例对象（即 this ），完全可以指定返回另外一个<br>对象。</p><h4 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h4><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错<br></p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> &#123;</span></span><br><span class="line">  printName(name = <span class="string">'there'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">print</span>(`<span class="javascript">Hello $&#123;name&#125;</span>`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = <span class="keyword">new</span> Logger();</span><br><span class="line">const &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="regexp">//</span> TypeError: Cannot read property <span class="string">'print'</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p></p><p>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错<br>解决办法<br>在构造方法中绑定this<br></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>另一种解决方法是使用箭头函数<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="function">(<span class="params">name = <span class="string">'there'</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this<br></p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">selfish</span> (<span class="params">target</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> WeakMap();</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">value</span> = Reflect.<span class="keyword">get</span>(target, key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">value</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(<span class="keyword">value</span>)) &#123;</span><br><span class="line">        cache.<span class="keyword">set</span>(<span class="keyword">value</span>, <span class="keyword">value</span>.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="keyword">get</span>(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> Proxy(target, handler);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> Logger());</span><br></pre></td></tr></table></figure><p></p><h4 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<br></p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><p></p><p>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例<br>父类的静态方法，可以被子类继承。</p><h4 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h4><p>new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用 new 命令生成实例'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="第20章-Class的继承"><a href="#第20章-Class的继承" class="headerlink" title="第20章 Class的继承"></a>第20章 Class的继承</h3><p>Class之间可以通过 extends 关键字实现继承<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。 这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。<br>Class不存在变量提升（hoist），这一点与ES5完全不同。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="Object-getPrototypeOf-1"><a href="#Object-getPrototypeOf-1" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>Object.getPrototypeOf 方法可以用来从子类上获取父类。<br>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p>super 这个关键字，有两种用法，含义不同。</p><ol><li>作为函数调用时（即 super(…args) ）， super 代表父类的构造函数。</li><li>作为对象调用时（即 super.prop 或 super.method() ），在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li></ol><p>ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。<br></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = <span class="keyword">new</span> <span class="type">B</span>();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p></p><p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象,在普通方法之中指向父类的原型对象<br></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    console.log(<span class="symbol">'stati</span>c', msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    console.log(<span class="symbol">'instanc</span>e', msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Child</span>.myMethod(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="type">Child</span>();</span><br><span class="line">child.myMethod(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><p></p><h4 id="类的prototype属性和proto属性"><a href="#类的prototype属性和proto属性" class="headerlink" title="类的prototype属性和proto属性"></a>类的prototype属性和<strong>proto</strong>属性</h4><p>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。<br></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">B</span>.__proto__ === <span class="type">A</span> <span class="comment">// true</span></span><br><span class="line"><span class="type">B</span>.prototype.__proto__ === <span class="type">A</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p></p><p>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（<strong>proto</strong>属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。</p><h3 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h3><ol><li>let取代var</li><li>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</li><li>函数的参数如果是对象的成员，优先使用解构赋值。</li><li><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2 &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    k1: v1,</span><br><span class="line">    k2: v2,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>数组<br>使用扩展运算符（…）拷贝数组。<code>const itemsCopy = [...items];</code><br>使用Array.from方法，将类似数组的对象转为数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</span><br><span class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</span><br></pre></td></tr></table></figure></li><li><p>函数<br>立即执行函数可以写成箭头函数的形式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet.'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>使用默认值语法设置函数参数的默认值。</p></li><li>总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。</li></ol></div><div class="common-bottom"><p>如需转载请保留此段声明</p><p>作者：<a href="/blog/about/">Jesse</a></p><p>出处：<a href="/blog/">https://jesse121.github.io/blog/</a></p><p>如果您对本文有什么疑问，欢迎在下方提出评论，您的建议是我写优质文章的动力。</p></div><div class="tags"><a href="/blog/tags/javascript/">JavaScript</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height:28px;height:28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="more" class="bds_more"></a></div><script>with(window._bd_share_config={common:{bdSnsKey:{},bdText:"",bdMini:"2",bdPic:"",bdStyle:"0",bdSize:"16"},share:{}},document)body.appendChild(createElement("script")).src="/blog/static/api/js/share.js?v=89860593.js?cdnversion="+~(-new Date/36e5)</script></div><div class="post-nav"><a href="/blog/articles/2018/03/12.html" class="pre">CSS3创建圆圈进度条</a><a href="/blog/articles/2018/02/11.html" class="next">LNMP + Apache 架构配置</a></div><div id="comments"><link rel="stylesheet" href="//imsun.github.io/gitment/style/default.css"><div id="gitment-ctn"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#第二章-let和const命令"><span class="toc-text">第二章 let和const命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#let命令"><span class="toc-text">let命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const命令"><span class="toc-text">const命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三章-变量的解构赋值"><span class="toc-text">第三章 变量的解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组的解构赋值"><span class="toc-text">数组的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的解构赋值"><span class="toc-text">对象的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数参数的解构赋值"><span class="toc-text">函数参数的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量解构赋值用途"><span class="toc-text">变量解构赋值用途</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第四章-字符串的扩展"><span class="toc-text">第四章 字符串的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串的遍历器接口"><span class="toc-text">字符串的遍历器接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#includes-startsWith-endsWith"><span class="toc-text">includes(), startsWith(), endsWith()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repeat"><span class="toc-text">repeat()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#padStart-，padEnd"><span class="toc-text">padStart()，padEnd()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板字符串"><span class="toc-text">模板字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第六章-数值的扩展"><span class="toc-text">第六章 数值的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isFinite"><span class="toc-text">Number.isFinite()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isNaN"><span class="toc-text">Number.isNaN()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-parseInt-Number-parseFloat"><span class="toc-text">Number.parseInt(), Number.parseFloat()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isInteger"><span class="toc-text">Number.isInteger()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安全整数和Number-isSafeInteger"><span class="toc-text">安全整数和Number.isSafeInteger()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math对象的扩展"><span class="toc-text">Math对象的扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第七章-函数的扩展"><span class="toc-text">第七章 函数的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rest参数"><span class="toc-text">rest参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绑定this"><span class="toc-text">绑定this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#尾调用优化"><span class="toc-text">尾调用优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#尾递归"><span class="toc-text">尾递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#柯里化"><span class="toc-text">柯里化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第八章-数组的扩展"><span class="toc-text">第八章 数组的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展运算符"><span class="toc-text">扩展运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-from"><span class="toc-text">Array.from()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-of"><span class="toc-text">Array.of()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组实例的copyWithin"><span class="toc-text">数组实例的copyWithin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组实例的find-和findIndex"><span class="toc-text">数组实例的find()和findIndex()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组实例的fill"><span class="toc-text">数组实例的fill()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组实例的entries-，keys-和values"><span class="toc-text">数组实例的entries()，keys()和values()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#includes"><span class="toc-text">includes()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第九章-对象的扩展"><span class="toc-text">第九章 对象的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性的简洁表示法"><span class="toc-text">属性的简洁表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-is"><span class="toc-text">Object.is()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-assign"><span class="toc-text">Object.assign()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ES6属性的遍历5种方法"><span class="toc-text">ES6属性的遍历5种方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-setPrototypeOf"><span class="toc-text">Object.setPrototypeOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getPrototypeOf"><span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-keys"><span class="toc-text">Object.keys()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-values"><span class="toc-text">Object.values()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-entries"><span class="toc-text">Object.entries()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getOwnPropertyDescriptors"><span class="toc-text">Object.getOwnPropertyDescriptors()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十章-Symbol"><span class="toc-text">第十章 Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol-for-，Symbol-keyFor"><span class="toc-text">Symbol.for()，Symbol.keyFor()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十一章-Set和Map数据结构"><span class="toc-text">第十一章 Set和Map数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set实例的属性和方法"><span class="toc-text">Set实例的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遍历操作"><span class="toc-text">遍历操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map结构的目的和基本用法"><span class="toc-text">Map结构的目的和基本用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第12章-Proxy"><span class="toc-text">第12章 Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#proxy的实例方法"><span class="toc-text">proxy的实例方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第13章-Reflect"><span class="toc-text">第13章 Reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reflect静态方法"><span class="toc-text">Reflect静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第14章-Promise对象"><span class="toc-text">第14章 Promise对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-prototype-then"><span class="toc-text">Promise.prototype.then()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-prototype-catch"><span class="toc-text">Promise.prototype.catch()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-all"><span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-race"><span class="toc-text">Promise.race()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第15章-lterator和for…of循环"><span class="toc-text">第15章 lterator和for…of循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第18章-async函数"><span class="toc-text">第18章 async函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#错误处理"><span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用注意点"><span class="toc-text">使用注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第19章-Class基本语法"><span class="toc-text">第19章 Class基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constructor方法"><span class="toc-text">constructor方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this的指向"><span class="toc-text">this的指向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class的静态方法"><span class="toc-text">Class的静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-target属性"><span class="toc-text">new.target属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第20章-Class的继承"><span class="toc-text">第20章 Class的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getPrototypeOf-1"><span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super关键字"><span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类的prototype属性和proto属性"><span class="toc-text">类的prototype属性和proto属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编程风格"><span class="toc-text">编程风格</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-user">关于我</i></div><div class="avatar"><img src="https://jesse121.github.io/blog/apple-touch-icon.png"></div><div class="author"><p><span class="name">姓名：Jesse</span></p><p><a href="mailto:jesse152@163.com">邮箱：jesse152@163.com</a></p><p><a href="https://github.com/Jesse121" target="_blank">Github: Jesse121</a></p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie">最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/articles/2019/07/23.html">《Javascript设计模式与开发实践》--读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/articles/2019/06/30.html">Base64编码原理及应用</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/articles/2019/06/15.html">CSS 计数器详解</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/articles/2019/05/04.html">为什么使用HTTP2？</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/articles/2019/04/21.html">Docker中Nginx服务器相关配置</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/articles/2019/01/21.html">Docker的安装与使用介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/articles/2019/01/15.html">《Node.js权威指南》--读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/articles/2018/12/23.html">exports与module.exports的区别,export与export.defult区别</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/articles/2018/10/13.html">Node.js学习记录(一)--安装设置篇</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/articles/2018/08/15.html">《React与Redux开发实例精解》--读书笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui">分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/bootstrap/">Bootstrap</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/html-css/">HTML-CSS</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/javascript/">JavaScript</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/mysql/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/node-js/">Node.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/php/">PHP</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/photoshop/">Photoshop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/web/">WEB</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/jquery/">jQuery</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/translation/">前端翻译</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/开发工具/">开发工具</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/mobile/">移动端开发</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/notes/">读书笔记</a><span class="category-list-count">16</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao">标签</i></div><div class="tagcloud"><a href="/blog/tags/yii/" style="font-size:15px">Yii</a> <a href="/blog/tags/css/" style="font-size:15px">CSS</a> <a href="/blog/tags/bootstrap/" style="font-size:15px">Bootstrap</a> <a href="/blog/tags/jquery/" style="font-size:15px">jQuery</a> <a href="/blog/tags/mobile/" style="font-size:15px">Mobile</a> <a href="/blog/tags/javascript/" style="font-size:15px">JavaScript</a> <a href="/blog/tags/mysql/" style="font-size:15px">MySQL</a> <a href="/blog/tags/node-js/" style="font-size:15px">Node.js</a> <a href="/blog/tags/angularjs/" style="font-size:15px">AngularJs</a> <a href="/blog/tags/react/" style="font-size:15px">React</a> <a href="/blog/tags/redux/" style="font-size:15px">Redux</a> <a href="/blog/tags/http/" style="font-size:15px">HTTP</a> <a href="/blog/tags/php/" style="font-size:15px">PHP</a> <a href="/blog/tags/web/" style="font-size:15px">WEB</a> <a href="/blog/tags/photoshop/" style="font-size:15px">Photoshop</a> <a href="/blog/tags/html/" style="font-size:15px">HTML</a> <a href="/blog/tags/docker/" style="font-size:15px">Docker</a> <a href="/blog/tags/nginx/" style="font-size:15px">Nginx</a> <a href="/blog/tags/sublimetext3/" style="font-size:15px">SublimeText3</a> <a href="/blog/tags/webpack/" style="font-size:15px">Webpack</a> <a href="/blog/tags/vue/" style="font-size:15px">Vue</a> <a href="/blog/tags/gulp/" style="font-size:15px">Gulp</a> <a href="/blog/tags/gitlab/" style="font-size:15px">Gitlab</a> <a href="/blog/tags/jenkins/" style="font-size:15px">Jenkins</a> <a href="/blog/tags/vim/" style="font-size:15px">Vim</a> <a href="/blog/tags/git/" style="font-size:15px">Git</a> <a href="/blog/tags/vagrant/" style="font-size:15px">Vagrant</a> <a href="/blog/tags/apache/" style="font-size:15px">Apache</a> <a href="/blog/tags/linux/" style="font-size:15px">Linux</a> <a href="/blog/tags/centos/" style="font-size:15px">CentOS</a> <a href="/blog/tags/https/" style="font-size:15px">HTTPS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive">归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/07/">七月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/06/">六月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/05/">五月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/04/">四月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/01/">一月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/12/">十二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/10/">十月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/08/">八月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/06/">六月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/05/">五月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/04/">四月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/03/">三月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/01/">一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/12/">十二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/11/">十一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/07/">七月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/05/">五月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/04/">四月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/03/">三月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/02/">二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/12/">十二月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/11/">十一月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/10/">十月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/09/">九月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/08/">八月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/07/">七月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/06/">六月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/03/">三月 2016</a><span class="archive-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you">友情链接</i></div><ul><li><a href="http://javascript.ruanyifeng.com/" title="JavaScript 标准参考教程" target="_blank">JavaScript 标准参考教程</a></li><li><a href="http://www.cnblogs.com/lyzg/" title="流云诸葛" target="_blank">流云诸葛</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" title="深入理解JavaScript系列" target="_blank">深入理解JavaScript系列</a></li><li><a href="http://caibaojian.com/page/2" title="前端开发博客" target="_blank">前端开发博客</a></li><li><a href="http://www.cnblogs.com/jesse131/" title="前端开发之路" target="_blank">前端开发之路</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><span>Copyright &copy 2016-2019 <a href="/blog/about/" rel="nofollow">Jesse.</a></span></p><p><span>Total visits：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i></span><span> Theme by <a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake">BlueLake.</a></span><span> Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a></span></p></div></div></div><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?086f9aadcaecfb1c04759719f845d5cf";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];t.src="https"===s?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",document.getElementsByTagName("script")[0].parentNode.appendChild(t)}()</script><script src="/blog/js/bundle.js"></script><script src="//imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:+new Date+"",owner:"Jesse121",repo:"blog",oauth:{client_id:"1d84813ae13cd94072f0",client_secret:"e0a20bd0498c8eb5eb6145c9802b47597d35f35a"}});gitment.render("gitment-ctn")</script></body></html>