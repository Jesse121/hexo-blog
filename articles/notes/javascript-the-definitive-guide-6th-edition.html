<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>《Javascript权威指南》第六版--读书笔记</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="white"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-title" content="我的博客"><meta name="description" content="专注前端开发，前端开发技术博客"><meta name="keywords" content="前端开发，PHP开发，Javascript，前端开发博客"><link rel="dns-prefetch" href="www.jesse131.cn"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="shortcut icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《Javascript权威指南》第六版--读书笔记</h1><a id="logo" href="/.">前端之路</a><p class="description">路漫漫其修远兮，吾将上下而求索</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索..."></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">《Javascript权威指南》第六版--读书笔记</h1><div class="post-meta"><span class="date">2016-10-22</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i> Hits</i></i></span><a href="/articles/notes/javascript-the-definitive-guide-6th-edition.html#comments" class="comment-count"></a></div><div class="post-content"><h3 id="第3章-类型、值和变量"><a href="#第3章-类型、值和变量" class="headerlink" title="第3章 类型、值和变量"></a>第3章 类型、值和变量</h3><h4 id="3-1-数字"><a href="#3-1-数字" class="headerlink" title="3.1 数字"></a>3.1 数字</h4><h5 id="3-1-3-javascript中算术运算符"><a href="#3-1-3-javascript中算术运算符" class="headerlink" title="3.1.3 javascript中算术运算符"></a>3.1.3 javascript中算术运算符</h5><p>isNaN()参数是NaN或一个非数字值返回true<br>isFinite() 参数是NaN,Infinity,-Infinity的时候返回false<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">NaN</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-文本"><a href="#3-2-文本" class="headerlink" title="3.2 文本"></a>3.2 文本</h4><h5 id="3-2-1-字符串直接量"><a href="#3-2-1-字符串直接量" class="headerlink" title="3.2.1 字符串直接量"></a>3.2.1 字符串直接量</h5><p>在ECMAScript5中字符串可以拆分成数行，中间每行必须以反斜线结束<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">"one \</span></span><br><span class="line"><span class="string">two \</span></span><br><span class="line"><span class="string">three"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//one two three</span></span><br></pre></td></tr></table></figure></p>
<p>建议：在javascript中使用单引号表示字符串，在HTML中使用双引号表示字符串;</p>
<h5 id="3-2-2-转义字符"><a href="#3-2-2-转义字符" class="headerlink" title="3.2.2 转义字符"></a>3.2.2 转义字符</h5><p>\n 换行符<br>\r 回车符<br><a id="more"></a></p>
<h4 id="3-3-布尔值"><a href="#3-3-布尔值" class="headerlink" title="3.3 布尔值"></a>3.3 布尔值</h4><p>undefined、null、0、-0、NaN、false、”” 会转化为false,其他值转化为true</p>
<h4 id="3-6-包装对象"><a href="#3-6-包装对象" class="headerlink" title="3.6 包装对象"></a>3.6 包装对象</h4><p>字符串通过new String()构造函数创建一个临时对象，这个对象继承了字符串的方法，并被用来处理属性的引用，一旦引用结束，这个对象自动销毁。<br>数字和布尔值也具有各自的方法，通过Number()和Boolean()构造函数创建一个临时对象，方法均来自这个临时对象<br>null和undefined没有包装对象  </p>
<h4 id="3-10-变量作用域"><a href="#3-10-变量作用域" class="headerlink" title="3.10 变量作用域"></a>3.10 变量作用域</h4><p>在函数体内，局部变量的优先级高于同名的全局变量  </p>
<h5 id="3-10-1-函数作用域和声明提前"><a href="#3-10-1-函数作用域和声明提前" class="headerlink" title="3.10.1 函数作用域和声明提前"></a>3.10.1 函数作用域和声明提前</h5><p>javascript函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，函数声明和变量声明都会被提升</p>
<h5 id="3-10-2-作为属性的变量"><a href="#3-10-2-作为属性的变量" class="headerlink" title="3.10.2 作为属性的变量"></a>3.10.2 作为属性的变量</h5><p>当使用var声明一个变量时，创建的这个属性是不可配置的，这个属性无法通过delete语运算符删除</p>
<h3 id="第4章-表达式和运算符"><a href="#第4章-表达式和运算符" class="headerlink" title="第4章 表达式和运算符"></a>第4章 表达式和运算符</h3><h4 id="4-7-运算符优先级"><a href="#4-7-运算符优先级" class="headerlink" title="4.7 运算符优先级"></a>4.7 运算符优先级</h4><p>参考MDN<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算符优先级</a><br>下面的表将所有运算符按照优先级的不同从高到低排列。  </p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算类型</th>
<th>关联性</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>20</td>
<td>圆括号</td>
<td>n/a</td>
<td>( … )</td>
</tr>
<tr>
<td>19</td>
<td>成员访问</td>
<td>从左到右</td>
<td>… . …</td>
</tr>
<tr>
<td></td>
<td>需计算的成员访问</td>
<td>从左到右</td>
<td>… [ … ]</td>
</tr>
<tr>
<td></td>
<td>new(带参数列表)</td>
<td>n/a</td>
<td>new … ( … )</td>
</tr>
<tr>
<td></td>
<td>函数调用</td>
<td>从左到右</td>
<td>… ( … )</td>
</tr>
<tr>
<td>18</td>
<td>new (无参数列表)</td>
<td>从右到左</td>
<td>new …</td>
</tr>
<tr>
<td>17</td>
<td>后置递增(运算符在后)</td>
<td>n/a</td>
<td>… ++</td>
</tr>
<tr>
<td></td>
<td>后置递减(运算符在后)</td>
<td>n/a</td>
<td>… –</td>
</tr>
<tr>
<td>16</td>
<td>逻辑非</td>
<td>从右到左</td>
<td>! …</td>
</tr>
<tr>
<td></td>
<td>按位非</td>
<td>从右到左</td>
<td>~ …</td>
</tr>
<tr>
<td></td>
<td>一元加法</td>
<td>从右到左</td>
<td>+ …</td>
</tr>
<tr>
<td></td>
<td>一元减法</td>
<td>从右到左</td>
<td>- …</td>
</tr>
<tr>
<td></td>
<td>前置递增</td>
<td>从右到左</td>
<td>++ …</td>
</tr>
<tr>
<td></td>
<td>前置递减</td>
<td>从右到左</td>
<td>– …</td>
</tr>
<tr>
<td></td>
<td>typeof</td>
<td>从右到左</td>
<td>typeof …</td>
</tr>
<tr>
<td></td>
<td>void</td>
<td>从右到左</td>
<td>void …</td>
</tr>
<tr>
<td></td>
<td>delete</td>
<td>从右到左</td>
<td>delete …</td>
</tr>
<tr>
<td>15</td>
<td>幂</td>
<td>从右到左</td>
<td>… ** …</td>
</tr>
<tr>
<td>14</td>
<td>乘法</td>
<td>从左到右</td>
<td>… * …</td>
</tr>
<tr>
<td></td>
<td>除法</td>
<td>从左到右</td>
<td>… / …</td>
</tr>
<tr>
<td></td>
<td>取模</td>
<td>从左到右</td>
<td>… % …</td>
</tr>
<tr>
<td>13</td>
<td>加法</td>
<td>从左到右</td>
<td>… + …</td>
</tr>
<tr>
<td></td>
<td>减法</td>
<td>从左到右</td>
<td>… - …</td>
</tr>
<tr>
<td>12</td>
<td>按位左移</td>
<td>从左到右</td>
<td>… &lt;&lt; …</td>
</tr>
<tr>
<td></td>
<td>按位右移</td>
<td>从左到右</td>
<td>… &gt;&gt; …</td>
</tr>
<tr>
<td></td>
<td>无符号右移</td>
<td>从左到右</td>
<td>… &gt;&gt;&gt; …</td>
</tr>
<tr>
<td>11</td>
<td>小于</td>
<td>从左到右</td>
<td>… &lt; …</td>
</tr>
<tr>
<td></td>
<td>小于等于</td>
<td>从左到右</td>
<td>… &lt;= …</td>
</tr>
<tr>
<td></td>
<td>大于</td>
<td>从左到右</td>
<td>… &gt; …</td>
</tr>
<tr>
<td></td>
<td>大于等于</td>
<td>从左到右</td>
<td>… &gt;= …</td>
</tr>
<tr>
<td></td>
<td>in</td>
<td>从左到右</td>
<td>… in …</td>
</tr>
<tr>
<td></td>
<td>instanceof</td>
<td>从左到右</td>
<td>… instanceof …</td>
</tr>
<tr>
<td>10</td>
<td>等号</td>
<td>从左到右</td>
<td>… == …</td>
</tr>
<tr>
<td></td>
<td>非等号</td>
<td>从左到右</td>
<td>… != …</td>
</tr>
<tr>
<td></td>
<td>全等号</td>
<td>从左到右</td>
<td>… === …</td>
</tr>
<tr>
<td></td>
<td>非全等号</td>
<td>从左到右</td>
<td>… !== …</td>
</tr>
<tr>
<td>9</td>
<td>按位与</td>
<td>从左到右</td>
<td>… &amp; …</td>
</tr>
<tr>
<td>8</td>
<td>按位异或</td>
<td>从左到右</td>
<td>… ^ …</td>
</tr>
<tr>
<td>7</td>
<td>按位或</td>
<td>从左到右</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>6</td>
<td>逻辑与</td>
<td>从左到右</td>
<td>… &amp;&amp; …</td>
</tr>
<tr>
<td>5</td>
<td>逻辑或</td>
<td>从左到右</td>
<td>…</td>
<td></td>
<td>…</td>
</tr>
<tr>
<td>4</td>
<td>条件运算符</td>
<td>从右到左</td>
<td>… ? … : …</td>
</tr>
<tr>
<td>3</td>
<td>赋值</td>
<td>从右到左</td>
<td>… = …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… += …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… -= …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… *= …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… /= …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… %= …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… &lt;&lt;= …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… &gt;&gt;= …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… &gt;&gt;&gt;= …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… &amp;= …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… ^= …</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>…</td>
<td>= …</td>
</tr>
<tr>
<td>2</td>
<td>yield</td>
<td>从右到左</td>
<td>yield …</td>
</tr>
<tr>
<td></td>
<td>yield*</td>
<td>从右到左</td>
<td>yield* …</td>
</tr>
<tr>
<td>1</td>
<td>展开运算符</td>
<td>n/a</td>
<td>… …</td>
</tr>
<tr>
<td>0</td>
<td>逗号</td>
<td>从左到右</td>
<td>… , …</td>
</tr>
</tbody>
</table>
<h5 id="4-9-4-instanceof-运算符"><a href="#4-9-4-instanceof-运算符" class="headerlink" title="4.9.4 instanceof 运算符"></a>4.9.4 instanceof 运算符</h5><p>为了计算表达式 <code>o instanceof f</code>,javascript首先计算f.prototype,然后在o的原型链中查找f.prototype,如果找到则表达式返回true，否则返回false</p>
<h5 id="4-13-3-delete-运算符"><a href="#4-13-3-delete-运算符" class="headerlink" title="4.13.3 delete 运算符"></a>4.13.3 delete 运算符</h5><p>并不是所有的属性都可以删除<br>内置核心和客户端属性是不能删除<br>用户通过var语句声明的变量不能删除<br>function语句定义的函数和函数参数也是不能删除 </p>
<h3 id="第5章-语句"><a href="#第5章-语句" class="headerlink" title="第5章 语句"></a>第5章 语句</h3><h4 id="5-2-复合语句和空语句"><a href="#5-2-复合语句和空语句" class="headerlink" title="5.2 复合语句和空语句"></a>5.2 复合语句和空语句</h4><p>语句块的结尾不需要分号，块中原始语句必须以分号结束  </p>
<h4 id="5-7-3-“use-strict”"><a href="#5-7-3-“use-strict”" class="headerlink" title="5.7.3 “use strict”"></a>5.7.3 “use strict”</h4><p>严格模式和非严格模式之间的区别：</p>
<ul>
<li>严格模式中禁止使用with语句</li>
<li>严格模式中所有变量要先声明，否则将会抛出一个引用错误异常</li>
<li>严格模式用调用的函数中的一个this值是undefined，在非严格模式中，this值总是全局变量。这可以用来判断是否支持严格模式<code>var hasStrictMode = (fuction(){&quot;use strict&quot;;return this === undefined}())</code></li>
<li>严格模式中，当通过call()或apply()来调用函数时，其中的this就是call()或apply()传入的第一个参数</li>
<li>严格模式中，给只读属性和给不可扩展的对象创建新成员都将抛出一个类型错误</li>
<li>严格模式中，传入eval()的代码不能再调用程序所在的上下文中声明变量或定义函数</li>
<li>严格模式中，函数里的arguments对象拥有传入函数值的静态副本，在非严格模式中，arguments里的数组元素和函数参数都指向同一个值的引用</li>
<li>严格模式中试图删除一个不可配置的属性将抛出一个类型错误</li>
<li>严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误</li>
<li>严格模式中，函数声明中存在两个或多个同名参数将产生一个语法错误</li>
<li>严格模式中，不允许使用八进制直接量</li>
<li>严格模式中，arguments,caller和arguments.callee都将抛出一个类型错误。</li>
</ul>
<h3 id="第6章-对象"><a href="#第6章-对象" class="headerlink" title="第6章 对象"></a>第6章 对象</h3><h4 id="6-1-创建对象"><a href="#6-1-创建对象" class="headerlink" title="6.1 创建对象"></a>6.1 创建对象</h4><p>可通过对象直接量、关键字New、Object.create()来创建对象</p>
<h5 id="6-1-3-原型"><a href="#6-1-3-原型" class="headerlink" title="6.1.3 原型"></a>6.1.3 原型</h5><p>Object.prototype没有原型对象，它不继承任何属性，所有内置构造函数都继承自它 </p>
<h5 id="6-1-4-Object-create"><a href="#6-1-4-Object-create" class="headerlink" title="6.1.4 Object.create()"></a>6.1.4 Object.create()</h5><p>使用Object.create()创建一个新对象，其中第一个参数是这个对象的原型，第二个参数是可选的属性描述符<br>var o = Object.create(null); //o是一个没有原型的对象<br>以下是IE8兼容方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create != <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Temp</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> hasOwn = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">O</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> O != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'Object prototype may only be an Object or null'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Temp.prototype = O;</span><br><span class="line">      <span class="keyword">var</span> obj = <span class="keyword">new</span> Temp();</span><br><span class="line">      Temp.prototype = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> Properties = <span class="built_in">Object</span>(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> Properties) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hasOwn.call(Properties, prop)) &#123;</span><br><span class="line">            obj[prop] = Properties[prop];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-2-属性的查询和设置"><a href="#6-2-属性的查询和设置" class="headerlink" title="6.2 属性的查询和设置"></a>6.2 属性的查询和设置</h4><p>当使用方括号([])运算符来获取属性的值时，方括号内的表达式必须返回字符串，或者是一个可以返回字符串的值</p>
<h4 id="6-3-删除属性"><a href="#6-3-删除属性" class="headerlink" title="6.3 删除属性"></a>6.3 删除属性</h4><p>delete只是断开属性和宿主对象的联系，而不去操作属性中的属性<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;<span class="attr">p</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a.p;</span><br><span class="line"><span class="keyword">delete</span> a.p;</span><br><span class="line"><span class="built_in">console</span>.log(b.x);</span><br></pre></td></tr></table></figure></p>
<p>delete运算符只能删除自有属性，不能删除继承属性。<br>delete表达式删除成功后，返回true  </p>
<h4 id="6-4-检测属性"><a href="#6-4-检测属性" class="headerlink" title="6.4 检测属性"></a>6.4 检测属性</h4><p>判断某个属性是否存在于某个对象中，可以通过in运算符、 hasOwnProperty()、propertyIsEnumerable()方法来判断<br>propertyIsEnumerable()只有检测到是自有属性，且这个属性的可枚举性为true时才返回true<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(&#123;<span class="attr">y</span>:<span class="number">2</span>&#125;);</span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">"x"</span>); <span class="comment">//true;</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">"y"</span>); <span class="comment">//false;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6-5-枚举属性"><a href="#6-5-枚举属性" class="headerlink" title="6.5 枚举属性"></a>6.5 枚举属性</h4><p>对象继承的内置方法不可枚举，但在代码中给对象添加的属性都是可枚举的（除非将他们转换为不可枚举的）<br>ECMAScript5定义了两个用以枚举属性名称的函数：</p>
<ul>
<li>Object.keys(),返回一个由对象中可枚举的自有属性的名称组成的数组</li>
<li>Object.getOwnPropertyNames(),只返回对象的所有自有属性的名称<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="built_in">Object</span>.keys(arr); <span class="comment">//["0", "1", "2"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(arr); <span class="comment">// ["0", "1", "2", "length"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-8-对象的三个属性"><a href="#6-8-对象的三个属性" class="headerlink" title="6.8 对象的三个属性"></a>6.8 对象的三个属性</h4><h4 id="6-8-1-原型属性-proto"><a href="#6-8-1-原型属性-proto" class="headerlink" title="6.8.1 原型属性 proto"></a>6.8.1 原型属性 <strong>proto</strong></h4><p>通过对象直接量创建的对象使用Object.prototype作为他们的原型<br>通过new创建的对象使用构造函数的prototype属性作为他们的原型<br>通过Object.create()创建的对象使用第一个参数作为他们的原型<br>将对象作为参数传入Object.getPrototypeOf()可以查询它的原型<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(b) === a;  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>想要检测一个对象是否是另一个对象的原型可以使用isPrototypeOf()方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line">a.isPrototypeOf(b);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6-8-2-类属性-object-class"><a href="#6-8-2-类属性-object-class" class="headerlink" title="6.8.2 类属性 [object class]"></a>6.8.2 类属性 [object class]</h4><p>对象的类属性是一个字符串，用以表示对象的类型信息<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(a).slice(<span class="number">8</span>,<span class="number">-1</span>);  <span class="comment">//Object</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6-8-3-可扩展性"><a href="#6-8-3-可扩展性" class="headerlink" title="6.8.3 可扩展性"></a>6.8.3 可扩展性</h4><p>Object.preventExtensions()  将对象转为不可扩展的<br>Object.seal() 将对象转为不可扩展的,且将对象的所有自有属性设置为不可配置<br>Object.freeze() 将对象转为不可扩展的,且将对象的所有自有属性设置为不可配置,将自有的所有数据属性设置为只读  </p>
<h3 id="第7章-数组"><a href="#第7章-数组" class="headerlink" title="第7章 数组"></a>第7章 数组</h3><h4 id="7-5-数组元素的添加和删除"><a href="#7-5-数组元素的添加和删除" class="headerlink" title="7.5 数组元素的添加和删除"></a>7.5 数组元素的添加和删除</h4><p>用delete删除数组元素与为其赋undefined值是类似的，注意：使用delete删除数组元素的时候不会修改数组的length属性，也不会将元素从高索引处移下来填充已删除属性留下来的空白</p>
<h4 id="7-8-数组方法"><a href="#7-8-数组方法" class="headerlink" title="7.8 数组方法"></a>7.8 数组方法</h4><h5 id="7-8-3-sort"><a href="#7-8-3-sort" class="headerlink" title="7.8.3 sort()"></a>7.8.3 sort()</h5><p>为了按照其他方式而非字符顺序进行数组排序，必须给sort()方法传递一个比较函数，该函数决定了它的两个参数在排好序的数组中的先后顺序。<br>假设第一个参数在前，比较函数应该返回一个小于0的数，第一个参数在后，比较函数返回一个大于0的数</p>
<h5 id="7-8-5-slice"><a href="#7-8-5-slice" class="headerlink" title="7.8.5 slice()"></a>7.8.5 slice()</h5><p>该方法返回数组的一个片段或子数组<br>当参数中出现负数，-1指定了最后一个元素</p>
<h5 id="7-8-7-push-pop-shift-unshift"><a href="#7-8-7-push-pop-shift-unshift" class="headerlink" title="7.8.7 push() pop() shift() unshift()"></a>7.8.7 push() pop() shift() unshift()</h5><p>pop() 返回数组尾部删除的值<br>unshift() 返回数组头部删除的值</p>
<h4 id="7-9-ECMAScript5中定义的数组方法"><a href="#7-9-ECMAScript5中定义的数组方法" class="headerlink" title="7.9 ECMAScript5中定义的数组方法"></a>7.9 ECMAScript5中定义的数组方法</h4><ol>
<li>forEach()<br>该方法遍历数组，为每个元素调用指定的函数  </li>
<li><p>map()<br>该方法调用数组的每个元素传递给指定的函数，并返回一个数组。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">&#125;); <span class="comment">//b = [1,4,9]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter()<br>该方法返回的数组元素是调用的数组的一个子集，传递的函数是用来逻辑判定的  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">samllValue = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">3</span></span><br><span class="line">&#125;);  <span class="comment">//[1,2]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>every()和some()<br>every()当且仅当针对数组中所有元素调用判定函数都返回true，它才返回true。<br>some()当针对数组中所有元素调用判定函数都返回false，它才返回false  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> &#125;)  <span class="comment">//true</span></span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>&#125;) <span class="comment">//false</span></span><br><span class="line">a.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span> &#125;) <span class="comment">//true</span></span><br><span class="line">a.some(<span class="built_in">isNaN</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>一旦every()和some()确认返回什么值他们就会停止遍历数组元素</p>
<ol>
<li>reduce()和reduceRight()<br>使用指定的函数将数组元素进行组合，生成单个值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x + y &#125;,<span class="number">0</span>); <span class="comment">//15</span></span><br><span class="line"><span class="keyword">var</span> max = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123; <span class="keyword">return</span> (x&gt;y) ? x : y;&#125;)  <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>reduce()第一个参数执行化简操作的函数，该函数的x参数是数组的元素，y参数是上一次操作的结果值，第二个参数是一个传递给函数的初始值，当没有初始值时默认为数组第一个元素<br>reduceRight()按照数组的索引从高到低处理数组</p>
<h4 id="7-11-类数组对象"><a href="#7-11-类数组对象" class="headerlink" title="7.11 类数组对象"></a>7.11 类数组对象</h4><p>javascript数组的一些特性是其他对象所没有的：</p>
<ul>
<li>当有新的元素添加到列表时，自动更新length属性</li>
<li>设置length属性为一个较小值时将截断数组</li>
<li>从Array.prototype中继承一些有用的方法</li>
<li>其类属性为Array</li>
</ul>
<h3 id="第8章-函数"><a href="#第8章-函数" class="headerlink" title="第8章 函数"></a>第8章 函数</h3><h4 id="8-2-函数调用"><a href="#8-2-函数调用" class="headerlink" title="8.2 函数调用"></a>8.2 函数调用</h4><h5 id="8-2-1-函数调用"><a href="#8-2-1-函数调用" class="headerlink" title="8.2.1 函数调用"></a>8.2.1 函数调用</h5><p>根据ECMAscript3和非严格的ECMAscript5对函数调用规定，调用上下文(this)是全局对象，在非严格模式下，调用上下文是window对象  </p>
<h5 id="8-2-2-方法调用"><a href="#8-2-2-方法调用" class="headerlink" title="8.2.2 方法调用"></a>8.2.2 方法调用</h5><p>如果函数表达式是一个属性访问表达式，即该函数是一个对象的属性或数组中的一个元素，那么它就是一个方法调用表达式<br>属性访问表达式由两部分组成，一个对象和一个属性名称，这个对象成为调用上下文，函数体可以使用this引用该对象  </p>
<h5 id="8-2-3-构造函数调用"><a href="#8-2-3-构造函数调用" class="headerlink" title="8.2.3 构造函数调用"></a>8.2.3 构造函数调用</h5><p>构造函数调用会创建一个新的对象，这个对象继承自构造函数的prototype属性，构造函数试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数可以使用this来引用这个新创建的对象  </p>
<h5 id="8-2-4-间接调用"><a href="#8-2-4-间接调用" class="headerlink" title="8.2.4 间接调用"></a>8.2.4 间接调用</h5><p>call()和apply()可以用来间接的调用函数，两个方法都允许显示指定调用所需的this的值，也就是说任何函数可以作为任何对象的方法来调用  </p>
<h4 id="8-3-函数的实参和形参"><a href="#8-3-函数的实参和形参" class="headerlink" title="8.3 函数的实参和形参"></a>8.3 函数的实参和形参</h4><h5 id="8-3-2-可变长的实参列表：实参对象"><a href="#8-3-2-可变长的实参列表：实参对象" class="headerlink" title="8.3.2 可变长的实参列表：实参对象"></a>8.3.2 可变长的实参列表：实参对象</h5><p>在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="literal">null</span>; <span class="comment">//修改实参数组的元素同样会修改x的值</span></span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">//null </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在ECMAScript5中移除了arguments属性  </p>
<h4 id="8-4-自定义函数属性"><a href="#8-4-自定义函数属性" class="headerlink" title="8.4 自定义函数属性"></a>8.4 自定义函数属性</h4><p>当函数需要一个静态变量在调用时保持某个值不变，最方便的就是给函数定义属性，而不是定义全局变量</p>
<h4 id="8-6-闭包"><a href="#8-6-闭包" class="headerlink" title="8.6 闭包"></a>8.6 闭包</h4><p>JavaScript采用词法作用域，这个作用域是在函数定义时决定的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"globlescope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"localscope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> scope;&#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()(); <span class="comment">//localscope</span></span><br></pre></td></tr></table></figure></p>
<h4 id="8-7-函数的属性方法和构造函数"><a href="#8-7-函数的属性方法和构造函数" class="headerlink" title="8.7 函数的属性方法和构造函数"></a>8.7 函数的属性方法和构造函数</h4><h5 id="8-7-3-call-和apply"><a href="#8-7-3-call-和apply" class="headerlink" title="8.7.3 call()和apply()"></a>8.7.3 call()和apply()</h5><p>要想以对象o的方法来调用f函数，可以这样使用：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.call(o)</span><br><span class="line">f.apply(o)</span><br></pre></td></tr></table></figure></p>
<p>call()和apply()的第一个实参是要调用函数的母对象，它是调用上下文，在函数内通过this来获得它的引用<br>两者区别：<br>对call()来说，第二个参数是要传入待调用函数的值，所传入参数一一列出<br>apply()第二个参数可以以参数数组(既可以是类数组也可以是真实数组)的形式传入</p>
<h5 id="8-7-4-bind"><a href="#8-7-4-bind" class="headerlink" title="8.7.4 bind()"></a>8.7.4 bind()</h5><p>当在函数f()上调用bind()方法并传入一个对象o作为参数，这个方法将返回一个新函数。新函数将会把原始函数f()当做o的方法来调用，传入新函数的任何实参都将传入原始函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x + y; &#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);</span><br><span class="line">g(<span class="number">2</span>)  <span class="comment">//3</span></span><br></pre></td></tr></table></figure></p>
<p>ECMAScript5中bind()方法不仅仅是将函数绑定至一个对象，传入bind()的实参也会绑定至this。这种编程技术被称为“柯里化”<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x + y&#125;;</span><br><span class="line"><span class="comment">//创建一个类似sum的新函数，但this的值绑定到null</span></span><br><span class="line"><span class="comment">//并且第一个参数绑定1，这个新函数期望只传入一个实参</span></span><br><span class="line"><span class="keyword">var</span> succ = sum.bind(<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line">succ(<span class="number">2</span>)  <span class="comment">//3</span></span><br></pre></td></tr></table></figure></p>
<h5 id="8-7-6-Function-构造函数"><a href="#8-7-6-Function-构造函数" class="headerlink" title="8.7.6 Function()构造函数"></a>8.7.6 Function()构造函数</h5><p>Function()构造函数所创建的函数并不使用词法作用域，函数体代码的编译总会在顶层函数执行，相当于全函数中的eval()<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"return scope"</span>);</span><br><span class="line">&#125;</span><br><span class="line">constructFunction()(); <span class="comment">//global</span></span><br></pre></td></tr></table></figure></p>
<h3 id="第9章-类和模块"><a href="#第9章-类和模块" class="headerlink" title="第9章 类和模块"></a>第9章 类和模块</h3><h4 id="9-2-类和构造函数"><a href="#9-2-类和构造函数" class="headerlink" title="9.2 类和构造函数"></a>9.2 类和构造函数</h4><h5 id="9-2-1-构造函数和类的标识符"><a href="#9-2-1-构造函数和类的标识符" class="headerlink" title="9.2.1 构造函数和类的标识符"></a>9.2.1 构造函数和类的标识符</h5><p>a instanceof b 本质是检测a对象是否继承自b.prototype<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.__proto__ === b.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="9-5-类和类型"><a href="#9-5-类和类型" class="headerlink" title="9.5 类和类型"></a>9.5 类和类型</h4><p>几种用以检测对象的类的技术：</p>
<h5 id="9-5-1-instanceof-运算符"><a href="#9-5-1-instanceof-运算符" class="headerlink" title="9.5.1 instanceof 运算符"></a>9.5.1 instanceof 运算符</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">    <span class="keyword">this</span>.to = to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>:Range,</span><br><span class="line">    includes: function(x) &#123; <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to; &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from); x &lt;= <span class="keyword">this</span>.to; x++) f(x);</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"("</span> + <span class="keyword">this</span>.from + <span class="string">"..."</span> + <span class="keyword">this</span>.to + <span class="string">")"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Range(<span class="number">1</span>,<span class="number">3</span>); </span><br><span class="line">r <span class="keyword">instanceof</span> Range; <span class="comment">//true</span></span><br><span class="line">Range.prototype.isPrototypeOf(r); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h5 id="9-5-2-constructor属性"><a href="#9-5-2-constructor属性" class="headerlink" title="9.5.2 constructor属性"></a>9.5.2 constructor属性</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">r.constructor == Range;</span><br></pre></td></tr></table></figure>
<h5 id="9-5-3-构造函数的名称"><a href="#9-5-3-构造函数的名称" class="headerlink" title="9.5.3 构造函数的名称"></a>9.5.3 构造函数的名称</h5><h5 id="9-5-4-鸭式辩型思想"><a href="#9-5-4-鸭式辩型思想" class="headerlink" title="9.5.4 鸭式辩型思想"></a>9.5.4 鸭式辩型思想</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quacks</span>(<span class="params">o <span class="regexp">/*, ... */</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;  <span class="comment">// for each argument after o</span></span><br><span class="line">        <span class="keyword">var</span> arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">typeof</span> arg) &#123; <span class="comment">// If arg is a:</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'string'</span>:       <span class="comment">// string: check for a method with that name</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> o[arg] !== <span class="string">"function"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'function'</span>:     <span class="comment">// function: use the prototype object instead</span></span><br><span class="line">            <span class="comment">// If the argument is a function, we use its prototype object</span></span><br><span class="line">            arg = arg.prototype;</span><br><span class="line">            <span class="comment">// fall through to the next case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'object'</span>:       <span class="comment">// object: check for matching methods</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> m <span class="keyword">in</span> arg) &#123; <span class="comment">// For each property of the object</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> arg[m] !== <span class="string">"function"</span>) <span class="keyword">continue</span>; <span class="comment">// skip non-methods</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> o[m] !== <span class="string">"function"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If we're still here, then o implements everything</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-8-ES5中的类"><a href="#9-8-ES5中的类" class="headerlink" title="9.8 ES5中的类"></a>9.8 ES5中的类</h4><h5 id="9-8-1-让属性不可枚举"><a href="#9-8-1-让属性不可枚举" class="headerlink" title="9.8.1 让属性不可枚举"></a>9.8.1 让属性不可枚举</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.definedProperty(<span class="built_in">Object</span>.prototype,<span class="string">"objectId"</span>,&#123;</span><br><span class="line">  get:idGetter,</span><br><span class="line">  enumerable:<span class="literal">false</span>,</span><br><span class="line">  configurable:<span class="literal">false</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h5 id="9-8-4-防止类的扩展"><a href="#9-8-4-防止类的扩展" class="headerlink" title="9.8.4 防止类的扩展"></a>9.8.4 防止类的扩展</h5><p>Object.preventExtensions()将对象设置为不可扩展<br>Object.seal()阻止用户给对象添加新属性<br>Object.freeze()将所有属性设置为只读和不可配置  </p>
<h3 id="第10章-正则表达式的模式匹配"><a href="#第10章-正则表达式的模式匹配" class="headerlink" title="第10章 正则表达式的模式匹配"></a>第10章 正则表达式的模式匹配</h3><h4 id="10-1-正则表达式的定义"><a href="#10-1-正则表达式的定义" class="headerlink" title="10.1 正则表达式的定义"></a>10.1 正则表达式的定义</h4><p>ECMAScript5规定一个正则表达式直接量会在执行到它时转化为一个正则对象，同一段代码每次运算都返回新对象</p>
<h5 id="10-1-1-直接量字符"><a href="#10-1-1-直接量字符" class="headerlink" title="10.1.1 直接量字符"></a>10.1.1 直接量字符</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">^ $ . * + ? = ! : | \ / () [] &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在正则表达式中使用这些字符的直接量进行匹配，则必须使用前缀\</p>
<h5 id="10-1-2-字符类"><a href="#10-1-2-字符类" class="headerlink" title="10.1.2 字符类"></a>10.1.2 字符类</h5><p>将直接量字符单独放进方括号内就组成了字符类，一个字符类可以匹配它所包含的任意字符<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/[abc]/</span>        匹配a,b,c中任意一个</span><br><span class="line"><span class="regexp">/[^abc]/</span>       匹配abc之外的所有字符</span><br><span class="line"><span class="regexp">/[a-zA-Z0-9]/</span>  匹配拉丁字母表中任何字母和数字</span><br><span class="line"><span class="regexp">/[...]/</span>        匹配方括号内任意字符</span><br><span class="line"><span class="regexp">/[^...]/</span>       匹配不在方括号内任意字符</span><br><span class="line"><span class="regexp">/./</span>            匹配除换行符和其他Unicode行终止符之外的任意字符</span><br><span class="line"><span class="regexp">/\w/</span>           匹配包括下划线在内的任何ASCII字符组成的单词  类似但不等价于<span class="regexp">/[a-zA-Z0-9_]/</span></span><br><span class="line"><span class="regexp">/\W/</span>           匹配任何不是ASCII字符组成的单词  等价于<span class="regexp">/[^a-zA-Z0-9_]/</span></span><br><span class="line"><span class="regexp">/\d/</span>           匹配任何ASCII数字   等价于<span class="regexp">/[0-9]/</span></span><br><span class="line"><span class="regexp">/\D/</span>           匹配除ASCII数字之外的任何字符   等价于<span class="regexp">/[^0-9]/</span></span><br><span class="line"><span class="regexp">/\s/</span>           匹配任何Unicode空白符</span><br><span class="line"><span class="regexp">/\S/</span>           匹配任何非Unicode空白符</span><br></pre></td></tr></table></figure></p>
<h5 id="10-3-重复"><a href="#10-3-重复" class="headerlink" title="10.3 重复"></a>10.3 重复</h5><p>正则表达式的重复字符语法<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">&#123;n,m&#125;          匹配前一项至少n次，但不能超过m次</span><br><span class="line">&#123;n,&#125;           匹配前一项n次或者更多</span><br><span class="line">&#123;n&#125;            匹配前一项n次</span><br><span class="line">?              匹配前一项<span class="number">0</span>次或<span class="number">1</span>次  等价于&#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">+              匹配前一项<span class="number">1</span>次或多次  等价于&#123;<span class="number">1</span>,&#125;</span><br><span class="line">*              匹配前一项<span class="number">0</span>次或多次  等价于&#123;<span class="number">0</span>,&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>?</code>,<code>*</code>时要注意，由于这些字符串可能匹配0个字符，因此他们允许什么都不匹配<br><strong>非贪婪的重复</strong><br>非贪婪的重复即尽可能少的匹配，只须在待匹配的字符后跟随一个问号即可<code>/a+?/</code></p>
<h5 id="10-1-4-选择分组和引用"><a href="#10-1-4-选择分组和引用" class="headerlink" title="10.1.4 选择分组和引用"></a>10.1.4 选择分组和引用</h5><p>字符”|”用于分隔供选择的字符<br><code>/\d{3}|[a-z]{4}/</code>匹配的是三位数字或者四个小写字母<br><strong>注意</strong>选择项的匹配次序是从左到右，直到发现匹配项，如果左边的选择项匹配，就忽略右边的匹配项<br>正则表达式圆括号的多种用途：</p>
<ul>
<li>把单独的项组成子表达式，以便通过”*+？|”进行修饰  /java(script)?/</li>
<li>允许在同一正则表达式的后部引用前面的子表达式    \1引用的是第一个带圆括号的子表达式</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">|       匹配的是该表达式左边或右边的子表达式</span></span><br><span class="line">(...)   将几个项组合为一个单元，这个单元可通过“*”，“+”，“？”和“<span class="string">|”等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后的引用使用</span></span><br><span class="line">(?...)   只组合，把项组合带一个单元，但不记忆与该组相匹配的字符</span><br><span class="line">\n      和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式</span><br></pre></td></tr></table></figure>
<h5 id="10-1-5-指定匹配位置"><a href="#10-1-5-指定匹配位置" class="headerlink" title="10.1.5 指定匹配位置"></a>10.1.5 指定匹配位置</h5><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">^       匹配字符串的开头，在多行检索中匹配一行的开头</span><br><span class="line">$       匹配字符串的结尾，在多行检索中匹配一行的结尾</span><br><span class="line"><span class="symbol">\b</span>      匹配一个单词的边界，简言之就是位于字符<span class="symbol">\w</span>和<span class="symbol">\W</span>之间的位置，或位于字符<span class="symbol">\W</span>和字符串的开头或者结尾之间的位置</span><br><span class="line"><span class="symbol">\B</span>      匹配非单词边界的位置</span><br><span class="line">(?=p)   零宽正向先行断言，要求接下来的字符都与p匹配，但不包括匹配p的那些字符</span><br><span class="line">(?=p)   零宽负向先行断言，要求接下来的字符都不与p匹配</span><br></pre></td></tr></table></figure>
<h5 id="10-1-6-修饰符"><a href="#10-1-6-修饰符" class="headerlink" title="10.1.6 修饰符"></a>10.1.6 修饰符</h5><ul>
<li>i 执行不区分大小写的匹配</li>
<li>g 执行一个全局匹配</li>
<li>m 多行匹配模式</li>
</ul>
<h4 id="10-2-用于模式匹配的String方法"><a href="#10-2-用于模式匹配的String方法" class="headerlink" title="10.2 用于模式匹配的String方法"></a>10.2 用于模式匹配的String方法</h4><p>search() 返回第一个与之匹配的子串的起始位置，如果找不到匹配则返回-1。该方法不支持全局检索<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"javascript"</span>.search(<span class="regexp">/script/i</span>);  <span class="comment">//4</span></span><br></pre></td></tr></table></figure></p>
<p>replace() 用于检索与替换操作<br>第一个参数是一个正则表达式，第二个参数是要进行替换的字符串。如正则表达式不带修饰符g，则只替换所匹配的第一个子串<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"javascript is a good language"</span>;</span><br><span class="line">text.replace(<span class="regexp">/javascript/gi</span>,<span class="string">"JavaScript"</span>); <span class="comment">//"JavaScript is a good language"</span></span><br><span class="line"><span class="keyword">var</span> quote = <span class="regexp">/"([^"]*)"/g</span>;</span><br><span class="line">text.replace(quote,<span class="string">'“$1”'</span>);</span><br></pre></td></tr></table></figure></p>
<p>match(正则表达式) 返回的是一个由匹配结果组成的数组<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"1 plus 2 euqals 3"</span>.match(<span class="regexp">/\d+/g</span>);   <span class="comment">//["1", "2", "3"]</span></span><br></pre></td></tr></table></figure></p>
<p>split() 这个方法用以将调用它的字符串拆分为一个子串组成的数组<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"1, 2, 3, 4"</span>.split(<span class="regexp">/\s*,\s*/</span>);   <span class="comment">//["1","2","3","4"]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="10-3-RexExp对象"><a href="#10-3-RexExp对象" class="headerlink" title="10.3 RexExp对象"></a>10.3 RexExp对象</h4><h5 id="10-3-2-RexExp的方法"><a href="#10-3-2-RexExp的方法" class="headerlink" title="10.3.2 RexExp的方法"></a>10.3.2 RexExp的方法</h5><p>exec()方法对一个字符串执行检索匹配，没找到任何匹配返回null，找到就返回一个数组<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"JavaScript is more fun than Java!"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = ;</span><br><span class="line">/Java/g.exec(text); <span class="comment">//["Java", index: 0, input: "JavaScript is more fun than Java!"]</span></span><br></pre></td></tr></table></figure></p>
<p>test()对某个字符串检测，如果包含正则表达的一个匹配结果，则返回true<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/java/i.test(<span class="string">"javascript"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="第11章-javascript的子集和扩展"><a href="#第11章-javascript的子集和扩展" class="headerlink" title="第11章 javascript的子集和扩展"></a>第11章 javascript的子集和扩展</h3><p>这部分扩展可参考《ECMAscript6标准入门》第二版</p>
<h3 id="第12章-服务器端javascript"><a href="#第12章-服务器端javascript" class="headerlink" title="第12章 服务器端javascript"></a>第12章 服务器端javascript</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.version    <span class="comment">//node版本计信系</span></span><br><span class="line">process.argv       <span class="comment">//node命令行数组参数</span></span><br><span class="line">process.env        <span class="comment">// 环境变量对象</span></span><br><span class="line">process.cwd()      <span class="comment">//返回当前工作目录</span></span><br><span class="line">process.chdir()    <span class="comment">//改变目录</span></span><br><span class="line">process.exitr()    <span class="comment">//退出</span></span><br></pre></td></tr></table></figure>
<h3 id="第13章-web浏览器中的javascript"><a href="#第13章-web浏览器中的javascript" class="headerlink" title="第13章 web浏览器中的javascript"></a>第13章 web浏览器中的javascript</h3><h4 id="13-3-javascript程序的执行"><a href="#13-3-javascript程序的执行" class="headerlink" title="13.3 javascript程序的执行"></a>13.3 javascript程序的执行</h4><p>web页面嵌入一个iframe窗体，文档中的js代码和被嵌入文档（iframe窗体）中js代码会有不同的全局对象<br>javascript程序的执行有两个阶段，第一阶段载入文档内容并执行script元素中的代码（包括内敛脚本和外部脚本）。所有脚本执行完后进入第二阶段，这个阶段是异步的，由时间驱动，web浏览器调用时事件处理程序来响应异步发生的事件</p>
<h5 id="客户端javascript时间线"><a href="#客户端javascript时间线" class="headerlink" title="客户端javascript时间线"></a>客户端javascript时间线</h5><ol>
<li>web浏览器创建document对象，并且开始解析web页面，在这个阶段document.readystate属性的值是loading  </li>
<li>当html解析器遇到没有async和defer属性的script时，他把这些元素添加到脚本中然后执行外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停，这样脚本可以用document.write()把文本插入到文档中  </li>
<li>当解析器遇到设置了async和defer属性的script时,他开始下载脚本，并继续解析文档，脚本会在它下载完成后尽快执行，这里异步脚本禁止使用document.write()方法</li>
<li>当文档完成解析。document.readyState属性变为interactive.浏览器在domcument对象上触发DOMContentLoaded事件，这标志着程序执行从同步执行阶段转到了异步事件驱动阶段  </li>
<li>当文档所有内容完成载入时，document.readyState属性变为complete，浏览器触发onload事件  </li>
</ol>
<h3 id="第14章-window对象"><a href="#第14章-window对象" class="headerlink" title="第14章 window对象"></a>第14章 window对象</h3><h4 id="14-8-多窗口和窗体"><a href="#14-8-多窗口和窗体" class="headerlink" title="14.8 多窗口和窗体"></a>14.8 多窗口和窗体</h4><h5 id="14-8-1-打开和关闭窗口"><a href="#14-8-1-打开和关闭窗口" class="headerlink" title="14.8.1 打开和关闭窗口"></a>14.8.1 打开和关闭窗口</h5><p>window.open()载入指定的URL到新的或已存在的窗口中，并返回代表那个窗口的window对象</p>
<h5 id="14-8-2-窗体之间的关系"><a href="#14-8-2-窗体之间的关系" class="headerlink" title="14.8.2 窗体之间的关系"></a>14.8.2 窗体之间的关系</h5><p>窗体可以用parent属性引用包含它的窗口或窗体的window对象<br>top属性是一个通用的快捷方式，无论一个窗体被嵌套了几层，它的top属性引用的都是指向包含它的顶级窗口<br>iframe元素具有contentWindow属性，引用该窗体的window对象<br>每个window对象都有一个frames属性，他引用自身包含的窗口或窗体的子窗体，window.iframes[0]指向窗口的第一个子窗体<br>frames[]数组里的元素是window对象  </p>
<h5 id="14-8-3-交互窗口中的javasctipt"><a href="#14-8-3-交互窗口中的javasctipt" class="headerlink" title="14.8.3 交互窗口中的javasctipt"></a>14.8.3 交互窗口中的javasctipt</h5><p>iframe A中有<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">3</span>；</span><br></pre></td></tr></table></figure></p>
<p>iframe B可以读取A中js<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(parent.A.i) <span class="comment">//3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="第15章-脚本化文档"><a href="#第15章-脚本化文档" class="headerlink" title="第15章 脚本化文档"></a>第15章 脚本化文档</h3><h4 id="15-3-文档和结构的遍历"><a href="#15-3-文档和结构的遍历" class="headerlink" title="15.3 文档和结构的遍历"></a>15.3 文档和结构的遍历</h4><h5 id="15-3-1-作为节点树的文档"><a href="#15-3-1-作为节点树的文档" class="headerlink" title="15.3.1 作为节点树的文档"></a>15.3.1 作为节点树的文档</h5><p>parentNode  childNodes firstChild lastChild nextSibling previoursSibling nodeType nodeValue nodeName </p>
<h5 id="15-3-2-作为元素树的文档"><a href="#15-3-2-作为元素树的文档" class="headerlink" title="15.3.2 作为元素树的文档"></a>15.3.2 作为元素树的文档</h5><p>firstElementChild lastElementChild nextElementSibling previousElementSibling childElementCount  </p>
<h5 id="15-5-2-作为纯文本的元素内容"><a href="#15-5-2-作为纯文本的元素内容" class="headerlink" title="15.5.2 作为纯文本的元素内容"></a>15.5.2 作为纯文本的元素内容</h5><p>标准的方法是用Node的textContent属性来实现，在IE章可以用innerText属性来代替  </p>
<h5 id="15-8-2-查询元素的几何尺寸"><a href="#15-8-2-查询元素的几何尺寸" class="headerlink" title="15.8.2 查询元素的几何尺寸"></a>15.8.2 查询元素的几何尺寸</h5><p>断定一个元素的尺寸和位置的最简单的方法是调用它的getBoundingClientRect()方法，返回一个left,right，top,bottom属性的对象，都是相对视口坐标的位置</p>
<h5 id="15-8-4-滚动"><a href="#15-8-4-滚动" class="headerlink" title="15.8.4 滚动"></a>15.8.4 滚动</h5><p>window.scrollTo()接受一个点的x，y坐标（文档坐标）。滚动到某点<br>window.scrollBy()接受一个点的x，y坐标（文档坐标）。相对滚动多少</p>
<h3 id="第16章-脚本化CSS"><a href="#第16章-脚本化CSS" class="headerlink" title="第16章 脚本化CSS"></a>第16章 脚本化CSS</h3><h4 id="16-4-查询计算出的样式"><a href="#16-4-查询计算出的样式" class="headerlink" title="16.4 查询计算出的样式"></a>16.4 查询计算出的样式</h4><p>getComputedStyle()方法来获得一个元素的计算样式，返回值是一个cssStyleDeclaration对象,代表了应用在指定元素上的所有样式<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> title = documnet.getElementById(<span class="string">"sectiontitle"</span>);</span><br><span class="line"><span class="keyword">var</span> titlestyles = <span class="built_in">window</span>.getComputedStyle(element,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>在IE8中可以通过元素的currentStyle属性来兼容  </p>
<h5 id="16-6-2-查询、插入与删除样式表规则"><a href="#16-6-2-查询、插入与删除样式表规则" class="headerlink" title="16.6.2 查询、插入与删除样式表规则"></a>16.6.2 查询、插入与删除样式表规则</h5><p>document.styleSheets[]数组的元素是cssStyleSheets对象，cssStyleSheets对象有一个cssRules[]数组，它包含样式表的所有规则<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstRule = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>].cssRules[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p>
<p>IE使用不同的属性名rules代替cssRules,rules数组只包含样式表中实际存在的样式规则  </p>
<h3 id="第17章-事件处理"><a href="#第17章-事件处理" class="headerlink" title="第17章 事件处理"></a>第17章 事件处理</h3><h4 id="17-4-文档加载事件"><a href="#17-4-文档加载事件" class="headerlink" title="17.4 文档加载事件"></a>17.4 文档加载事件</h4><p>当文档加载解析完毕且所有延迟脚本(deferred)都执行完毕时会触发DOMContentLoaded事件，此时图片和异步脚本(async)可能依旧在加载</p>
<h3 id="第18章-脚本化HTTP"><a href="#第18章-脚本化HTTP" class="headerlink" title="第18章 脚本化HTTP"></a>第18章 脚本化HTTP</h3><h4 id="18-1-3-编码请求主体"><a href="#18-1-3-编码请求主体" class="headerlink" title="18.1.3 编码请求主体"></a>18.1.3 编码请求主体</h4><p>在表单用POST方法提交请求时，必须设置Content-Type<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.setResquestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="18-1-6-跨域HTTP请求"><a href="#18-1-6-跨域HTTP请求" class="headerlink" title="18.1.6 跨域HTTP请求"></a>18.1.6 跨域HTTP请求</h4><p>测试withCredentials的存在性是测试浏览器是否支持CORS的一种方法</p>
<h3 id="第19章-jquery类库"><a href="#第19章-jquery类库" class="headerlink" title="第19章 jquery类库"></a>第19章 jquery类库</h3><h5 id="19-5-3-动画得到取消延迟和队列"><a href="#19-5-3-动画得到取消延迟和队列" class="headerlink" title="19.5.3 动画得到取消延迟和队列"></a>19.5.3 动画得到取消延迟和队列</h5><p>stop()方法第一个参数默认为false，如果为true则会清楚该选中元素上的动画队列，还会取消任何等待执行的动画。第二个参数用来黄子行正在连续变化的css属性是否保留当前值，true变化到最终值，false保留当前值  </p>
<h3 id="第20章-客户端存储"><a href="#第20章-客户端存储" class="headerlink" title="第20章 客户端存储"></a>第20章 客户端存储</h3><h4 id="20-1-localStorage和sessionStorage"><a href="#20-1-localStorage和sessionStorage" class="headerlink" title="20.1 localStorage和sessionStorage"></a>20.1 localStorage和sessionStorage</h4><p>这俩者的主要区别在于存储的有效期和作用域的不同，数据可以存储多长时间以及谁拥有数据的访问权限</p>
<h5 id="20-1-1-存储有效期和作用域"><a href="#20-1-1-存储有效期和作用域" class="headerlink" title="20.1.1 存储有效期和作用域"></a>20.1.1 存储有效期和作用域</h5><p>localStorage存储的数据是永久的，除非web应用删除存储数据或者用户通过设置浏览器配置删除数据，否则数据将一直保存在用户的电脑中，永不过期<br>localStorage的作用域是限制在文档源级别的，不同的协议，主机名，端口拥有不同的文档源，同源的文档间共享localStorage。localStorage的作用域也受浏览器供应商限制</p>
<h3 id="第21章-多媒体和图形编程"><a href="#第21章-多媒体和图形编程" class="headerlink" title="第21章 多媒体和图形编程"></a>第21章 多媒体和图形编程</h3><h4 id="21-3-可伸缩的矢量图形"><a href="#21-3-可伸缩的矢量图形" class="headerlink" title="21.3 可伸缩的矢量图形"></a>21.3 可伸缩的矢量图形</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">fill</span>=<span class="string">"red"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<svg width="100" height="100"><rect x="0" y="0" width="100" height="100" fill="red"/></svg>

<p>SVG适用场景<br>SVG功能更完善，适合静态图片展示，高保真文档查看和打印的应用场景<br>兼容性IE9+  </p>
<h4 id="21-4-canvas中的图形"><a href="#21-4-canvas中的图形" class="headerlink" title="21.4 canvas中的图形"></a>21.4 canvas中的图形</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"drawing"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span>a drawing of something.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">'drawing'</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">if</span>(drawing.getContext)&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> context = srawing.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"><span class="undefined">    context.fillRect(10,10,50,50);</span></span><br><span class="line"><span class="actionscript">    context.fillStyle = <span class="string">"#f00"</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><canvas id="drawing" width="100" height="100">a drawing of something.</canvas></p>
<script type="text/javascript">
  var drawing = document.getElementById('drawing');
  if(drawing.getContext){
    var context = drawing.getContext("2d");
    context.fillStyle = "#f00";
    context.fillRect(0,0,100,100);
  }
</script>

<p>Canvas适用场景<br>Canvas提供的功能更原始，适合像素处理，动态渲染和大数据量绘制<br>兼容性IE9+  </p>
<h3 id="第22章-html5-API"><a href="#第22章-html5-API" class="headerlink" title="第22章 html5 API"></a>第22章 html5 API</h3><h4 id="22-3-跨域消息传递"><a href="#22-3-跨域消息传递" class="headerlink" title="22.3 跨域消息传递"></a>22.3 跨域消息传递</h4><p> postMessage()方法接收俩参数，第一个参数是要传递的消息，第二个参数是一个字符串，指定目标窗口的源<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://127.0.0.1/a.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> text = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>).innerHTML;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//window.parent.postMessage()返回想要的数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.parent.postMessage(text, <span class="string">"http://localhost/test/index.html"</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- http:localhost/test/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1/test/a.html"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">"iframe"</span>);</span></span><br><span class="line"><span class="actionscript">    iframe.contentWindow.postMessage(<span class="string">"null"</span>, <span class="string">"http://127.0.0.1/test/a.html"</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(e.data);  <span class="comment">//123 这里获取到了a页面的dom内容</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</div><div class="common-bottom"><p>如需转载请保留此段声明</p><p>作者：<a href="/about/">Jesse</a></p><p>出处：<a href="/">http://www.jesse131.cn</a></p><p>如果您对本文有什么疑问，欢迎在下方提出评论，您的建议是我写优质文章的动力。</p></div><div class="tags"><a href="/tags/javascript/">JavaScript</a></div><div class="post-share"><!-- baidu分享--><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="more" class="bds_more"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdPic":"","bdStyle":"0","bdSize":"16"},"share":{}};
with(document)0[body.appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></div><div class="post-nav"><a href="/articles/photoshop/the-front-end-cutting-technique.html" class="pre">前端切图技巧</a><a href="/articles/bootstrap/Bootstrap源码分析系列之核心CSS.html" class="next">Bootstrap源码分析系列之核心CSS</a></div><div id="comments"><link type="text/css" rel="stylesheet" href="//imsun.github.io/gitment/style/default.css"><div id="gitment-ctn"> </div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#第3章-类型、值和变量"><span class="toc-text">第3章 类型、值和变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-数字"><span class="toc-text">3.1 数字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-javascript中算术运算符"><span class="toc-text">3.1.3 javascript中算术运算符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-文本"><span class="toc-text">3.2 文本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-字符串直接量"><span class="toc-text">3.2.1 字符串直接量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-转义字符"><span class="toc-text">3.2.2 转义字符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-布尔值"><span class="toc-text">3.3 布尔值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-包装对象"><span class="toc-text">3.6 包装对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-变量作用域"><span class="toc-text">3.10 变量作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-10-1-函数作用域和声明提前"><span class="toc-text">3.10.1 函数作用域和声明提前</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-10-2-作为属性的变量"><span class="toc-text">3.10.2 作为属性的变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第4章-表达式和运算符"><span class="toc-text">第4章 表达式和运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-运算符优先级"><span class="toc-text">4.7 运算符优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-9-4-instanceof-运算符"><span class="toc-text">4.9.4 instanceof 运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-13-3-delete-运算符"><span class="toc-text">4.13.3 delete 运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第5章-语句"><span class="toc-text">第5章 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-复合语句和空语句"><span class="toc-text">5.2 复合语句和空语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-3-“use-strict”"><span class="toc-text">5.7.3 “use strict”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第6章-对象"><span class="toc-text">第6章 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-创建对象"><span class="toc-text">6.1 创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-3-原型"><span class="toc-text">6.1.3 原型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-4-Object-create"><span class="toc-text">6.1.4 Object.create()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-属性的查询和设置"><span class="toc-text">6.2 属性的查询和设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-删除属性"><span class="toc-text">6.3 删除属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-检测属性"><span class="toc-text">6.4 检测属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-枚举属性"><span class="toc-text">6.5 枚举属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-对象的三个属性"><span class="toc-text">6.8 对象的三个属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-1-原型属性-proto"><span class="toc-text">6.8.1 原型属性 proto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-2-类属性-object-class"><span class="toc-text">6.8.2 类属性 [object class]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-3-可扩展性"><span class="toc-text">6.8.3 可扩展性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第7章-数组"><span class="toc-text">第7章 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-数组元素的添加和删除"><span class="toc-text">7.5 数组元素的添加和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-数组方法"><span class="toc-text">7.8 数组方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-8-3-sort"><span class="toc-text">7.8.3 sort()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-8-5-slice"><span class="toc-text">7.8.5 slice()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-8-7-push-pop-shift-unshift"><span class="toc-text">7.8.7 push() pop() shift() unshift()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-ECMAScript5中定义的数组方法"><span class="toc-text">7.9 ECMAScript5中定义的数组方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-11-类数组对象"><span class="toc-text">7.11 类数组对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第8章-函数"><span class="toc-text">第8章 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-函数调用"><span class="toc-text">8.2 函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-1-函数调用"><span class="toc-text">8.2.1 函数调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-2-方法调用"><span class="toc-text">8.2.2 方法调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-3-构造函数调用"><span class="toc-text">8.2.3 构造函数调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-4-间接调用"><span class="toc-text">8.2.4 间接调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-函数的实参和形参"><span class="toc-text">8.3 函数的实参和形参</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-2-可变长的实参列表：实参对象"><span class="toc-text">8.3.2 可变长的实参列表：实参对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-自定义函数属性"><span class="toc-text">8.4 自定义函数属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-闭包"><span class="toc-text">8.6 闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-函数的属性方法和构造函数"><span class="toc-text">8.7 函数的属性方法和构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-7-3-call-和apply"><span class="toc-text">8.7.3 call()和apply()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-7-4-bind"><span class="toc-text">8.7.4 bind()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-7-6-Function-构造函数"><span class="toc-text">8.7.6 Function()构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第9章-类和模块"><span class="toc-text">第9章 类和模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-类和构造函数"><span class="toc-text">9.2 类和构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-1-构造函数和类的标识符"><span class="toc-text">9.2.1 构造函数和类的标识符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-类和类型"><span class="toc-text">9.5 类和类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-5-1-instanceof-运算符"><span class="toc-text">9.5.1 instanceof 运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-5-2-constructor属性"><span class="toc-text">9.5.2 constructor属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-5-3-构造函数的名称"><span class="toc-text">9.5.3 构造函数的名称</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-5-4-鸭式辩型思想"><span class="toc-text">9.5.4 鸭式辩型思想</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-ES5中的类"><span class="toc-text">9.8 ES5中的类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-8-1-让属性不可枚举"><span class="toc-text">9.8.1 让属性不可枚举</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-8-4-防止类的扩展"><span class="toc-text">9.8.4 防止类的扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第10章-正则表达式的模式匹配"><span class="toc-text">第10章 正则表达式的模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-正则表达式的定义"><span class="toc-text">10.1 正则表达式的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-1-直接量字符"><span class="toc-text">10.1.1 直接量字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-2-字符类"><span class="toc-text">10.1.2 字符类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-重复"><span class="toc-text">10.3 重复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-4-选择分组和引用"><span class="toc-text">10.1.4 选择分组和引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-5-指定匹配位置"><span class="toc-text">10.1.5 指定匹配位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-6-修饰符"><span class="toc-text">10.1.6 修饰符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-用于模式匹配的String方法"><span class="toc-text">10.2 用于模式匹配的String方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-RexExp对象"><span class="toc-text">10.3 RexExp对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-2-RexExp的方法"><span class="toc-text">10.3.2 RexExp的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第11章-javascript的子集和扩展"><span class="toc-text">第11章 javascript的子集和扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第12章-服务器端javascript"><span class="toc-text">第12章 服务器端javascript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第13章-web浏览器中的javascript"><span class="toc-text">第13章 web浏览器中的javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-javascript程序的执行"><span class="toc-text">13.3 javascript程序的执行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#客户端javascript时间线"><span class="toc-text">客户端javascript时间线</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第14章-window对象"><span class="toc-text">第14章 window对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-多窗口和窗体"><span class="toc-text">14.8 多窗口和窗体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#14-8-1-打开和关闭窗口"><span class="toc-text">14.8.1 打开和关闭窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-8-2-窗体之间的关系"><span class="toc-text">14.8.2 窗体之间的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-8-3-交互窗口中的javasctipt"><span class="toc-text">14.8.3 交互窗口中的javasctipt</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第15章-脚本化文档"><span class="toc-text">第15章 脚本化文档</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3-文档和结构的遍历"><span class="toc-text">15.3 文档和结构的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15-3-1-作为节点树的文档"><span class="toc-text">15.3.1 作为节点树的文档</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-3-2-作为元素树的文档"><span class="toc-text">15.3.2 作为元素树的文档</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-5-2-作为纯文本的元素内容"><span class="toc-text">15.5.2 作为纯文本的元素内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-8-2-查询元素的几何尺寸"><span class="toc-text">15.8.2 查询元素的几何尺寸</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-8-4-滚动"><span class="toc-text">15.8.4 滚动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第16章-脚本化CSS"><span class="toc-text">第16章 脚本化CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-查询计算出的样式"><span class="toc-text">16.4 查询计算出的样式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-6-2-查询、插入与删除样式表规则"><span class="toc-text">16.6.2 查询、插入与删除样式表规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第17章-事件处理"><span class="toc-text">第17章 事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-文档加载事件"><span class="toc-text">17.4 文档加载事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第18章-脚本化HTTP"><span class="toc-text">第18章 脚本化HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-3-编码请求主体"><span class="toc-text">18.1.3 编码请求主体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-6-跨域HTTP请求"><span class="toc-text">18.1.6 跨域HTTP请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第19章-jquery类库"><span class="toc-text">第19章 jquery类库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#19-5-3-动画得到取消延迟和队列"><span class="toc-text">19.5.3 动画得到取消延迟和队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第20章-客户端存储"><span class="toc-text">第20章 客户端存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#20-1-localStorage和sessionStorage"><span class="toc-text">20.1 localStorage和sessionStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#20-1-1-存储有效期和作用域"><span class="toc-text">20.1.1 存储有效期和作用域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第21章-多媒体和图形编程"><span class="toc-text">第21章 多媒体和图形编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-3-可伸缩的矢量图形"><span class="toc-text">21.3 可伸缩的矢量图形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-4-canvas中的图形"><span class="toc-text">21.4 canvas中的图形</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第22章-html5-API"><span class="toc-text">第22章 html5 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#22-3-跨域消息传递"><span class="toc-text">22.3 跨域消息传递</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-user"> 关于我</i></div><div class="avatar"><img src="http://o8l2fza1x.bkt.clouddn.com/apple-touch-icon.png"/></div><div class="author"><p><span class="name">姓名：杨冬</span></p><p><a href="mailto:jesse152@163.com">邮箱：jesse152@163.com</a></p><p class="github"><a href="https://github.com/Jesse121/jesse131.cn" target="_blank"><img src="http://o8l2fza1x.bkt.clouddn.com/github.png"/></a></p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/articles/jquery/fix-the-plugin-of-slimscroll.html">针对模拟滚动条插件(jQuery.slimscroll.js)的修改</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/tool/the-usual-command-line-of-line-of-vim.html">工作中常用到的Vim命令</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/html-css/make-a-thorough-inquiry-about-css-vertical-align.html">Vertical-Align属性探究</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/php/Yii-study-notes.html">Yii1.1.16学习记录</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/mobile/mobile-webpages-commonly-used-header-tags.html">移动端Web页面开发常用的头部标签设置</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/tool/the-usual-git-command.html">常用的Git命令整理</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/html-css/summary-of-various-length-unit-in-css.html">CSS中各种长度单位总结</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/javascript/the-different-between-innerHTML-innerText-and-textContent.html">innerHTML,innerText,textContent的区别详解</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/javascript/对JavaScript中this的理解.html">对JavaScript中this的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/tool/set-up-my-front-end-build-tool-webpack.html">搭建自己的Webpack前端构建工具</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/bootstrap/">Bootstrap</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html-css/">HTML-CSS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">JavaScript</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">PHP</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/photoshop/">Photoshop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">WEB</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webserver/">WEB服务器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jquery/">jQuery</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">前端工具</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/translation/">前端翻译</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mobile/">移动端开发</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/notes/">读书笔记</a><span class="category-list-count">13</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/photoshop/" style="font-size: 15px;">Photoshop</a> <a href="/tags/bootstrap/" style="font-size: 15px;">Bootstrap</a> <a href="/tags/html/" style="font-size: 15px;">HTML</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/jquery/" style="font-size: 15px;">jQuery</a> <a href="/tags/mobile/" style="font-size: 15px;">Mobile</a> <a href="/tags/http/" style="font-size: 15px;">HTTP</a> <a href="/tags/web/" style="font-size: 15px;">WEB</a> <a href="/tags/angularjs/" style="font-size: 15px;">AngularJs</a> <a href="/tags/css/" style="font-size: 15px;">CSS</a> <a href="/tags/php/" style="font-size: 15px;">PHP</a> <a href="/tags/yii/" style="font-size: 15px;">Yii</a> <a href="/tags/gulp/" style="font-size: 15px;">Gulp</a> <a href="/tags/webpack/" style="font-size: 15px;">Webpack</a> <a href="/tags/vim/" style="font-size: 15px;">Vim</a> <a href="/tags/git/" style="font-size: 15px;">Git</a> <a href="/tags/sublimetext3/" style="font-size: 15px;">SublimeText3</a> <a href="/tags/apache/" style="font-size: 15px;">Apache</a> <a href="/tags/mysql/" style="font-size: 15px;">MySQL</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul><li><a href="http://javascript.ruanyifeng.com/" title="JavaScript 标准参考教程" target="_blank">JavaScript 标准参考教程</a></li><li><a href="http://www.cnblogs.com/lyzg/" title="流云诸葛" target="_blank">流云诸葛</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" title="深入理解JavaScript系列" target="_blank">深入理解JavaScript系列</a></li><li><a href="http://caibaojian.com/page/2" title="前端开发博客" target="_blank">前端开发博客</a></li><li><a href="http://www.cnblogs.com/jesse131/" title="前端开发之路" target="_blank">前端开发之路</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><span> Copyright &copy 2016-2017 <a href="//about/" rel="nofollow">Jesse.</a></span></p><p><span>Total visits：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i></span><span> Theme by  <a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Powered by  <a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><!-- 百度统计--><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4ffc2e2a8e110c88089b74c1a953786f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();

</script><!-- 百度内容推送--><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.appendChild(bp);
})();

</script><script type="text/javascript" src="/js/bundle.js"></script><!--gitment--><script src="//imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  //- id: location.href,
  owner: 'Jesse121',
  repo: 'www.jesse131.cn',
  oauth: {
    client_id: '1d84813ae13cd94072f0',
    client_secret: 'e0a20bd0498c8eb5eb6145c9802b47597d35f35a',
  },
})
gitment.render('gitment-ctn')</script></body></html>