<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>《ECMAScript6标准入门》第二版--读书笔记</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="white"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-title" content="我的博客"><meta name="description" content="专注前端开发，前端开发技术博客"><meta name="keywords" content="前端开发，PHP开发，Javascript，前端开发博客"><link rel="dns-prefetch" href="www.jesse131.cn"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="shortcut icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《ECMAScript6标准入门》第二版--读书笔记</h1><a id="logo" href="/.">前端之路</a><p class="description">路漫漫其修远兮，吾将上下而求索</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索..."></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">《ECMAScript6标准入门》第二版--读书笔记</h1><div class="post-meta"><span class="date">2017-04-10</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i> Hits</i></i></span><a href="/articles/notes/ECMAScript-6-primer-2nd-edition.html#comments" class="comment-count"></a></div><div class="post-content"><p>2015年6月，ECMAScript 6正式通过，成为国际标准。尽管在目前的工作中还没有使用ES6，但是每项新技术出来总是忍不住想尝尝鲜，想知道ES6能为前端开发带来哪些变化？对自己的工作有哪些方面可以提升。刚好看到阮一峰的《ES6标准入门》，便顺着这本书尝试着ES6的各种新特性。<br><a id="more"></a><br>ES6的各种新特性的兼容性查询<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/</a><br>尽管我们的浏览器还不一定完全支持ES6代码，我们可以使用Babel转码器,在这里我们使用命令行转码<strong>babel-cli</strong>，命令行<code>$ npm install --global babel-cli</code>安装babel-cli</p>
<h3 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h3><h4 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h4><p>ES6新增了 let 命令，用来声明变量。它的用法类似于 var ，但是所声明的变量，只在 let 命令所在的代码块内有效。let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>ES6明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。<br>let不允许在相同作用域内，重复声明同一个变量。let 实际上为JavaScript新增了块级作用域。  ES6引入了块级作用域，明确允许在块级作用域之中声明函数。  </p>
<h4 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h4><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MAX); <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。 const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">//123</span></span><br></pre></td></tr></table></figure></p>
<p>ES6规定var 命令和 function 命令声明的全局变量，依旧是全局对象的属性；let 命令、 const 命令、 class 命令声明的全局变量，不属于全局对象的属性。</p>
<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>解构赋值允许指定默认值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure></p>
<p>注意，ES6内部使用严格相等运算符（ === ），判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined ，默认值是不会生效的。</p>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。  </p>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function"><span class="keyword">function</span>(<span class="params">[a,b]</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;    </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//[3,7]</span></span><br></pre></td></tr></table></figure>
<h4 id="变量解构赋值用途"><a href="#变量解构赋值用途" class="headerlink" title="变量解构赋值用途"></a>变量解构赋值用途</h4><ol>
<li>交换变量的值<code>[x, y] = [y, x];</code></li>
<li><p>提取JSON数据</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">    id: <span class="number">42</span>,</span><br><span class="line">    <span class="keyword">status</span>: <span class="string">"OK"</span>,</span><br><span class="line">    <span class="keyword">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; id, <span class="keyword">status</span>, <span class="keyword">data</span>: <span class="keyword">number</span> &#125; = jsonData;</span><br><span class="line">console.<span class="built_in">log</span>(id, <span class="keyword">status</span>, <span class="keyword">number</span>);// <span class="number">42</span>, <span class="string">"OK"</span>, [<span class="number">867</span>, <span class="number">5309</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数的默认值</p>
 <figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> </span>(url, &#123;</span><br><span class="line">    async = <span class="literal">true</span>,</span><br><span class="line">    beforeSend = <span class="function"><span class="keyword">function</span> </span>() &#123;&#125;,</span><br><span class="line">    cache = <span class="literal">true</span>,</span><br><span class="line">    complete = <span class="function"><span class="keyword">function</span> </span>() &#123;&#125;,</span><br><span class="line">    crossDomain = <span class="literal">false</span>,</span><br><span class="line">    global = <span class="literal">true</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>includes()：返回布尔值，表示是否找到了参数字符串。<br>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。<br>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>使用第二个参数 n 时， endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。</p>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>返回一个新字符串，表示将原字符串重复 n 次。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><p>padStart 用于头部补全， padEnd 用于尾部补全。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure></p>
<p>padStart 和 padEnd 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><p>从ES5开始，在严格模式之中，八进制就不再允许使用前缀 0 表示，ES6进一步明确，要使用前缀 0o 表示。</p>
<h4 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite()"></a>Number.isFinite()</h4><p>Number.isFinite() 用来检查一个数值是否非无穷（infinity）。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h4><p>Number.isNaN() 用来检查一个值是否为 NaN 。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>它们与传统的全局方法 isFinite() 和 isNaN() 的区别在于，传统方法先调用 Number() 将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回 false 。</p>
<h4 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h4><p>ES6将全局方法 parseInt() 和 parseFloat() ，移植到Number对象上面，行为完全保持不变。</p>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p>Number.isInteger() 用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</p>
<h4 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h4><p>JavaScript能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。<br>ES6引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个<br>常量，用来表示这个范围的上下限。<br>Number.isSafeInteger() 则是用来判断一个整数是否落在这个范围之内。</p>
<h4 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h4><p>Math.trunc 方法用于去除一个数的小数部分，返回整数部分。<br>Math.sign 方法用来判断一个数到底是正数、负数、还是零。<br>Math.cbrt 方法用于计算一个数的立方根。<br>Math.fround方法返回一个数的单精度浮点数形式。<br>Math.hypot 方法返回所有参数的平方和的平方根。</p>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。<br>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的 arguments 对象。 Array.from 都可以将它们转为真正的数组。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>Array.of 方法用于将一组值，转换为数组。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h4><p>Array.prototype.copyWithin(target, start = 0, end = this.length)</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h4 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h4><p>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined 。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure></p>
<p>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1 。</p>
<h4 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h4><p>fill 方法使用给定值，填充一个数组。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)<span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="数组实例的entries-，keys-和values"><a href="#数组实例的entries-，keys-和values" class="headerlink" title="数组实例的entries()，keys()和values()"></a>数组实例的entries()，keys()和values()</h4><p>ES6提供三个新的方法—— entries() ， keys() 和 values() ——用于遍历数组。唯一的区别是 keys() 是对键名的遍历、 values() 是对键值的遍历， entries() 是对键值对的遍历。</p>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h4><p>指定了默认值以后，函数的 length 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后， length 属性将失真。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function (a) &#123;&#125;).length // 1</span><br><span class="line">(function (a = 5) &#123;&#125;).length // 0</span><br><span class="line">(function (a, b, c = 5) &#123;&#125;).length // 2</span><br></pre></td></tr></table></figure></p>
<h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p> ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入<br>数组中。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">        sum += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p>
<p>注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点（ … ）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)<span class="comment">// 1 2 3 4 5</span></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br></pre></td></tr></table></figure></p>
<h4 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h4><ol>
<li><p>合并数组</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">var arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">var arr2 = [<span class="string">'c'</span>];</span><br><span class="line">var arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line">// <span class="symbol">ES5</span>的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br><span class="line">// <span class="symbol">ES6</span>的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]// [ <span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span> ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现了Iterator接口的对象</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">var nodeList = document.querySelectorAll('div');</span><br><span class="line">var<span class="built_in"> array </span>= [...node<span class="class">List];</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6允许使用“箭头”（ =&gt; ）定义函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数有几个使用注意点</p>
<ol>
<li>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</li>
<li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</li>
<li>不可以使用 yield 命令，因此箭头函数不能用作Generator函数。</li>
</ol>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><p>ES6允许在对象之中，只写属性名，不写属性值。这时属性值等于属性名所代表的变量。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    <span class="comment">//等同于birth: birth</span></span><br><span class="line">    birth,</span><br><span class="line">    <span class="comment">// 等同于hello: function ()...</span></span><br><span class="line">    hello() &#123; <span class="built_in">console</span>.log(<span class="string">'我的名字是'</span>, <span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p>Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性<br>Object.assign 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。<br>Object.assign 方法有很多用处。</p>
<ol>
<li><p>为对象添加属性</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为对象添加方法</p>
 <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Object</span><span class="selector-class">.assign</span>(SomeClass.prototype, &#123;</span><br><span class="line">    <span class="selector-tag">someMethod</span>(arg1, arg2) &#123;</span><br><span class="line">    ···</span><br><span class="line">    &#125;,</span><br><span class="line">    anotherMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆对象</p>
 <figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">clone</span>(origin) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Object.assign(&#123;&#125;,</span> origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并多个对象</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">const <span class="built_in">merge</span> = (<span class="keyword">target</span>, ...sources) =&gt; Object.<span class="keyword">assign</span>(<span class="keyword">target</span>, ...sources);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为属性指定默认值</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">    logLevel: <span class="number">0</span>,</span><br><span class="line">    outputFormat: <span class="string">'html'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="ES6属性的遍历5种方法"><a href="#ES6属性的遍历5种方法" class="headerlink" title="ES6属性的遍历5种方法"></a>ES6属性的遍历5种方法</h5><ol>
<li>for…in 循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</li>
<li>Object.keys(obj)返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</li>
<li>Object.getOwnPropertyNames(obj)返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</li>
<li>Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有Symbol属性。</li>
<li>Reflect.ownKeys(obj)返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</li>
</ol>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。<br>注意，Symbol值作为对象属性名时，不能用点运算符。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a.mySymbol = <span class="string">'Hello!'</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">'mySymbol'</span>] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure></p>
<p>因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个Symbol值。<br>Symbol作为属性名，该属性不会出现在 for…in 、 for…of 循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。<br>Reflect.ownKeys 方法可以返回所有类型的键名，包括常规键名和Symbol键名。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">    enum: <span class="number">2</span>,</span><br><span class="line">    nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)<span class="comment">// [Symbol(my_key), 'enum', 'nonEnum']</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h4><p>有时，我们希望重新使用同一个Symbol值， Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)<span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h4><ol>
<li>Set.prototype.constructor ：构造函数，默认就是 Set 函数。</li>
<li>Set.prototype.size ：返回 Set 实例的成员总数。</li>
<li>add(value) ：添加某个值，返回Set结构本身。</li>
<li>delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value) ：返回一个布尔值，表示该值是否为 Set 的成员。</li>
<li>clear() ：清除所有成员，没有返回值。</li>
</ol>
<h4 id="Map结构的目的和基本用法"><a href="#Map结构的目的和基本用法" class="headerlink" title="Map结构的目的和基本用法"></a>Map结构的目的和基本用法</h4><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键<br>Map原生提供三个遍历器生成函数和一个遍历方法。</p>
<ol>
<li>keys() ：返回键名的遍历器。</li>
<li>values() ：返回键值的遍历器。</li>
<li>entries() ：返回所有成员的遍历器。</li>
<li>forEach() ：遍历Map的所有成员。</li>
</ol>
<h3 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h3><p>Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。<br>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。<br>形式上，Generator函数是一个普通函数，但是有两个特征。一是， function关键字与函数名之间有一个星号；二是，函数体内部使用 yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise实例生成以后，可以用 then 方法分别指定 Resolved 状态和 Reject 状态的回调函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">        client.onreadystatechange = handler;</span><br><span class="line">        client.responseType = <span class="string">"json"</span>;</span><br><span class="line">        client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">        client.send();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>then 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。<br>then 方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p>Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。<br>一般来说，不要在 then 方法里面定义Reject状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5的构造函数 Point ，对应ES6的 Point 类的构造方法。<br>由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。 Object.assign 方法可以很方便地一次向类添加多个方法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">    toString()&#123;&#125;,</span><br><span class="line">    toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<h4 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h4><p>constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。constructor 方法默认返回实例对象（即 this ），完全可以指定返回另外一个<br>对象。</p>
<h3 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h3><p>Class之间可以通过 extends 关键字实现继承<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以<br>使用 this 关键字，否则会报错。<br>Class不存在变量提升（hoist），这一点与ES5完全不同。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>Object.getPrototypeOf 方法可以用来从子类上获取父类。<br>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p>super 这个关键字，有两种用法，含义不同。</p>
<ol>
<li>作为函数调用时（即 super(…args) ）， super 代表父类的构造函数。</li>
<li>作为对象调用时（即 super.prop 或 super.method() ）， super 代表父<br>类。注意，此时 super 即可以引用父类实例的属性和方法，也可以引用父类的静<br>态方法。</li>
</ol>
<h4 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<h3 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h3><ol>
<li>let取代var</li>
<li>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</li>
<li>函数的参数如果是对象的成员，优先使用解构赋值。</li>
<li><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2 &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    k1: v1,</span><br><span class="line">    k2: v2,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组<br> 使用扩展运算符（…）拷贝数组。<code>const itemsCopy = [...items];</code><br> 使用Array.from方法，将类似数组的对象转为数组。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</span><br><span class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数<br> 立即执行函数可以写成箭头函数的形式。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet.'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p> 使用默认值语法设置函数参数的默认值。  </p>
</li>
<li>总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。</li>
</ol>
<p>这些笔记只是看第一遍消化的，还有更多的内容需要对研究几遍才行。</p>
</div><div class="common-bottom"><p>如需转载请保留此段声明</p><p>作者：<a href="/about/">Jesse</a></p><p>出处：<a href="/">http://www.jesse131.cn</a></p><p>如果您对本文有什么疑问，欢迎在下方提出评论，您的建议是我写优质文章的动力。</p></div><div class="tags"><a href="/tags/javascript/">JavaScript</a></div><div class="post-share"><!-- baidu分享--><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="more" class="bds_more"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdPic":"","bdStyle":"0","bdSize":"16"},"share":{}};
with(document)0[body.appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></div><div class="post-nav"><a href="/articles/webserver/Apache2.4.23+PHP5.6.30+MySQL5.7.18安装教程.html" class="pre">Apache2.4.23 + PHP5.6.30 + MySQL5.7.18安装教程</a><a href="/articles/javascript/对JavaScript中闭包的理解.html" class="next">对JavaScript中闭包的理解</a></div><div id="comments"><link type="text/css" rel="stylesheet" href="//imsun.github.io/gitment/style/default.css"><div id="gitment-ctn"> </div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#let和const命令"><span class="toc-text">let和const命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#let命令"><span class="toc-text">let命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const命令"><span class="toc-text">const命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量的解构赋值"><span class="toc-text">变量的解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组的解构赋值"><span class="toc-text">数组的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的解构赋值"><span class="toc-text">对象的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数参数的解构赋值"><span class="toc-text">函数参数的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量解构赋值用途"><span class="toc-text">变量解构赋值用途</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串的扩展"><span class="toc-text">字符串的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#includes-startsWith-endsWith"><span class="toc-text">includes(), startsWith(), endsWith()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repeat"><span class="toc-text">repeat()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#padStart-，padEnd"><span class="toc-text">padStart()，padEnd()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板字符串"><span class="toc-text">模板字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值的扩展"><span class="toc-text">数值的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isFinite"><span class="toc-text">Number.isFinite()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isNaN"><span class="toc-text">Number.isNaN()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-parseInt-Number-parseFloat"><span class="toc-text">Number.parseInt(), Number.parseFloat()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isInteger"><span class="toc-text">Number.isInteger()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安全整数和Number-isSafeInteger"><span class="toc-text">安全整数和Number.isSafeInteger()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math对象的扩展"><span class="toc-text">Math对象的扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组的扩展"><span class="toc-text">数组的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-from"><span class="toc-text">Array.from()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-of"><span class="toc-text">Array.of()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组实例的copyWithin"><span class="toc-text">数组实例的copyWithin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组实例的find-和findIndex"><span class="toc-text">数组实例的find()和findIndex()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组实例的fill"><span class="toc-text">数组实例的fill()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组实例的entries-，keys-和values"><span class="toc-text">数组实例的entries()，keys()和values()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数的扩展"><span class="toc-text">函数的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数参数的默认值"><span class="toc-text">函数参数的默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的length属性"><span class="toc-text">函数的length属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rest参数"><span class="toc-text">rest参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展运算符"><span class="toc-text">扩展运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展运算符的应用"><span class="toc-text">扩展运算符的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的扩展"><span class="toc-text">对象的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性的简洁表示法"><span class="toc-text">属性的简洁表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-assign"><span class="toc-text">Object.assign()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ES6属性的遍历5种方法"><span class="toc-text">ES6属性的遍历5种方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol-for-，Symbol-keyFor"><span class="toc-text">Symbol.for()，Symbol.keyFor()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set和Map数据结构"><span class="toc-text">Set和Map数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set实例的属性和方法"><span class="toc-text">Set实例的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map结构的目的和基本用法"><span class="toc-text">Map结构的目的和基本用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generator-函数"><span class="toc-text">Generator 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise对象"><span class="toc-text">Promise对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-prototype-then"><span class="toc-text">Promise.prototype.then()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-prototype-catch"><span class="toc-text">Promise.prototype.catch()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class"><span class="toc-text">Class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constructor方法"><span class="toc-text">constructor方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class的继承"><span class="toc-text">Class的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getPrototypeOf"><span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super关键字"><span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class的静态方法"><span class="toc-text">Class的静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编程风格"><span class="toc-text">编程风格</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-user"> 关于我</i></div><div class="avatar"><img src="http://o8l2fza1x.bkt.clouddn.com/apple-touch-icon.png"/></div><div class="author"><p><span class="name">姓名：杨冬</span></p><p><a href="mailto:jesse152@163.com">邮箱：jesse152@163.com</a></p><p class="github"><a href="https://github.com/Jesse121/jesse131.cn" target="_blank"><img src="http://o8l2fza1x.bkt.clouddn.com/github.png"/></a></p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/articles/tool/the-usual-command-line-of-line-of-vim.html">工作中常用到的Vim命令</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/html-css/make-a-thorough-inquiry-about-css-vertical-align.html">Vertical-Align属性探究</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/php/Yii-study-notes.html">Yii1.1.16学习记录</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/mobile/mobile-webpages-commonly-used-header-tags.html">移动端Web页面开发常用的头部标签设置</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/tool/the-usual-git-command.html">常用的Git命令整理</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/html-css/summary-of-various-length-unit-in-css.html">CSS中各种长度单位总结</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/javascript/the-different-between-innerHTML-innerText-and-textContent.html">innerHTML,innerText,textContent的区别详解</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/javascript/对JavaScript中this的理解.html">对JavaScript中this的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/tool/set-up-my-front-end-build-tool-webpack.html">搭建自己的Webpack前端构建工具</a></li><li class="post-list-item"><a class="post-list-link" href="/articles/notes/performance-best-practices-for-web-developer.html">《高性能网站建设进阶指南》--读书笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/bootstrap/">Bootstrap</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html-css/">HTML-CSS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">JavaScript</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">PHP</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/photoshop/">Photoshop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">WEB</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webserver/">WEB服务器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jquery/">jQuery</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">前端工具</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/translation/">前端翻译</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mobile/">移动端开发</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/notes/">读书笔记</a><span class="category-list-count">13</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/php/" style="font-size: 15px;">PHP</a> <a href="/tags/bootstrap/" style="font-size: 15px;">Bootstrap</a> <a href="/tags/html/" style="font-size: 15px;">HTML</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/jquery/" style="font-size: 15px;">jQuery</a> <a href="/tags/mobile/" style="font-size: 15px;">Mobile</a> <a href="/tags/http/" style="font-size: 15px;">HTTP</a> <a href="/tags/web/" style="font-size: 15px;">WEB</a> <a href="/tags/angularjs/" style="font-size: 15px;">AngularJs</a> <a href="/tags/css/" style="font-size: 15px;">CSS</a> <a href="/tags/photoshop/" style="font-size: 15px;">Photoshop</a> <a href="/tags/yii/" style="font-size: 15px;">Yii</a> <a href="/tags/gulp/" style="font-size: 15px;">Gulp</a> <a href="/tags/webpack/" style="font-size: 15px;">Webpack</a> <a href="/tags/vim/" style="font-size: 15px;">Vim</a> <a href="/tags/git/" style="font-size: 15px;">Git</a> <a href="/tags/sublimetext3/" style="font-size: 15px;">SublimeText3</a> <a href="/tags/apache/" style="font-size: 15px;">Apache</a> <a href="/tags/mysql/" style="font-size: 15px;">MySQL</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul><li><a href="http://javascript.ruanyifeng.com/" title="JavaScript 标准参考教程" target="_blank">JavaScript 标准参考教程</a></li><li><a href="http://www.cnblogs.com/lyzg/" title="流云诸葛" target="_blank">流云诸葛</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" title="深入理解JavaScript系列" target="_blank">深入理解JavaScript系列</a></li><li><a href="http://caibaojian.com/page/2" title="前端开发博客" target="_blank">前端开发博客</a></li><li><a href="http://www.cnblogs.com/jesse131/" title="前端开发之路" target="_blank">前端开发之路</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><span> Copyright &copy 2016-2017 <a href="//about/" rel="nofollow">Jesse.</a></span></p><p><span>Total visits：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i></span><span> Theme by  <a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Powered by  <a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><!-- 百度统计--><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4ffc2e2a8e110c88089b74c1a953786f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();

</script><!-- 百度内容推送--><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.appendChild(bp);
})();

</script><script type="text/javascript" src="/js/bundle.js"></script><!--gitment--><script src="//imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  //- id: location.href,
  owner: 'Jesse121',
  repo: 'www.jesse131.cn',
  oauth: {
    client_id: '1d84813ae13cd94072f0',
    client_secret: 'e0a20bd0498c8eb5eb6145c9802b47597d35f35a',
  },
})
gitment.render('gitment-ctn')</script></body></html>