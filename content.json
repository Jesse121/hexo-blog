[{"title":"工作中遇到的细节问题总结(一)","date":"2018-04-11T10:13:05.000Z","path":"articles/html-css/question-in-work.html","text":"在前端开发工作中总会遇到各种各样的坑，今天这篇博文就是为了记录下踩过的坑，分析后发现容易掉坑里的地方一般是自己不熟悉的知识点或者是易忽略的知识点。故作此文，谨以自勉。 用css3播放逐帧动画动效设计师给了我们11张(300*300)帧动画图片，现需要用css3以动画的形式播放这些图片第一个想到的办法就是通过animation改变DOM元素的背景图片.boom-2&#123; position: fixed; width:300px; height:300px; transform:translate(-50%,-50%); pointer-events: none; animation: boom-2 1s forwards;&#125;@keyframes boom-2&#123; 0%&#123; background-image: url(\"../hit/0.png\"); &#125; 10%&#123; background-image: url(\"../hit/1.png\"); &#125; 20%&#123; background-image: url(\"../hit/2.png\"); &#125; 30%&#123; background-image: url(\"../hit/3.png\"); &#125; 40%&#123; background-image: url(\"../hit/4.png\"); &#125; 50%&#123; background-image: url(\"../hit/5.png\"); &#125; 60%&#123; background-image: url(\"../hit/6.png\"); &#125; 70%&#123; background-image: url(\"../hit/7.png\"); &#125; 80%&#123; background-image: url(\"../hit/8.png\"); &#125; 90%&#123; background-image: url(\"../hit/9.png\"); &#125; 100%&#123; background-image: url(\"../hit/10.png\"); &#125;&#125; 结果在chrome firefox上运行良好，可是在IE上看不到效果,在网上搜一下发现background-image不支持动画既然不行那就在想想办法。 第二种办法就是通过动画改变background-position,在加上以帧动画的形式播放,关键点：animation-timing-function:steps(11);.boom-2&#123; position: fixed; width:300px; height:300px; transform:translate(-50%,-50%) scale(0.5); pointer-events: none; animation: boomSvg 0.4s steps(11) forwards; background-image: url(\"./boom.png\");&#125;@keyframes boomSvg&#123; 0%&#123; background-position: 0 0; &#125; 100%&#123; background-position: 0 -1100%; &#125;&#125; 至此完美解决帧动画播放问题。通过这个问题发现自己对css3动画不是非常了解，就顺便在延展下 animation 属性是一个简写属性，用于设置8个动画属性： animation-name //规定需要绑定到选择器的 keyframe 名称 animation-duration //规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function //规定动画的速度曲线 animation-delay //规定在动画开始之前的延迟。 animation-iteration-count //规定动画应该播放的次数 animation-direction //规定是否应该轮流反向播放动画 animation-fill-mode //属性规定动画在播放之前或之后，其动画效果是否可见 animation-play-state //属性规定动画正在运行还是暂停 animation-fill-mode 值 描述 none 不改变默认行为。 forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。 backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 both 向前和向后填充模式都被应用。 animation-play-state 值 描述 paused 规定动画已暂停 running 规定动画正在播放 animation-timing-function 值 描述 linear 动画从头到尾的速度是相同的 ease 默认。动画以低速开始，然后加快，在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 以上animation-timing-function的值都是实现线性变化（两个状态之间是逐渐变化过去），其实animation-timing-function还可以实现帧动画（两个状态之间是直接跳跃变化） steps(11,start)第一个参数 number 为指定的间隔数，即把两关键帧分为 n 步阶段性展示第二个参数可选，接受 start 和 end 两个值，指定在每个间隔的起点或是终点发生阶跃变化，默认为 end start在变化过程中，都是以下一帧的显示效果来填充间隔动画， end与上面相反，都是以上一帧的显示效果来填充间隔动画， line-height属性再探究line-height: normal | &lt;number&gt; | &lt;length&gt; | &lt;percentage&gt; | inheritInherited: yesPercentages: refer to the font size of the element itself line-height默认值为normal 不允许用负值当元素没有设置高度的时候，其实是由line-height撑开了元素的高度以百分数或数字为单位的时候是相对与本身字体大小而得到的计算结果下面代码中设置的三个行高结果是相同的div &#123; line-height: 1.2; font-size: 10pt &#125; /* number */div &#123; line-height: 1.2em; font-size: 10pt &#125; /* length */div &#123; line-height: 120%; font-size: 10pt &#125; /* percentage */ 通过设置line-height和height常用于单行文字的垂直居中 通过line-height也可设置多行文本的垂直居中 asdfkjkj暗示的风景好看阿斯蒂芬框架啊世纪东方sadf p&#123; width: 250px; line-height: 150px;&#125;span&#123; display: inline-block; vertical-align: middle; line-height: 20px;/*作用是设置文本的行高，并覆盖掉父元素的行高*/&#125; css行高line-height的一些深入理解及应用参考链接 pointer-events属性让点击事件穿透在直播间特效开发中遇到点击图片无响应(图片父元素已绑定点击事件),仔细研究发现由于特效图片切换太快而不能将点击事件冒泡到父元素解决办法：在特效图片上添加以下css属性，这样使得点击事件能够直接穿透到父元素上img&#123; pointer-events:none;&#125; pointer-events：auto | none | visiblepainted | visiblefill | visiblestroke | visible | painted | fill | stroke | allnone:元素永远不会成为鼠标事件的target兼容性：IE11+参考链接 Date.parse()获取时间戳IOS不兼容的问题因为IOS系统不支持2017-01-01格式的时间导致的，用正则替换2017-01-01日期格式为2017/01/01后问题解决var mydata = '2017-01-01 11:00:00';mydata=mydata.replace(/-/g, '/');var time = Date.parse(new Date(mydata)) / 1000; 移动端禁止页面长按复制在前端页面开发中有时会因为用户点击而导致页面被全选出现蓝色，这时可以禁用全选body&#123; user-select:none;&#125; user-select：none | text | all | elementnone：文本不能被选择text：可以选择文本all：当所有内容作为一个整体时可以被选择。如果双击或者在上下文上点击子元素，那么被选择的部分将是以该子元素向上回溯的最高祖先元素。element：可以选择文本，但选择范围受元素边界的约束兼容性：IE10+ 需要添加浏览器前缀 -ms- -moz- -webkit-详细可参考user-select chrome滚动条样式该样式只适用于webkit内核浏览器，由于兼容性问题，目前工作中改用改进后的slimscroll.js插件.scrollBox&#123; overflow-y: auto; &amp;::-webkit-scrollbar&#123; width: 10px; &#125; &amp;::-webkit-scrollbar-button&#123; background-color: transparent; &#125; &amp;::-webkit-scrollbar-track&#123; background-color: transparent; &#125; &amp;::-webkit-scrollbar-thumb&#123; background-color: #fe2545; border-radius: 5px; &#125;&#125; 镂空字体1Jesse关键css: -webkit-text-stroke: 1px red;兼容性:IE都不兼容 Edge16+ 需要加-webkit-前缀firefox58+ 需要加-webkit-前缀chrome 需要加-webkit-前缀 镂空字体2背景是图片 Jesse关键css:div&#123; -webkit-background-clip:text; -webkit-text-fill-color:transparent;&#125; 兼容性：IE都不兼容 Edge16+ 需要加-webkit-前缀firefox58+ 需要加-webkit-前缀chrome 需要加-webkit-前缀 渐变字体背景是渐变色 Jesse.text&#123; font-size:40px; font-weight:bold; color: #fde2ba; background-image: -webkit-gradient(linear, 0 0, 0 bottom, from(#fffaf3), to(#fbc677)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;&#125; 3D字体用的是多层背景 3d关键css:-webkit-text-stroke: 2px white;text-shadow: 0 1px 0 #4a4a4e, /*main 3d shadow*/ -1px -1px 0 #4a4a4e, -1px 0px 0 #343437, -2px 1px 0 #343437, -3px 2px 0 #313134, -4px 3px 0 #2f2f31, -5px 4px 0 #2c2c2f, -6px 5px 0 #2a2a2c, -7px 6px 0 #27272a, -8px 7px 0 #252527, -9px 8px 0 #232324, -10px 9px 0 #202022,-11px 10px 0 #1e1e1f,-12px 11px 0 #1b1b1d,-13px 12px 0 #19191a, -14px 13px 0 #161617, -15px 14px 0 #141415, -16px 15px 0 #111112, /*top right*/ 0 -1px 1px #ffffff, 0 -2px 0px #ffffff, /*bottom left corner*/ -15px 14px 0px #ffffff, -16px 15px 0px #ffffff, -17px 16px 0px #ffffff, -18px 17px 0px #ffffff, -2px -1px 0 #ffffff,-3px 0px 0 #ffffff, /*top left corner*/ -19px 15px 0 #ffffff,-18px 14px 0 #ffffff, -17px 13px 0 #ffffff,-16px 12px 0 #ffffff, -15px 11px 0 #ffffff, -14px 10px 0 #ffffff,-13px 9px 0 #ffffff, -12px 8px 0 #ffffff, -11px 7px 0 #ffffff, -10px 6px 0 #ffffff,-9px 5px 0 #ffffff, -8px 4px 0 #ffffff, -7px 3px 0 #ffffff, -6px 2px 0 #ffffff, -5px 1px 0 #ffffff, -4px 0px 0 #ffffff, /*lower right / (upper right side for capital T like H etc letters. */ 0px 2px 0px #ffffff, -1px 3px 0px #ffffff, -2px 4px 0px #ffffff, -3px 5px 0px #ffffff, -4px 6px 0px #ffffff, -5px 7px 0px #ffffff, -6px 8px 0px #ffffff, -7px 9px 0px #ffffff, -8px 10px 0px #ffffff, -9px 11px 0px #ffffff, -10px 12px 0px #ffffff, -11px 13px 0px #ffffff, -12px 14px 0px #ffffff, -13px 15px 0px #ffffff, -14px 16px 0px #ffffff, -15px 17px 0px #ffffff; 边框渐变原理：对外层的div使用循环渐变 background: -webkit-repeating-linear-gradient(45deg, #ffc9d0 0px, #ffc9d0 10px, #ff 233f 10px, #ff233f 40px); 兼容性：IE11+ Firefox Chrome 基本都支持 控制元素在IOS设备上是否使用滚动回弹效果从前端开发的角度讲，只需要知道CSS的属性-webkit-overflow-scrolling是真的创建了带有硬件加速的系统级控件，所以效率很高。但是这相对是耗更多内存的，最好在产生了非常大面积的overflow时才应用。body &#123; -webkit-overflow-scrolling: touch;/*ios*/&#125; css波浪下划线this is a testdiv&#123; text-decoration-style:wavy; text-decoration-color: red; text-decoration-line:underline;&#125; 具体参考：text-decoration兼容 css3外发光div&#123; box-shadow: 0 0 10px #000;&#125; ios中激活active伪类在iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。//ios中激活active伪类document.body.addEventListener('touchstart', function () &#123;&#125;);","tags":[{"name":"CSS","slug":"css","permalink":"https://jesse121.github.io/tags/css/"}]},{"title":"CSS3创建圆圈进度条","date":"2018-03-12T02:17:04.000Z","path":"articles/html-css/css3-circle-progress.html","text":"最近在工作中需要做一个圆圈倒计时，刚开始的想法是做个纯数字的倒计时即可，可是需求觉得这个不太好看，想加个倒计时进度条。于是就有了接下来的分析过程…我们知道CSS3可以很方便的画圆，圆环，然后在加上一个旋转动画不就可以实现了吗？于是先把圆环画出来了 做到这里问题又来了，如何让红色的圆环一点一点的消失呢？此处一个圆环再怎么旋转终究是一个圆环，此时觉得一个圆可能不够，何不在画一个白色的半圆再旋转呢？可是白色的半圆又如何一点一点的显示呢?貌似又回到了问题的起点。我们知道overflow：hidden;可以让多余的部分隐藏，如果在配合两个半圆旋转不就可以实现了吗？先画两个半圆试试左半圆 右半圆 如果都顺时针旋转45度再刚刚好拼在一起就是一个完整的圆环 .circleProgress_wrapper{ width: 160px; height: 160px; margin: 10px auto; position: relative; } .wrapper{ width: 80px; height: 160px; position: absolute; top:0; /*overflow: hidden;*/ } .right{ right:0; } .left{ left:0; } .circleProgress{ width: 160px; height: 160px; border:20px solid transparent; border-radius: 50%; position: absolute; top:0; /*transform: rotate(45deg);*/ } .rightcircle{ border-top:20px solid red; border-right:20px solid red; right:0; animation: circleProgressLoad_right 6s linear infinite; } .leftcircle{ border-bottom:20px solid red; border-left:20px solid red; left:0; animation: circleProgressLoad_left 6s linear infinite; } 此时当我们再旋转的时候发现，圆环可以实现一点一点的消失了，但是当转过一个180度的时候这个半圆右出现了，此时我们可以用到前面的overflow:hidden;CSS代码如下.circleProgress_wrapper&#123; width: 160px; height: 160px; margin: 10px auto; position: relative;&#125;.wrapper&#123; width: 80px; height: 160px; position: absolute; top:0; overflow: hidden;&#125;.right&#123; right:0;&#125;.left&#123; left:0;&#125;.circleProgress&#123; width: 160px; height: 160px; border:20px solid transparent; border-radius: 50%; position: absolute; top:0; /*transform: rotate(45deg);*/&#125; .rightcircle&#123; border-top:20px solid red; border-right:20px solid red; right:0; animation: circleProgressLoad_right 6s linear infinite;&#125;.leftcircle&#123; border-bottom:20px solid red; border-left:20px solid red; left:0; animation: circleProgressLoad_left 6s linear infinite;&#125; 接下来用css3写个旋转动画即可 .rightcircle&#123; border-top:20px solid red; border-right:20px solid red; right:0; animation: circleProgressLoad_right 6s linear infinite;&#125;.leftcircle&#123; border-bottom:20px solid red; border-left:20px solid red; left:0; animation: circleProgressLoad_left 6s linear infinite;&#125;@keyframes circleProgressLoad_right&#123; 0%&#123; transform: rotate(45deg); &#125; 50%,100%&#123; transform: rotate(225deg); &#125;&#125;@keyframes circleProgressLoad_left&#123; 0%,50%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(225deg); &#125;&#125; 完整的demo可以查看下面的实例 目前这里的倒计时动画是动画时间是6s，这里可以根据需要自行修改，这里的运行时间我在项目中是用js控制的，这样可以根据后台下发的时间值来倒计时，非常方便。","tags":[{"name":"CSS","slug":"css","permalink":"https://jesse121.github.io/tags/css/"}]},{"title":"LNMP + Apache 架构配置","date":"2018-02-11T00:08:12.000Z","path":"articles/webserver/LNMPA.html","text":"从事前端开发已3年有余，越来越发现前端开发要学习的知识已不仅仅是html+css+js那么简单了，2017年市场上就有了大前端的概念，可以说对前端工程师的要求也越来越高了，从招聘的要求中可以看到熟悉一门后端语言可以说是标配了。由于目前公司用的后台语言是PHP，借此机会充分锻炼了我的PHP技能。如今不仅要对PHP语言熟悉，还要熟悉公司整个架构，今天我通过在WIN7上安装的虚拟机上练习了下搭建LNMPA架构，顺便做下笔记。 前提准备需要在官网上下载以下软件 CentOS 这里选择aliyun的镜像 Virtual Box 这里选择5.2.8版本 xshell5 这里选择可以免费使用的Home &amp; School user 安装CentOS系统 安装virtual box虚拟机 新建虚拟机电脑，输入名称CentOS,然后一直选择下一步 启动CentOS,选择启动盘时，选择我们下载好的CentOS镜像文件后，点击启动 进入安装界面，选择Install CentOS 7 安装过程中设置好语言，安装位置(磁盘分区选择默认)和网络(打开以太网连接),设置好后点击开始安装 安装过程中设置root密码及创建用户,安装完成后点击重启 设置固定ip方便xshell远程登录网卡设置网卡设置前先查询主机的网络ipcmd ipconfig /all分别记下本地连接的ipv4地址、子网掩码、网关登录centos虚拟主机后cd /etc/sysconfig/network-scripts/ls 一般第一个就是自己的网卡，我这里是ifcfg-enp0s3vi ifcfg-enp0s3 添加以下内容BOOTPROTO=\"dhcp\"//改为\"static\"IPADDR=\"10.0.5.100\"//设置为与ipv4地址在同一网段NETMASK=\"255.255.0.0\"//设置子网掩码GATEWAY=\"10.0.0.1\"//设置网关 执行systemctl restart network.service //重启网络 此时测试主机和虚拟机是否可互相ping通 开启22端口firewall-cmd --zone=public --add-port=22/tcp --permanent //开启22端口systemctl restart firewalld.service //重启防火墙 设置防火墙允许http服务firewall-cmd --add-service=http --permanentfirewall-cmd --reload 此时可在xshell上远程登录虚拟主机了ssh username@10.0.5.100 LAMP环境搭建安装Apachesudo yum -y install httpd 安装完成后，修改配置文件，vi /etc/httpd/conf/httpd.conf 把 ServerName 前的 # 去掉，并修改为：ServerName 127.0.0.1 并保存重启apachesudo apachectl restart 在主机浏览器中输入10.0.5.100即可看到apache测试页面(需要开启80端口) 安装MySQLsudo yum -y install mysql mariadb-server 安装完成后，启动 MySQL：sudo systemctl start mariadb.service 接下来开始初始化 MySQL，并按照提示设置 MySQL中的 root 用户的密码及其他配置：sudo mysql_secure_installation 配置如下Enter current password for root (enter for none) （按回车）Set root password? [Y/n] （输入 Y：回车）New password: （输入新密码，回车）Re-enter new password: （再次输入新密码，回车）Remove anonymous users? [Y/n] （输入 Y：回车）Disallow root login remotely? [Y/n] （输入 Y：回车）Remove test database and access to it? [Y/n] （输入 Y：回车）Reload privilege tables now? [Y/n] （输入 Y：回车） 登录mysqlmysql -u root -p 安装 PHP7安装epelsudo yum -y install epel-release 更换rpm源sudo rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 安装php7.0sudo yum -y install php70w 安装结束后，重启 Apachesudo apachectl restart 在 Apache 的默认网站目录添加 phpinfo.php 文件，vi /var/www/html/phpinfo.php //添加以下内容&lt;?phpphpinfo();?&gt; 设置开机启动项systemctl enable httpd.servicesystemctl enable mariadb.service 至此，LAMP 环境搭建完成！ LNMP环境搭建安装 Nginx此步骤接上，为了避免冲突，先关闭 Apache： sudo systemctl stop httpd.serviceCentOS 官方 rpm 源是没有 nginx 安装包的，需要手动添加，cd /etc/yum.repos.d/vi nginx.repo 往 nginx.repo 文件里添加如下代码：[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearchgpgcheck=0enabled=1 保存后，即可开始安装 Nginx，sudo yum -y install nginx 安装结束后，启动 Nginx,记得先关闭 Apachesudo systemctl start nginx.service 此时用浏览器访问10.0.5.100即可看到Welcome to nginx! 安装PHP-FPM(FastCGI)sudo yum -y install php-fpm 开启php-fpmsudo systemctl start php-fpm.service 编辑 Nginx 的默认配置文件 default.confsudo vim /etc/nginx/conf.d/default.conf 把 default.conf 文件中 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 这一行下面的 # 注释去掉，并修改 root 后面的目录为：/usr/share/nginx/html;（此目录为 Nginx 的默认网站目录），修改 SCRIPT_FILENAME 后的参数为：$document_root$fastcgi_script_name;重启 Nginx, systemctl restart nginx.service同样，在 Nginx 的默认网站目录下添加 phpinfo.php 文件,在浏览器中可浏览php相关信息 设置开机启动项systemctl enable httpd.servicesystemctl enable mariadb.service 至此，LNMP 环境搭建完成！ LNMP + Apache 架构配置：Nginx 做前端代理 + Apache 做后端服务Apache优势与劣势Apache用户基数大，稳定，兼容性高，在处理动态 php 页面时，mod_php 模块也比 php-cgi 模块更稳定更高效。Apache过于臃肿以及对静态文件响应过于缓慢让很多使用者感到头疼 Nginx优势与劣势Nginx 对于高并发性能出众，Proxy 功能强效率高，占用系统资源少Nginx在处理 php 脚本时需要通过 php-fpm(FastCGI) 解析，而 php-fpm 不够稳定，经常出现 502 错误，生成相对复杂的页面没有优势，反而会使 php-cgi 进程变为僵尸进程。 很多大型的网站都是采用 Nginx 前端 + Apache 后端的服务器架构，这样可以很好地结合了 Nginx 高并发和静态页面高效率以及 Apache 稳定的动态页面处理特点，再也不用担心 Nginx 以 FastCGI 模式运行 PHP 时的502问题和 Apache 处理静态页面过慢、负载过高的问题。 配置 LNMP + Apache 架构编辑 Nginx 的默认配置文件sudo vim /etc/nginx/conf.d/default.conf 注释掉之前 FastCGI 监听的配置，并添加Apache对php脚本的监听# proxy the PHP scripts to Apache listening on 127.0.0.1:80#location ~ \\.php$ &#123; proxy_pass http://127.0.0.1:8080;&#125;# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000##location ~ \\.php$ &#123;# root /usr/share/nginx/html;# fastcgi_pass 127.0.0.1:9000;# fastcgi_index index.php;# fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;# include fastcgi_params;#&#125; 编辑 Apache 的配置文件sudo vim /etc/httpd/conf/httpd.conf 找到 Listen 字段，并改为：Listen 127.0.0.1:8080，让 Apache 来监听这个端口，修改 Apache 的网站根目录为：/usr/share/nginx/html，与上述 Nginx 对应的网站目录保持一致 重启 Nginx ,Apache 服务,并确保这两个服务开机自启：sudo systemctl restart httpd.servicesudo systemctl restart nginx.servicesystemctl enable httpd.servicesystemctl enable nginx.service 发现出现 502 Bad Gateway经查阅相关资料发现是由于开启了 selinux 服务导致的，关闭 selinux 即可。sudo vim /etc/selinux/config SELINUX=disabled 修改保存后，通过 reboot 命令重启 CentOS 服务器 至此，LNMP + Apache 架构配置完成！可通过浏览器查看http://10.0.5.100/phpinfo.php来确认 参考文献Win7 下 VMware 虚拟机中安装 CentOS 服务器","tags":[{"name":"MySQL","slug":"mysql","permalink":"https://jesse121.github.io/tags/mysql/"},{"name":"PHP","slug":"php","permalink":"https://jesse121.github.io/tags/php/"},{"name":"Apache","slug":"apache","permalink":"https://jesse121.github.io/tags/apache/"},{"name":"Linux","slug":"linux","permalink":"https://jesse121.github.io/tags/linux/"},{"name":"CentOS","slug":"centos","permalink":"https://jesse121.github.io/tags/centos/"},{"name":"Nginx","slug":"nginx","permalink":"https://jesse121.github.io/tags/nginx/"}]},{"title":"利用Webpack搭建的前端工程化环境","date":"2018-01-17T00:06:27.000Z","path":"articles/tool/webpack-vue.html","text":"随着webpack3.x的发布，其功能也越来越强大，很多的项目的编译打包工具也由gulp逐渐转移到webpack。最近因为项目重构考虑使用使用vue，同时想从原来的gulp切换到webpack，所以搭建了webpack-vue的前端脚手架工具，这里记录下搭建的过程中的要点。项目源码 1. 用yarn代替npmnpm是一款非常好的包管理工具，之前在用npm安装项目依赖的时候总会因为某些依赖包推出了新版本从而导致编译结果不一样的问题，这是因为在安装依赖的时候npm并没有锁定依赖包的版本号(npm5好像已经解决了这个问题)，每次安装的时候总是获取最新的依赖包，导致编译结果不一样。用yarn安装依赖包可以完美的解决这个问题。去官网下载并安装yarn在命令行中执行yarn -versions,若能输出版本号表示安装成功 2. 初始化生成package.json文件执行yarn init,填写项目相关信息 3. 安装项目依赖包和开发依赖包执行yarn add *** ,安装项目依赖包，添加–dev表示安装成开发依赖，具体安装的依赖包可查阅项目源码中package.json文件 4. 建立常用库配置文件并打包常用库文件1. 新建webpack-dll.config.js文件这个配置文件只要是用来打包库文件的，这里介绍下几个重点配置output: &#123; path: outputDir, filename: 'js/lib/[name].js', library: '[name]_library', /*libraryTarget: 'umd'*/&#125;, output中的library和libraryTarget是为了自定义打包后的文件以怎样的形式输出，这里采用默认的var形式new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125;&#125;), 这里定义环境为开发环境，方便生成的库文件直接用于开发环境 //稳定模块IDnew webpack.HashedModuleIdsPlugin(),new webpack.DllPlugin(&#123; // 本Dll文件中各模块的索引，供DllReferencePlugin读取使用 path: dll_manifest_name + '.json', //当前Dll的所有内容都会存放在这个参数指定变量名的一个全局变量下，注意与参数output.library保持一致 name: '[name]_library', // 指定一个路径作为上下文环境，需要与DllReferencePlugin的context参数保持一致，建议统一设置为项目根目录 context: __dirname,&#125;) 这个是为了稳定模块ID并生成manifest文件，方便在生产环境中通过读取dll_manifest知道哪些文件已经被dll打包，而不需要再次打包 2. 生成库文件dll.js执行 yarn dll,会在src/app/js/lib/文件夹下生成dll.js文件，该文件打包了vue2.5.13,axios0.17.1,flexible,webpack-zepto，具体要打包哪些文件可由webpack-dll.config.js中的entries来配置若有必要可考虑生成dll.css 5. 建立配置文件这里我将配置文件分为3个，一个基础配置文件，一个开发环境配置文件，一个生产环境配置文件，开发环境和生产环境配置文件通过webpack-merge插件调用基础配置文件。 基础配置文件webpack.base.js在基础配置文件中包含了基本的配置信息，这里主要介绍下多页面配置中的htmlWebpackPlugin插件的使用。var pages = getEntry(entryDir + '/html/**/*.ejs');for (var pathname in pages) &#123; var conf = &#123; // html模板文件输入路径 template: entryDir + '/html/' + pathname + '.js', // html文件输出路径 filename: outputDir + '/html/' + pathname + '.html', inject: true, cache: true, //只改动变动的文件 minify: &#123; removeComments: true, collapseWhitespace: false &#125; &#125;; //根据chunks提取页面js,css和公共verdors if (pathname in module.exports.entry) &#123; conf.chunks = [pathname, 'vendors']; &#125; else &#123; conf.chunks = ['vendors']; &#125; module.exports.plugins.push(new htmlWebpackPlugin(conf));&#125; 这里多页面配置采用的是ejs模板，通过循环入口文件，每个模板文件都配置一个htmlWebpackPlugin插件编译，最后达到生成多个页面的目的，通过chunks来提取页面的js/css/img等 开发环境配置文件webpack.dev.js在开发环境配置文件，通过使用webpack-dev-server插件来建立一个静态服务器提供服务devServer: &#123; //设置服务器主文件夹，默认情况下，从项目的根目录提供文件 contentBase: outputDir, //自动开启默认浏览器 //open: true, //开启热模块替换,只重载页面中变化了的部分 //hot: true, //hotOnly:true, //开启gzip压缩 compress: true, //使用inlilne模式,会触发页面的动态重载 inline: true, //当编译错误的时候，网页上显示错误信息 overlay: &#123; warnings: true, errors: true &#125;, //浏览器自动打开的文件夹 //openPage: 'html/', //只在shell中展示错误信息 //stats: 'errors-only', //设置域名，默认是localhost host: 'localhost', port: 8080&#125;, 在使用热更新时需要使用热更新插件//热模块替换插件new webpack.HotModuleReplacementPlugin() 生产环境配置文件webpack.prod.js在生产环境中我们需要关注公共组件的分离，代码压缩，文件缓存等问题，在公共组件分离时通过读取dll_manifest文件知道哪些文件不用打包，从而减少打包后的文件大小new webpack.HashedModuleIdsPlugin(),new webpack.DllReferencePlugin(&#123; // 指定一个路径作为上下文环境，需要与DllPlugin的context参数保持一致，建议统一设置为项目根目录 context: __dirname, // 指定manifest.json manifest: require('../' + dll_manifest_name + '.json'), // 当前Dll的所有内容都会存放在这个参数指定变量名的一个全局变量下，注意与DllPlugin的name参数保持一致 name: 'dll_library',&#125;), 在考虑代码压缩时通过使用以下配置//压缩css代码new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.css\\.*(?!.*map)/g, //注意不要写成 /\\.css$/g cssProcessor: require('cssnano'), cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125;, // 避免 cssnano 重新计算 z-index safe: true &#125;, canPrint: true&#125;),//提取cssnew ExtractTextPlugin('css/[name].css?v=[contenthash:8]'),//压缩JS代码new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125;, output: &#123; comments: false, &#125;&#125;), 在考虑线上文件缓存问题时可以使用以下配置output: &#123; //publicPath: 'http://localhost:8080/', filename: 'js/[name].js?v=[chunkhash:8]'&#125;, 这里建议使用chunkhash,使用hash每次编译都会变化 至此配置以基本完成，目前仍有一些不足之处，一直在改进。源码src/app/文件夹下有一demo，大家可参考demo愉快的进行开发了，有问题欢迎评论提出 参考文献 webpack官方文档, Webpack的dll功能, 详解webpack中的hash、chunkhash、contenthash区别","tags":[{"name":"Webpack","slug":"webpack","permalink":"https://jesse121.github.io/tags/webpack/"},{"name":"Vue","slug":"vue","permalink":"https://jesse121.github.io/tags/vue/"}]},{"title":"针对模拟滚动条插件(jQuery.slimscroll.js)的修改","date":"2017-12-23T07:19:24.000Z","path":"articles/jquery/fix-the-plugin-of-slimscroll.html","text":"在开发过程中程序员总会碰到产品经理提出的各种稀奇古怪的需求，尽管有些需求很奇葩，但不得不说有些须有还是能指引我们不断的学习与进步，最近在工作中就碰到这种问题。需求是要求在各主流浏览器上使用自定义的滚动条样式，并且达到完美兼容，此篇博客记录自己的分析过程。此篇博客的源码可访问slimscroll 为了能使用自定义的滚动条样式并且能在各主流浏览器上兼容，首先想到的就是css定制滚动条的样式。于是在网上搜索了下发现确实有这样的css样式存在：ul::-webkit-scrollbar/*滚动条整体部分，其中的属性有width,height,background,border（就和一个块级元素一样）等。*/ul::-webkit-scrollbar-button /*滚动条两端的按钮。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。*/ul::-webkit-scrollbar-track /* 外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。*/ul::-webkit-scrollbar-track-piece /*内层轨道，滚动条中间部分（除去）。*/ul::-webkit-scrollbar-thumb /*滚动条里面可以拖动的那部分*/ul::-webkit-scrollbar-corner /* 边角*/ul::-webkit-resizer /*定义右下角拖动块的样式*/ 这里只是初略的介绍下，具体的使用方法可参考这篇博客自定义浏览器滚动条的样式，打造属于你的滚动条风格这种方法确实可以定制滚动条样式，但是仅仅是在webkit内核浏览器有效，不能达到完美兼容。上面的博客中推荐一种jquery插件来解决这个问题，但是介绍的并不全面，也不好使用。于是我在网上搜索了下发现类似的jquery插件有很多，为了更贴近项目需要我选择了jquery.slimscroll.js. 可是在实际使用的过程中发现该插件不支持滚动的内容翻页，一旦翻页追加新内容，因为内容高度的变化导致存在滚动内容跳跃的情况。 重现问题看实际效果请猛击这里demo1从该插件的github上下载源码，并引入到页面中，为了看到效果请打开调试面板，我设置了在内容滚动时输出其scrollTop值，根据输出的结果我们可以很明显的看到在追加新内容后，内容会有跳跃的情况scrollTop 49scrollTop 51scrollTop 105 //内容向上跳跃了scrollTop 108 打开源码分析原因源码中的以下这段是在拖动滚动条时要触发的函数// make it draggable and no longer dependent on the jqueryUIif (o.railDraggable)&#123; //默认设置为true bar.bind(\"mousedown\", function(e) &#123; var $doc = $(document); isDragg = true; t = parseFloat(bar.css('top')); pageY = e.pageY; $doc.bind(\"mousemove.slimscroll\", function(e)&#123; currTop = t + e.pageY - pageY; bar.css('top', currTop); scrollContent(0, bar.position().top, false);// scroll content &#125;); $doc.bind(\"mouseup.slimscroll\", function(e) &#123; isDragg = false;hideBar(); $doc.unbind('.slimscroll'); &#125;); return false; &#125;).bind(\"selectstart.slimscroll\", function(e)&#123; e.stopPropagation(); e.preventDefault(); return false; &#125;);&#125; 翻页追加新内容的时候，我们需要重新初始化该插件，初始化的过程中会重新计算滚动条的top值，下拉翻页时由于鼠标一直是按下的状态，在追加新内容后t值和pageY值记录的一直是按下状态时刻(未追加新内容时刻)的。所以当追加完新内容后，再触发mousemove事件时，currTop又会被计算得到翻页之前的值(滚动条的top值也是之前的值了)，而此时的内容高度已经变化了，所以内容会跳跃。(不知道有没有解释清楚啊) 针对问题的解决之道通过上面的分析我们知道由于在翻页追加新内容后未获取到最新的滚动条的top值和最新的e.pageY值，针对这个问题我在源码中添加了以下一些代码： // scroll content by the given offsetscrollContent(offset, false, true);// 以下是我添加的内容//追加新内容后强制解绑之前的鼠标事件，不使用翻页之前记录的值$(document).unbind('mousemove.slimscroll');//解绑后为了能继续下拉滚动条，需重新绑定鼠标事件//记录最新的滚动条的top值和鼠标位置var pageY, t = parseFloat(bar.css('top'));$(document).bind(\"mousemove.slimscroll\", function(e) &#123; //这里判断鼠标状态是为了区分滚动事件和拖动事件 //当鼠标左键是按下状态时， if (e.buttons == 1) &#123; pageY = pageY || e.pageY currTop = t + e.pageY - pageY; bar.css('top', currTop); scrollContent(0, currTop, false); // scroll content &#125; return;&#125;) 以上代码解决翻页追加新内容后，拖动滚动条存在的跳跃问题function _onWheel(e) &#123; //... var e = e || window.event; // 以下是我添加的内容 //取消拖动 $(document).unbind('mousemove.slimscroll'); //...&#125; 以上这段代码是为了解决翻页滚动后的点击事件被覆盖问题 这里为什么用e.buttons而不用e.button?MouseEvent.buttons 可指示任意鼠标事件中鼠标的按键情况MouseEvent.button 只能够表明在事件中通过按下或者放开一个按键，或者是多个按键同时按下时，哪一个按键被按下。因此，它对判断mouseenter, mouseleave, mouseover, mouseout or mousemove这些事件并不可靠。 修改源码之后的效果请猛击这里demo2 这里修改的代码仅仅是我一人之见，如果您有更好的方法，欢迎在评论中提出 参考文献： MouseEvent.buttonMouseEvent.buttons","tags":[{"name":"jQuery","slug":"jquery","permalink":"https://jesse121.github.io/tags/jquery/"}]},{"title":"如何编写高性能的Javascript","date":"2017-12-06T00:08:18.000Z","path":"articles/javascript/how-to-write-high-performance-javascript.html","text":"作为前端工程师javascript可谓是基本功，那么如何写出高性能的js代码呢？这就需要我们平时在编码的时候注意各种写法，本文就简单介绍了几种策略，希望对大家的工作起到帮助^_^ 1.减少全局变量的使用，避免冲突全局变量的问题在于,你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量,他们住在同一个全局命名空间,所以当程序的两个不同部分定义同名但不同作用的全局变量的时候,命名冲突在所难免。并且全局变量在js运行完后并不会被垃圾回收机制回收，因此这块内存一直被占用着 使用匿名函数 //合理的利用命名空间达到匿名函数之间的通信var GLOBAL = &#123;&#125;;(function()&#123; var test = \"123\"; GLOBAL.a = test; //A code &#125;())(function()&#123; //B code console.log(GLOBAL.a)&#125;()) 注意隐式全局变量以下是反例，请勿模仿 function foo() &#123; var a = b = 0;//b是全局变量 // ... &#125; 2.使用高性能的变量或属性值读取方式若函数在运行过程中遇到一个变量，就会判定从哪里取的数据值，在这个过程中会顺着作用域链查找此名称的标识符，该搜索会从最近的作用域开始，如果找到了就使用这个变量值，如果没找到就会进入外层作用域中，直至最外层的全局作用域。一个变量在作用域链上查找的层级越多则读取速度就越慢，因此函数中局部变量访问速度最快，全部变量访问速度最慢。 最好的做法是将变量定义为本作用域的局部变量，如果需要频繁的访问一个外部作用域的变量，最好是用一个局部变量保存外部变量。例1：jQuery插件开发中传入的window和document就是将全局变量保存为本作用域中的局部变量;(function($, window, document, undefined)&#123; $.fn.extend(&#123; pluginName : function()&#123; return this.each(function()&#123; // plugin implementation code here &#125;); &#125;; &#125;)&#125;)(jQuery, window, document); 例2：将for循环长度缓存for(var i = 0,len = arr.length; i &lt; len; i++)&#123; arr[i] *= 2;&#125; 意义：在js代码中需要访问到变量时，需要注意到是否存在这种问题，特别是需要频繁访问的变量，尽量将外部作用域中的变量或对象上的属性值缓存在局部变量中，以提高读取性能。 3.避免使用with(),eval()当代码流执行到一个with()表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高了。eval()接受任意的字符串，并当作JavaScript代码来处理当你在 JavaScript 代码中执行(另一段)JavaScript 代码时,你付出二次评估的代价。此代码首先被评估 为正常代码,然后在执行过程中,运行字符串中的代码时发生另一次评估。二次评估是一项昂贵的操作,与直接包含相应代码相比将占用更长时间。var num1 = 5,num2 = 6;result = eval(\"num1 + num2\")//字符串内的代码会进行第二次评估 同样重要的是要记住，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。 4.高效的DOM操作 合并多次DOM操作为单次操作 //优化方案1element.style.cssText += \"border: 1px solid #ccc;\"//优化方案2element.className += 'empty';element.classList.add('empty');//IE兼容性不太好 把DOM元素离线或隐藏后修改 使用文档片段 设置display:none;来隐藏元素 克隆DOM元素到内存中，操作完后再替换 设置具有动画效果的DOM元素脱离文档流 设置DOM元素的position属性为fixed或position 谨慎获取DOM元素的布局信息 offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop, scrollLeft, scrollWidth, scrollHeight clientTop, clientLeft, clientWidth, clientHeight getComputedStyle() (currentStyle in IE)当你查询布局信息如偏移量、滚动条位置，或风格属性时，浏览器刷新队列并执行所有修改操作，以返回最新的数值。最好是尽量减少对布局信息的查询次数，查询时将它赋给局部变量，并用局部变量参与计算。 利用事件委托方式绑定事件页面中元素绑定的事件越多，占用的处理时间和内存就越大，性能也就越差 5.if-else与switch 比较大多数情况下switch 表达式比if-else 更快，但只有当条件体数量很大时才明显更快。两者间的主要性能区别在于：当条件体增加时，if-else 性能负担增加的程度比switch更多。因此，我们的自然倾向认为条件体较少时应使用if-else 而条件体较多时应使用switch 表达式，如果从性能方面考虑也是正确的。 优化if-else优化if-else的目标总是最小化找到正确分支之前所判断条件体的数量。最简单的优化方法是将最常见的条件体放在首位 6.释放内存尽量减少使用全局变量，全局变量在整个页面生命周期中不会被回收确保解除不需要的事件监听不要再闭包中返回外界不需要的对象，会造成内存泄漏，无法回收 7.函数有递归时使用尾递归优化递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 参考文献： 高性能的javascript 深入理解javascript系列","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"MySQL基础","date":"2017-11-23T23:48:08.000Z","path":"articles/mysql/MySQL.html","text":"如今的前端开发不再是以前的切图仔或者是写写静态页面就能胜任的了，如今的工作中也常用到PHP和MYSQL，这就要求我们前端开发也必须熟悉PHP和mMySQL相关内容，这篇博客仅是记录mysql学习课程笔记。 MySQL常用语句登录 mysql -uroot -p登录并打开某数据库 mysql -uroot -p -D db_name 常用MySQL的关键字需要大写，库名，表名，字段名需要小写 常用sql语句SELECT USER();SELECT VERSION();SELECT NOW();SELECT DATABASE();SHOW WARNINGS; -- 查看上一步产生的警告 MySQL注释-- 注释内容 创建数据库CREATE DATABASE db_name;CREATE DATABASE IF NOT EXISTS db_name;CREATE DATABASE db_name CHARACTER SET 'UTF8'; 查看数据库的详细信息SHOW CREATE DATABASE db_name; 修改数据库编码方式ALTER DATABASE db_name CHARACTER SET 'UTF8'; 查看当前服务器下的全部数据库SHOW DATABASES; 删除指定的数据库DROP DATABASE db_name;DROP DATABASE IF EXISTS db_name; 创建数据表CREATE TABLE [IF NOT EXISTS] tb_name( 字段名称 字段类型[完整性约束条件], ...)ENGINE=存储引擎 CHARSET=编码方式 mysql中字段类型 数值型 字符串型 日期时间类型 完整性约束条件 unsigned 无符号没有负数，从0开始 zerofill 当显示长度不够使用前补0填充 NOT NULL 非空 DEFAULT 默认值 PRIMARY KEY 主键 标识记录的唯一性，不能重复 一个表只能有一个主键 UNIQUE KEY 唯一性 可有多个唯一性字段 NULL除外 AUTO INCREMENT 自动增长 只能用于数值列 配合索引 FOREIGN KEY 外键约束 查看数据表SHOW TABLES;SHOW FULL TABLES FROM db_name; 查看指定数据表的详细信息SHOW CREATE TABLE tb_name; 查看表结构DESC tb_name; 删除指定数据表DROP TABLE IF EXISTS tb_name; 彻底清空数据表TRUNCATE tb_name; 向表中插入数据INSERT tb_name(id,username ...) VALUES(1,'jesse'...); 查询表中所有记录SELECT * FROM imooc_user; 表结构相关操作添加字段ALTER TABLE tb_nameADD 字段名称 字段属性[约束条件]; 删除字段ALTER TABLE tb_nameDROP 字段名称; 添加默认值ALTER TABLE tb_nameALTER 字段名称 SET DEFAULT 默认值; 删除默认值ALTER TABLE tb_nameALTER 字段名称 DROP DEFAULT; 修改字段类型 字段属性ALTER TABLE tb_nameMODIFY 字段名称 字段类型[字段属性] 修改字段名称 字段类型 字段属性ALTER TABLE tb_nameCHANGE 原字段名称 新字段名称 字段类型[字段属性] 添加主键ALTER TABLE tb_nameADD PRIMARY KEY(字段名称); 删除主键ALTER TABLE tb_nameDROP PRIMARY KEY; 添加唯一ALTER TABLE tb_nameADD UNIQUE KEY|INDEX index_name(字段名称); 删除唯一ALTER TABLE tb_nameADD index_name; 修改表名ALTER TABLE tb_name RENAME new_tb_name;RENAME TABLE tb_name TO new_tb_name; 添加记录INSERT tb_name(col_name...) VALUES(values...); 添加多条记录INSERT tb_name(col_name...) VALUES(values...),(values...); 修改记录UPDATE tb_name SET 字段名称=值，字段名称=值 WHERE 条件 删除记录DELETE FROM tb_name WHERE 条件 查询记录SELECT * FROM tb_name;SELECT 字段名称 FROM db_name.tb_name;SELECT 字段名称 别名 FROM tb_name; 选出null值SELECT * FROM user WHERE userDesc&lt;=&gt;NULL;SELECT * FROM user WHERE userDesc IS [NOT] NULL; 指定范围 BETWEEN … AND …指定集合 IN(…)匹配字符 LIKE %代表任意长度字符 _代表任意一个字符 GROUP BY分组配合GROUP_CONCAT()使用SELECT GROUP_CONCAT(username),age,sex FROM user1 GROUP BY sex; 配合函数使用 MAX() MIN() AVG() SUM()COUNT()当统计的字段值为null时不计入在内COUNT(*)会全部计入配合WITH ROLLUP使用 会在记录末尾添加一条记录，是所有上面记录的总和HAVING子句对分组结果进行二次筛选 ORDER BY 排序SELECT id,ussename,age FROM userORDER BY id DESC,age ASC; LIMIT 限制结果集显示条数SELECT * FROM user LIMIT 5;SELECT * FROM user LIMIT 0,5; offset从0开始 多表查询内连接SELECT 字段名… FROM tb_name1 INNER JOIN tb_name2 ON 连接条件SELECT e.id,e.username,e.age,d.depNameFORM emp AS eINNER JOIN dep AS dON d.id = e.depId; 外连接SELECT 字段名... FROM tb_name1LEFT [OUTER] JOIN tb_name2ON 条件;SELECT 字段名... FROM tb_name1RIGHT [OUTER] JOIN tb_name2ON 条件; 创建外键建表创建FOREIGN KEY(字表字段名) REFERENCES 父表(父表主键字段名) 动态创建添加外键之前表中数据没有脏值ALTER TRABLE tb_nameADD FOREIGN KEY(外键字段) REFERENCES 主表(主键字段); 删除外键ALTER TABLE tb_nameDROP FORENGIN KEY fk_name; 添加外键时指定级联操作ALTER TABLE tb_nameADD FOREIGN KEY(外键字段) REFERENCES 主表(主键字段);ON DELETE CASCADE ON UPDATE CASCADE; 由IN引发的子查询SELECT * FROM empWHERE depId IN (SELECT id FROM dep); 由EXISTS引发的子查询SELECT * FROM empWHERE EXISTS (SELECT depName FROM dep WHERE id=10); INSERT … SELECT …将查询结果插入CREATE … SELECT …将查询结果写入表INSERT … SET … 将查询结果赋值给某字段 联合查询 UNION 合并查询结果并去掉重复 UNION ALL 合并查询结果 常用函数 CHAR_LENGTH()返回字符串字符数 LENGTH()返回字符串长度 CONCAT(S1,S2…)合并字符串 如果字符串中包含null,结果为null CONCAT_WS(X,S1,S2…)已指定分隔符拼接字符串 UPPER()|UCASE()转大写 LOWER()|LCASE()转小写 REVERSE()反转字符 LEFT()|RIGHT() SUBSTRING()截取字符串 STRCMP()比较字符串","tags":[{"name":"MySQL","slug":"mysql","permalink":"https://jesse121.github.io/tags/mysql/"}]},{"title":"Linux基础","date":"2017-10-17T23:05:49.000Z","path":"articles/webserver/the-usual-command-line-of-linux.html","text":"linux基础ip a 查看ip地址ip addr 查看网卡关机 shutdown -h now重启 shutdown -r now 或者reboot linux目录结构及操作命令linux目录结构/bin 命令存放目录/boot 启动目录/dev 设备文件存放目录/etc 配置文件存放目录/lib 函数库存放目录/home 普通用户家目录/mnt 系统挂载目录/media 媒体设备挂载目录/opt 第三方软件放置目录/root 超级用户家目录/tmp 临时目录/sbin 系统命令行存放目录/proc 放置数据到内存/srv 服务存放数据目录/usr 系统软件资源目录/var 系统相关文档目录 目录管理显示当前目录 pwd目录创建 mkdir [-p] 目录名称 -p依次创建目录目录删除 rmdir [-p] 目录名称 文件操作创建文件 touch 文件名编辑文件 vi 文件名文件查看cat 显示全部内容less 分页显示内容more 分页显示内容 按空格翻页head 显示文件前几行tail显示文件后几行 文件管理复制 cp [-r] 来源文件 目标文件移动 mv 来源文件 目标文件删除 rm [-rf] 文件或目录查找 find 目录 [-name/user/size] 文件名查找命令 which 命令名 用户管理及组群管理查看当前用户 who创建用户 useradd [-g 群组] 用户名设置密码 passwd 用户名删除用户 userdel [-r] 用户名查看群组 groups [用户名]创建群组 groupadd 群组名删除群组 groupdel 群组名用户群组修改 usermod [-g 群组名] 用户名切换用户 su 用户名 权限与角色权限与角色设置修改所有者 chown [-R] 用户名 文件或目录修改所有者和组 chown [-R] 用户名：组名 文件或目录修改组 chgrp [-R] 组名 文件或目录权限修改 chmod [-R] xyz 文件或目录x所有者权限 y所属组权限 z其他用户权限r:4 w:2 x:1 rwx总和即权限chomd -R 777 * 压缩与解压打包压缩tar [-ctxzjJvf] 压缩文件 [源文件]c打包压缩/t查看内容/x解打包解压缩z使用gzip方式/j使用bzip2方式/J使用xz方式/v显示过程 f指定压缩包名称 解压tar -xzvf ***.tar.gz zip压缩zip [-q -r -e -m -o] [yourName].zip someThing -q 表示不显示压缩进度状态-r 表示子目录子文件全部压缩为zip-e 表示你的压缩文件需要加密，终端会提示你输入密码的-m 表示压缩完删除原文件-o 表示设置所有被压缩文件的最后修改时间为当前压缩时间 软件的安装与卸载源码包安装下载源码包(curl,wget)解压(tar)进入目录(cd)编译前配置(./configure)编译(make)编译安装(nake install)删除源码包 make clean rpm包安装下载rpm安装包rpm -ivh 软件包-i 安装 -v 显示详细信息 -h 显示进度卸载 rpm -e 安装包 yum安装管理rpm包安装 yum [-y] install 安装包更新 yum [-y] update 安装包卸载 yum [-y] remove 安装包 常用指令 命令 作用 ls 显示文件或目录 ls -l 列出文件详细信息l(list) ls -a 列出当前目录下所有文件及目录，包括隐藏的a(all) pwd 显示当前目录 mkdir 创建目录 rmdir 删除空目录 cd 打开目录 touch 创建空文件 echo 创建带有内容的文件 cat 查看文件内容 cp 拷贝 mv 移动或重命名 rm 删除文件 rm -r 递归删除，可删除子目录及文件 rm -f 强制删除 find 在文件系统中搜索某文件 wc 统计文本中行数、字数、字符数 grep 在文本文件中查找某个字符串 tree 树形结构显示目录，需要安装tree包 ln 创建链接文件 more、less 分页显示文本文件内容 head、tail 显示文件头、尾内容 其他命令date -s 设置日期时间例如：date -s “2017/11/11 00:00:00” cal 输出当前日历","tags":[{"name":"Linux","slug":"linux","permalink":"https://jesse121.github.io/tags/linux/"}]},{"title":"工作中常用到的Vim命令","date":"2017-10-13T14:22:39.000Z","path":"articles/tool/the-usual-command-line-of-line-of-vim.html","text":"最近工作中需要到linux服务器上更改文件，苦于对vim的各种命令不熟悉，今天特此总结并熟悉一下各种vim命令，好提高工作效率。后期持续更新 vim编辑器个人设置 先复制一份vim配置模板到个人目录下 cp /usr/share/vim/vimrc ~/.vimrc 编辑个人目录下的.vimrc vi ~/.vimrc 进入vim编辑模式编写以下配置信息 syntax on '开启语法高亮'set nu! '设置行号'set autoindent '自动缩进'set tabstop=4 '设置tab键为4个空格' set showmatch '设置匹配模式，类似当输入一个左括号时会匹配相应的右括号' 命令模式（command mode）—执行命令 在该模式中，可以输入命令来执行许多种功能。控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 输入模式（Insert mode）—输入文本 vi被运行时，通常处在命令模式下，键入以下命令 可以使vi退出命令模式，进入输入模式：I（i）、A（a）、O（o）。 末行模式（last line mode）—执行待定命令 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。不过一般我们在使用时把vi简化成两个模式，就是将末行模式（last line mode）也算入命令行模式command mode）。 命令模式下常用命令移动命令^ 移动到当前行的开头处$ 移动到当前行的结尾处w 移动到下一个单词的开始位置gg 移动到文件头shift+g 移动到文件尾h 光标左移j 光标下移k 光标上移l 光标右移Ctrl+b(back) 屏幕往后移动一页Ctrl+f(forward) 屏幕往前移动一页Ctrl+u(up) 屏幕往上移动半页Ctrl+d(down) 屏幕往下移动半页 撤销命令u 倒退一步Ctrl+r 重做 删除命令x 删除当前字符dd 删除光标所在行dgg 删除光标所在行到文件头的所有字符dG 删除光标所在行到文件尾的所有字符 拷贝剪切和粘贴yy 复制光标所在行p 将已复制的数据在光标下一行粘贴P 将已复制的数据在光标上一行粘贴. 重复前一个动作 退出命令:w filename(存入指定文件) 另存为:q 退出:q! 强行退出vi，使被更新的内容不写回文件中。:wq 保存并退出,即将上面的两步操作可以合成一步来完成。:x 保存并退出 搜索命令/text 从光标开始向后查找text，按n查找下一个，按N查找前一个。?text 从光标开始向前查找text，按n查找前一个，按N查找下一个。搜索特殊符号.*[]^%/?~$需要转义:n 将光标快速定位到n行vim +/text a.php 打开a.php并将光标定位到第一个text% 快速定位到另一半符号{}[]() 替换命令r 替换光标所在字符(按下r后输入新字符)%s/t/o/g 将所有的t替换为o 修改命令 c [数字] motionc^ 删除光标从当前位置到当前行的开头处所有字符，并进入插入模式c$ 删除光标从当前位置到当前行的结尾处所有字符，并进入插入模式 插入命令i 在当前位置前插入并切换到输入模式a 在当前位置后插入并切换到输入模式o 在当前行下方插入一行并切换到输入模式 按下插入命令可进入文本输入模式 :!可以执行其他shell命令","tags":[{"name":"Vim","slug":"vim","permalink":"https://jesse121.github.io/tags/vim/"}]},{"title":"Vertical-Align属性探究","date":"2017-09-21T00:46:16.000Z","path":"articles/html-css/make-a-thorough-inquiry-about-css-vertical-align.html","text":"在前端开发中我们经常需要将元素垂直居中对齐，我们很自然的想到使用vertical-align属性，但是使用后却发现有时候能起作用，有时候却又不起作用。究其原因还是因为我们没有将vertical-align属性弄清楚，今天就来分析一下这个属性，若分析有误，还请原谅，望一起探讨！ 规范介绍Value: baseline | sub | super | top | text-top | middle | bottom | text-bottom | &lt;percentage&gt; | &lt;length&gt; | inheritInitial: baselineApplies to: inline-level and 'table-cell' elementsInherited: noPercentages: refer to the 'line-height' of the element itselfMedia: visualComputed value:for &lt;percentage&gt; and &lt;length&gt; the absolute length, otherwise as specified 适用元素该属性仅适用于inline,inline-block,table-cell元素 属性值介绍介绍属性之前先来了解一下各个属性值代表着什么，通过下面这张图可以知道我们知道英语本子每行有4条线，其中红色的线即为基线 所用demo&lt;div class=\"box\"&gt; &lt;span class=\"aa\"&gt;&lt;/span&gt; x&lt;/div&gt; baseline将元素的基线与父元素的基线对齐.aa4&#123; display:inline-block; width:5px; height:5px; background:blue; vertical-align: baseline;&#125; x baseline的确定规则 inline-table元素的baseline是它的table第一行的baseline。 父元素【line box】的baseline是最后一个inline box 的baseline。 inline-block元素，如果内部有line box，则inline-block元素的baseline就是最后一个作为内容存在的元素[inline box]的baseline，而这个元素的baseline的确定就要根据它自身来定了。 inline-block元素，如果其内部没有line box或它的overflow属性不是visible，那么baseline将是这个inline-block元素的底margin边界。 length基于基线上（正值）下（负值）移动元素input[name=\"sex\"]&#123; margin:0; padding:0; vertical-align:-2px;&#125; 基于基线向下移动-2px 女性男性 percentage基于基线上（正值）下（负值）移动元素，值通过百分比乘上line-height而得.aa2&#123; display:inline-block; width:5px; height:5px; background:blue; vertical-align: -10%; line-height: 30px;&#125; x 这里的vertical-align:-10%所代表的实际值是：-10% * 30 = -3px，即向基线下方移动3px注意：若该元素没有定义line-height,则会使用继承的line-height值 middle将元素的中线与父元素的基线加上字母x的高度的一半对齐.aa3&#123; display:inline-block; width:5px; height:5px; background:blue; vertical-align: middle;&#125; x text-top将元素的顶部与父元素正文区域的顶部对齐，元素的位置受父元素font-size的大小影响.aa5&#123; display:inline-block; width:5px; height:5px; background:blue; vertical-align: text-top;&#125; x text-bottom将元素的底部与父元素的正文区域的底部对齐，元素的位置受父元素font-size的大小影响.aa6&#123; display:inline-block; width:5px; height:5px; background:blue; vertical-align: text-bottom;&#125; x top将元素的顶部与line box顶部对齐.aa7&#123; display:inline-block; width:5px; height:5px; background:blue; vertical-align: top;&#125; x bottom将元素的底部与line box底部对齐.aa8&#123; display:inline-block; width:5px; height:5px; background:blue; vertical-align: bottom;&#125; x super将元素置于基线上方合适的位置.aa10&#123; display:inline-block; width:5px; height:5px; background:blue; vertical-align: super;&#125; 102 sub将元素置于基线下方合适的位置.aa9&#123; display:inline-block; width:5px; height:5px; background:blue; vertical-align: sub;&#125; x 参考文章 vertical-alignvertical-align我对CSS vertical-align的一些理解与认识（一）","tags":[{"name":"CSS","slug":"css","permalink":"https://jesse121.github.io/tags/css/"}]},{"title":"Yii1.1.16学习记录","date":"2017-09-13T00:22:39.000Z","path":"articles/php/Yii-study-notes.html","text":"最近工作中用到Yii框架，为此专门在网上找了些相关教程学一下，尽管教程比较老，但学完后至少对Yii框架有了基本了解，特别是widget的使用，感觉Yii真的很强大。 一、框架介绍与安装框架源码下载点击官网 安装在命令行进入到framework 目录执行 ：php yiic.php webapp ../blog在 windows系统中运行 yiic 时，如果出现”php.exe” 不是内部或外部命令，也不是可运行的程序，或批处理文件，需要把php目录添加环境路径里面去。 二、创建与设置默认控制器并载入模板创建控制器class IndexController extends Controller&#123; public function actionIndex()&#123; echo 'jesse'; &#125;&#125; 访问：index.php?r=index/indexr=后面，第一个是控制器，第二个是方法， r就是路由route的缩写 配置默认控制器默认访问：控制器SiteController下面的actionIndex方法Config/main.php是主配置文件，在其中加入：‘defaultController’ =&gt; ‘Index’, 载入外部文件Css与js等一些文件放入assets里面，按照前后台分开Yii::app()-&gt;request-&gt;baseUrlYii::app()返回的是你在index.php里创建的CWebApplication实例。在一次请求处理过程中，这是个唯一的实例。Yii::app()主要负责一些全局性的功能模块。 载入视图$this-&gt;render();会加载布局$this-&gt;renderPartial();不会加载布局（也不能载入框架自带的jquery等）建立文件夹需要根据控制器名字来建立，里面的文件名也就是render或者renderPartial方法传递的名字 如何在视图中处理分配的数据在Yii框架中，数据以对象的形式存在&lt;?php foreach ($article as $v):?&gt; &lt;li&gt;&lt;?php echo $v-&gt;title;?&gt;&lt;/li&gt;&lt;?php endforeach;?&gt; 扩展自定义函数在protected目录下建立funtions.php文件 在单入口引入函数require_once(‘./protected/functions.php’); 三、前台模板载入与layouts使用将静态模板文件(js、css、img)放置在assert文件夹中，在views文件夹下的php模板中调整好静态文件的链接将php模板中的文件中的公共部分可提取放置在layouts文件夹内，并在components/Controller.php文件中设置所使用的公有布局文件 四、gii模块使用与widget使用gii模块使用打开模块，在config/main.php'gii'=&gt;array( 'class'=&gt;'system.gii.GiiModule', 'password'=&gt;'Enter Your Password Here',//设置密码 'ipFilters'=&gt;array('127.0.0.1','::1'),), 访问创建http://localhost/yiitest/shop/index.php?r=模块名字生成Generators添加后台ID需要在main.php里面配置'gii'=&gt;array(),'admin'//加入后台你创建的ID 访问模块moduleshttp://localhost/yiitest/shop/index.php?r=模块/控制器/方法 小物件widget使用CActiveForm 类下面找方法&lt;?php $form = $this-&gt;beginWidget('CActiveForm') ?&gt; &lt;?php echo $form-&gt;textField(模型,'表单名',html属性)) ?&gt;&lt;?php $this-&gt;endWidget() ?&gt; 五、验证码的使用与规则设置验证码的使用public function actions()&#123; return array ( 'captcha'=&gt; array( 'class'=&gt; 'CCatpchaAction', 'height'=&gt; 25, 'width'=&gt;80, 'minLength'=&gt;4, 'maxLength'=&gt;4 ) )) 带有点击刷新：$this-&gt;widget('CCaptcha',array('showRefreshButton'=&gt;false,'clickableImage'=&gt;true,'imageOptions'=&gt;array('alt'=&gt;'点击换图','title'=&gt;'点击换图','style'=&gt;'cursor:pointer'))); 显示错误信息&lt;?php echo $form-&gt;error('模型','name名')?&gt; 修改核心类：在framework/web/widgets/ captcha/CCaptchaAction.php修改run方法里面：$this-&gt;renderImage($this-&gt;getVerifyCode(TRUE)); 设置验证规则：在loginForm.php的rules方法里：array('name','captcha','错误信息'); array('verify',' captcha','message'=&gt;'验证码错误'); 通过验证：$loginForm-&gt;attributes = $_POST['LoginForm']; $loginForm-&gt;validate(); 为模块设置单独布局文件 在模块下面的视图views文件夹里面的components文件中设置public $layout=’//layouts/xx’;xx是自己的布局，去掉/ 在模块下面的视图views文件夹里面建立layouts文件夹，里面放置模块的布局文件， 如果后台模块没有公共区域直接在布局文件里&lt;?php echo $content?&gt; 六、数据库连接配置与模型定义数据库连接配置'db'=&gt;array( 'connectionString' =&gt; 'mysql:host=localhost;dbname=blog', 'emulatePrepare' =&gt; true,//PDO扩展 'username' =&gt; 'root', 'password' =&gt; '', 'charset' =&gt; 'utf8', 'tablePrefix' =&gt; 'hd__'//定义表前缀, 'enableParamLogging' =&gt; TRUE//开启调试信息的SQL语句具体值信息) 查询动作User::model()-&gt;find( 'username=：name', array(':name'=&gt;'admin')) 七、session使用与redirect和createUrlsession使用存储：Yii::app()-&gt;session['logintime'] = time(); 调用：Yii::app()-&gt;session['logintime'] 清除：Yii::app()-&gt;session-&gt;clear();Yii::app()-&gt;session-&gt;destroy(); 退出登陆：Yii::app()-&gt;user-&gt;logout(); redirect跳转如果在当前控制器下：$this-&gt;redirect(array('index'))//跳转到当前控制器index方法 访问其他控制器方法:$this-&gt;redirect(array('控制器/方法')) createUrl方法使用在视图中用$this-&gt;createUrl('控制器/方法'，get参数); $this-&gt;createUrl('article/index',array('aid'=&gt;3)); 八、模型规则与标签设置开启前台验证标签设置public function attributeLabels()&#123; return array( 'passwd' =&gt; '原始密码', );&#125; 规则设置public function rules()&#123; return array( array('passwd','required', 'message'=&gt;'原始密码必填'), );&#125; 开启前台验证必须用render(),在小物件中调用$form=$this-&gt;beginWidget('CActiveForm', array( 'id'=&gt;'contact-form', 'enableClientValidation'=&gt;true, 'clientOptions'=&gt;array( 'validateOnSubmit'=&gt;true, ),)); 九、修改动作与成功提示信息操作成功提示控制器中：Yii::app()-&gt;user-&gt;setFlash('s','添加成功'); 视图中：If(Yii::app()-&gt;user-&gt;hasFlash('s'))&#123; echo Yii::app()-&gt;user-&gt;getFlash('s');&#125; 十、AR类的增删查改增加$model = new Model()；$model-&gt;attributes = $_POST['user'];$model-&gt;save(); save方法，在new Model的时候是增加，在$model::model()的时候是修改。 删除model::model()-&gt;deleteByPk($id) 查询find() 查询一条信息例：find(‘username=:name’ ,array(‘:name’=&gt;’admin’)) findByPk() 通过主键来查询例：findByPk(1) findBysql() 通过SQL来查询出一条例：findBySql(‘SELECT * FROM ‘) findAll() 查询多条信息例：findAll(‘color=:color’ ,array(‘:color’=&gt;’red’)) findAllByPk() 通过主键来查询,可以多个主键例：findAllByPk (array(1,2))findAllBysql() 通过SQL来查询出多条例：findAllBysql (‘SELECT * FROM ‘) 更改$model = Model::model();$info = $model-&gt;findByPk($id);if(isset($_POST['user']))&#123; $info-&gt;attributes = $_POST['user']; $info-&gt;save()//此时save是修改&#125;$this-&gt;render('edit',array('model'=&gt;$info)); 十一、小物件创建radio与select//创建redio&lt;?php echo $form-&gt;radioButtonList( $articleModel, 'type', array(0=&gt;'普通',1=&gt;'热门'), array('separator'=&gt;'&amp;nbsp') ) ?&gt;//创建上传图片$form = $this-&gt;beginWidget('CActiveForm', array('htmlOptions'=&gt;array('enctype'=&gt;'multipart/form-data')));&lt;?php echo $form-&gt;fileField($articleModel, 'thumb') ?&gt;//创建select&lt;?php echo $form-&gt;dropDownList($articleModel,'cid', $cateArr) ?&gt;//创建textarea&lt;?php echo $form-&gt;textArea( $articleModel, 'info', array('cols'=&gt;50,'rows'=&gt;10,'maxlength'=&gt;100) ) ?&gt; 十二、上传类与扩展第三方类略图类的使用上传类$model = new model();$model-&gt;thumb = CUploadedFile::getInstance($model,'thumb');if($model-&gt;thumb)&#123; $name = 'img_' . time() . mt_rand(0,999); $img = $name . '.' . $model-&gt;thumb-&gt;extensionName; $model-&gt;thumb-&gt;saveAs('uploads/' . $img); $model-&gt;thumb = $img;&#125; 扩展缩略图类 在extensions中建立CThumb/CThumb.php文件 在main.php里面配置 'components'=&gt; array( 'thumb' =&gt; array( 'class' =&gt; 'ext.CThumb.CThumb'//路径别名 )) 控制器中添加 $path = dirname(Yii::app()-&gt;BasePath) . '/uploads/';$thumb = Yii::app()-&gt;thumb;$thumb-&gt;image = $path . $imgName;$thumb-&gt;width = 130;$thumb-&gt;height=95;$thumb-&gt;mode = 4;$thumb-&gt;directory = $path;$thumb-&gt;defaultName = $preRand;$thumb-&gt;createThumb();$thumb-&gt;save(); 十三、分页类与后台权限认证分页类//controller$criteria = new CDbCriteria();//AR的另一种写法$model = Model::model();$total = $model-&gt;count($criteria);//统计总条数$pager = new Cpagination($total);//实例化分页类$pager-&gt;pagerSize = 3;//每页显示多少条$pager-&gt;applyLimit($criteria);//进行limit截取$info = $model-&gt;findAll($criteria);//查询截取过的数据$data = array('info'=&gt;$info,'pages'=&gt;$pager);$this-&gt;render('index',$data);//views$this-&gt;widget('CLinkPager', array( 'header' =&gt; '', 'firstPageLabel' =&gt; '首页', 'lastPageLabel' =&gt; '末页', 'prevPageLabel' =&gt; '上一页', 'nextPageLabel' =&gt; '下一页', 'pages' =&gt; $pages, 'maxButtonCount'=&gt; 5,)); 权限验证public function filters()&#123; return array( 'accessControl' //可以用 + -来控制那个方法是否验证 );&#125;public function accessRules()&#123; return array( array( 'allow', 'actions' =&gt; array('index'), 'users' =&gt; array('@') ), array( 'deny', 'users' =&gt; array('*') ), );&#125; allow 允许 deny 拒绝 代表所有用户 @ 代表登陆用户 ? 代表匿名用户 配置默认登陆界面,在main.php'user'=&gt; array( //加上 loginUrl =&gt; array('admin/login/index')) 十四、前台数据分配十五、伪静态路由与缓存隐藏单入口 保证apache配置文件httpd.conf里的LoadModule rewrite_module modules/mod_rewrite.so开启（去掉#） 将相对应目录的AllowOverride 改为ALL 在根目录下，即在index.php同级目录下新建.htaccess .htaccess文件内容如下RewriteEngine on# if a directory or a file exists, use it directlyRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-d# otherwise forward it to index.phpRewriteRule . index.php 开启缓存在main.php的组件components中配置设置缓存'cache' =&gt; array('class' =&gt; 'system.caching.CFileCache') 也就是framework/caching/CFileCache.php 片段缓存&lt;?php if($this-&gt;beginCache($id,array('duration'=&gt;1))): ?&gt; //缓存内容&lt;?php $this-&gt;endCache();endif ?&gt; duration 时间，以秒为单位 整页缓存public function filters()&#123; return array( array( 'system.web.widgets.COutputCache + index', 'duration' =&gt; 30, 'varyByParam'=&gt; array('aid') ) );&#125; 数据缓存$value = Yii::app()-&gt;cache-&gt;get($id)if($value == false)&#123; Yii::app()-&gt;cache-&gt;set($id, $value);&#125;","tags":[{"name":"Yii","slug":"yii","permalink":"https://jesse121.github.io/tags/yii/"}]},{"title":"移动端Web页面开发常用的头部标签设置","date":"2017-08-17T02:19:39.000Z","path":"articles/mobile/mobile-webpages-commonly-used-header-tags.html","text":"在移动端web页面开发中，我们常需要设置各种头部标签以帮助浏览器更好的解析页面，将页面完美呈现，这里列出了工作中常用的各种头部标签，以备查询。 viewport&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0\"&gt; initial-scale属性控制页面最初加载时的缩放等级。maximum-scale、minimum-scale及user-scalable属性控制允许用户以怎样的方式放大或缩小页面。 使用目的：阻止页面缩放 Safari 无效，其他均能阻止页面缩放safari可以使用以下方法window.onload = function() &#123; document.addEventListener('touchstart', function(event) &#123; if (event.touches.length &gt; 1) &#123;//多触点 event.preventDefault();//阻止默认缩放 &#125; &#125;) var lastTouchEnd = 0; document.addEventListener('touchend', function(event) &#123; var now = (new Date()).getTime(); if (now - lastTouchEnd &lt;= 300) &#123; event.preventDefault(); //阻止双击放大 &#125; lastTouchEnd = now; &#125;, false)&#125; ios meta &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/&gt; 启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏&lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt; 设置添加到主屏后的标题&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/&gt; 在web app应用下状态条（屏幕顶部条）的颜色，default（白色）black（黑色） black-translucent（灰色半透明）若值为”black-translucent”将会占据页面位置（会覆盖页面20px高度–iphone4和itouch4的Retina屏幕为40px）。&lt;meta name=\"format-detection\" content=\"telphone=no, email=no\"/&gt; 忽略页面中的数字识别为电话，忽略email识别 iOS 添加到主屏图标&lt;link rel=\"apple-touch-icon\" href=\"apple-touch-icon.png\"&gt; ios7以前系统默认会对图标添加特效（圆角及高光），如果不希望系统添加特效，则可以用apple-touch-icon-precomposed.png代替apple-touch-icon.png&lt;link rel=\"apple-touch-icon-precomposed\" href=\"apple-touch-icon-57x57-precomposed.png\"/&gt; iPhone 和 iTouch，默认 57x57 像素，必须有&lt;link rel=\"apple-touch-icon-precomposed\" href=\"apple-touch-icon-114x114-precomposed.png\"/&gt; Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 图标使用的优先级如下： 如果没有跟相应设备推荐尺寸一致的图标，会优先使用比推荐尺寸大，但最接近推荐尺寸的图标。 如果没有比推荐尺寸大的图标，会优先选择最接近推荐尺寸的图标。 iOS 启动画面iPhone&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 320px)\" href=\"apple-touch-startup-image-320x460.png\" /&gt; iPhone Retina&lt;link href=\"apple-touch-startup-image-640x920.png\" media=\"(device-width: 320px) and (-webkit-device-pixel-ratio: 2)\" rel=\"apple-touch-startup-image\" /&gt; iPhone 5&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)\" href=\"apple-touch-startup-image-640x1096.png\"&gt; iPad portrait&lt;link href=\"apple-touch-startup-image-768x1004.png\" media=\"(device-width: 768px) and (orientation: portrait)\" rel=\"apple-touch-startup-image\" /&gt; iPad landscape&lt;link href=\"apple-touch-startup-image-748x1024.png\" media=\"(device-width: 768px) and (orientation: landscape)\" rel=\"apple-touch-startup-image\" /&gt; iPad Retina portrait&lt;link href=\"apple-touch-startup-image-1536x2008.png\" media=\"(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)\" rel=\"apple-touch-startup-image\" /&gt; iPad Retina landscape&lt;link href=\"apple-touch-startup-image-1496x2048.png\"media=\"(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)\"rel=\"apple-touch-startup-image\" /&gt; 其他&lt;link rel=\"dns-prefetch\" href=\"//api.m.taobao.com\"&gt; DNS预解析&lt;link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/&gt; 添加 favicon icon&lt;meta name=\"renderer\" content=\"webkit\"&gt; 启用360浏览器的极速模式(webkit)&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; IE使用现有最高版本&lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /&gt; 不让百度转码&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt; QQ强制竖屏&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt; QQ强制全屏&lt;meta name=\"x5-page-mode\" content=\"app\"&gt; QQ应用模式&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt; UC强制竖屏&lt;meta name=\"full-screen\" content=\"yes\"&gt; UC强制全屏&lt;meta name=\"browsermode\" content=\"application\"&gt; UC应用模式 &lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; windows phone 点击无高光&lt;meta name=\"robots\" content=\"index,follow\"/&gt; 搜索引擎抓取说明：robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。具体参数如下：信息参数为all：文件将被检索，且页面上的链接可以被查询；信息参数为none：文件将不被检索，且页面上的链接不可以被查询；信息参数为index：文件将被检索；信息参数为follow：页面上的链接可以被查询；信息参数为noindex：文件将不被检索，但页面上的链接可以被查询；信息参数为nofollow：文件将被检索，但页面上的链接不可以被查询； 参考文章 HTML meta标签总结,HTML5 head meta属性整理Safari Web Content GuideSafari HTML Reference","tags":[{"name":"Mobile","slug":"mobile","permalink":"https://jesse121.github.io/tags/mobile/"}]},{"title":"常用的Git命令整理","date":"2017-08-07T22:39:30.000Z","path":"articles/tool/the-usual-git-command.html","text":"之前一直忙于项目苦于没有时间总结，今天刚好有时间特来总结一下在工作中常用到的代码版本管理器Git。至于为什么要用Git？Git相比SVN有哪些好处？我就不多说了,前人已经总结的很好。今天主要介绍的是常用的Git命令。 Git工作流一般来说，日常使用只要记住下图6个命令，就可以了。 Remote：远程仓库Repository：本地仓库Index/Stage：暂存区Workspace：工作区 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置$ git config –list 编辑Git配置文件$ git config -e [–global] 设置提交代码时的用户信息$ git config [–global] user.name “[name]”$ git config [–global] user.email “[email address]” 新建代码库在当前目录新建一个Git代码库$ git init 新建一个目录，将其初始化为Git代码库$ git init [project-name] 下载一个项目和它的整个代码历史$ git clone [url] 增加/删除文件添加指定文件到暂存区$ git add [file1] [file2] … 添加指定目录到暂存区，包括子目录$ git add [dir] 添加当前目录的所有文件到暂存区$ git add . 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] … 停止追踪指定文件，但该文件会保留在工作区$ git rm -r -–cached [file] 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交提交暂存区到仓库区$ git commit -m [message] 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] … -m [message] 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a 提交时显示所有diff信息$ git commit -v 使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit –amend -m [message] 重做上一次commit，并包括指定文件的新变化$ git commit –amend [file1] [file2] … 分支列出所有本地分支$ git branch 列出所有远程分支$ git branch -r 列出所有本地分支和远程分支$ git branch -a 新建一个分支，但依然停留在当前分支$ git branch [branch-name] 切换分支$ git checkout [branch] 新建一个分支，并切换到该分支$ git checkout -b [branch] 新建一个无根分支，并切换到该分支$ git checkout –orphan [branch] 新建一个分支，指向指定commit$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系$ git branch –track [branch] [remote-branch] 切换到指定分支，并更新工作区$ git checkout [branch-name] 建立追踪关系，在现有分支与指定的远程分支之间$ git branch –set-upstream [branch] [remote-branch] 合并指定分支到当前分支$ git merge [branch] 选择一个commit，合并进当前分支$ git cherry-pick [commit] 删除分支$ git branch -d [branch-name] 删除远程分支$ git branch -dr [remote/branch] 追加远程分支$ git remote add &lt;主机名&gt; &lt;网址&gt; 删除远程分支$ git remote rm &lt;主机名&gt; 标签列出所有tag$ git tag 新建一个tag在当前commit$ git tag [tag] 新建一个tag在指定commit$ git tag [tag] [commit] 删除本地tag$ git tag -d [tag] 删除远程tag$ git push origin :refs/tags/[tagName] 查看tag信息$ git show [tag] 提交指定tag$ git push [remote] [tag] 提交所有tag$ git push [remote] –tags 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息显示有变更的文件$ git status 显示当前分支的版本历史$ git log 显示commit历史，以及每次commit发生变更的文件$ git log –stat 显示某个文件的版本历史，包括文件改名$ git log –follow [file] 显示指定文件相关的每一次diff$ git log -p [file] 显示指定文件是什么人在什么时间修改过$ git blame [file] 显示暂存区和工作区的差异$ git diff 显示暂存区和上一个commit的差异$ git diff –cached [file] 显示工作区与当前分支最新commit之间的差异$ git diff HEAD 显示两次提交之间的差异$ git diff [first-branch]…[second-branch] 显示某次提交的元数据和内容变化$ git show [commit] 显示某次提交发生变化的文件$ git show –name-only [commit] 显示某次提交时，某个文件的内容$ git show [commit]:[filename] 显示当前分支的最近几次提交$ git reflog 远程同步下载远程仓库的所有变动$ git fetch [remote] 显示所有远程仓库$ git remote -v 显示某个远程仓库的信息$ git remote show [remote] 将本地仓库提交到远程仓库$git remote add origin [url] 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] 上传本地指定分支到远程仓库$ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] –force 推送所有分支到远程仓库$ git push [remote] –all 撤销恢复暂存区的指定文件到工作区$ git checkout [file] 恢复某个commit的指定文件到工作区$ git checkout [commit] [file] 恢复上一个commit的所有文件到工作区$ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致$ git reset –hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset –hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset –keep [commit] 新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 其他创建git忽略文件.gitignore$ vim .gitignore文件.gitignore 的格式规范如下： 所有空行或者以注释符号＃ 开头的行都会被Git 忽略。 可以使用正则表达式模式匹配。 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 生成一个可供发布的压缩包$ git archive Git使用流程总结 在当前目录新建一个Git代码库$ git init 添加当前目录的所有文件到暂存区$ git add . 每次提交前查看下当前文件状态$ git status 提交暂存区到仓库区$ git commit -m [message]当忘了输入messages时，可以使用esc + :wq + enter 创建远程仓库curl -u “$username:$token” https://api.github.com/user/repos -d ‘{“name”:”$repo_name”}’注意：这里需要把$username和$token分别换成实际的用户名和创建的personal access token ，把$repo_name换成任何想要的repo name。 为本地仓库添加远程仓库$ git remote add origin git@github.com:Jesse121/[remote].git 提交之前需获取远程仓库最新代码$ git pull origin master 上传本地指定分支到远程仓库$ git push origin master 将dist文件夹添加到gh-pages分支去展示$ git subtree push –prefix dist origin gh-pages 参考文章 SVN和Git介绍,区别,优缺点,适用范围总结常用 Git 命令清单","tags":[{"name":"Git","slug":"git","permalink":"https://jesse121.github.io/tags/git/"}]},{"title":"CSS中各种长度单位总结","date":"2017-07-27T23:48:54.000Z","path":"articles/html-css/summary-of-various-length-unit-in-css.html","text":"在前端开发工作过程中曾碰到这样一问题:&lt;style type=\"text/css\"&gt;.parent&#123; width:400px; height:300px; border:1px solid #ccc; &#125;.child&#123; margin:10%; background-color: red; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt; 问这类名为child元素在网页中显示的高宽？答案：width:320px;height:160px;如果您的答案正确，那说明您CSS功底比较强，如果您也不知所以然，希望这篇博文对您有所帮助 CSS中长度单位类型css中长度单位有很多，可谓五花八门，但可分为这两类： 绝对长度单位彼此固定，不会因为其他元素的尺寸变化而变化。主要有cm mm Q in pc pt px 相对长度单位指定相对于另一长度的长度。主要有em ex ch rem %和可视区百分比长度单位 vm vh vmin vmax 由于各种单位比较多，我们这里只介绍常用的一些单位,其他单位的详细情况可查询W3C规范 pxpx单位名称为像素，像素是固定大小的单元,用于屏幕媒体(即在电脑屏幕上读取)。一个像素等于电脑屏幕上的一个点 (是你屏幕分辨率的最小分割)。许多网页设计师在web文档使用像素单位以生产浏览器渲染的像素完美呈现的网站。 像素单位的一个问题是在IE下无法用浏览器字体缩放的功能(影响不是很大)。 %百分比是一个相对长度单位，相对于包含块（containing block）的高宽或字体大小。关于包含块（containing block）的概念，不能简单地理解成是父元素。如果是静态定位和相对定位，包含块一般就是其父元素。如果是绝对定位的元素，包含块应该是离它最近的 position为非static属性的祖先元素。如果是固定定位的元素，它的包含块是视口（viewport）。具体可以参考 W3Help。 在使用百分比单位的时候，最让人困惑的就是不清楚它到底是相对于谁计算的，下面将详细介绍列出 相对于包含块的宽度left、right、width、max-width、min-width、margin、padding、text-indent; 相对于包含块的高度top、 bottom、height、 max-height、 min-height; 相对于自身的高宽border-radius、background-size、transform: translate()、transform-origin、zoom(css3缩放)、clip-path 相对于自身的字体大小line-height 相对于自身的行高（不常用）vertical-align 相对于继承字体大小font-size 特殊对象 背景定位中的百分比 background-position 分别设置水平方向和垂直方向上的两个值，如果使用百分比，那么百分比值会同时应用于元素和图像。例如 50% 50% 会把图片的（50%, 50%）这一点与框的（50%, 50%）处对齐，相当于设置了 center center。同理 0% 0% 相当于 left top，100% 100% 相当于 right bottom。 filter(css3滤镜，不常用) filter: none | blur(%) | brightness(%) | contrast(%) | drop-shadow(%) | grayscale(%) | hue-rotate(%) | invert(%) | opacity(%) | saturate(%) | sepia(%) | url(%); 百分比的继承如果某个元素设置了百分比的属性，则后代元素继承的是计算后的值。例如：p &#123; font-size: 10px;line-height: 120%; &#125; 那么p的子元素继承到的值是 line-height: 12px，而不是 line-height: 120%。 emem是相对字体长度单位。如果用于font-size属性本身，则是相对于父元素的font-size。若用于其他属性（width,height），则是相对于本身元素的font-size。国外使用比较多； em单位有如下特点： em的值并不是固定的; em会继承父级元素的字体大小。 我们知道任意浏览器的默认字体大小都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。 em是继承父元素的字体大小，可是当父元素字体大小改变时，又得重新计算了，这不怎么方便，还好rem解决了这个问题 remrem是CSS3新增的一个相对字体长度单位，只相对根元素即html元素字体大小所以我们只要在html标签上设置字体大小为标准，文档中的字体大小都会以此为参照html&#123;font-size:62.5%; &#125;body&#123;font-size:12px;font-size:1.2rem ;&#125;p&#123;font-size:14px;font-size:1.4rem;&#125; 兼容性： IE 9 &amp; IE 10 do not support rem units when used in the font shorthand property (the entire declaration is ignored) or when used on pseudo elements. IE9/10中font缩写和伪元素中不支持rem单位IE9/10部分支持，IE11+、Firefox、Chrome、Safari、Opera 的主流版本都支持，为了兼容不支持 rem 的浏览器，我们需要在 rem 前面写上对应的 px 值，这样不支持的浏览器可以优雅降级。 vm vh vmin vmax响应式布局的实现依靠媒体查询（ Media Queries ）来实现，选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配。CSS3中引入一种新的办法去真正地适配所有设备尺寸。 视口单位视口在桌面端，指的是浏览器的可视区域；而在移动端较为复杂，它涉及到三个视口：分别是 Layout Viewport（布局视口）、 Visual Viewport（视觉视口）、Ideal Viewport。视口单位中的“视口”，在桌面端，毫无疑问指的就是浏览器的可视区域；但是在移动端，它指的则是Layout Viewport（布局视口） 。 根据CSS3规范，视口单位主要包括以下4个： vw : 1vw 等于视口宽度的1% vh : 1vh 等于视口高度的1% vmin : 选取 vw 和 vh 中最小的那个 vmax : 选取 vw 和 vh 中最大的那个 兼容性在PC端用的很少，主要在移动端在移动端 ios 8 以上以及 Android 4.4 以上获得支持，并且在微信 x5 内核中也得到完美的全面支持。 搭配vw和rem，布局更优化 给根元素大小设置随着视口变化而变化的 vw 单位，这样就可以实现动态改变其大小。 限制根元素字体大小的最大最小值，配合 body 加上最大宽度和最小宽度 个人总结在一般的PC端网页制作过程中，一般直接用px为单位，在移动端由于vw,vh单位的兼容性，目前一般采用rem + %或者rem + vw/vh。 参考文章 CSS Values and Units Module Level 3KB008: 包含块( Containing block )css样式的百分比都相对于谁？CSS参考手册纯CSS3使用vw和vh视口单位实现自适应","tags":[{"name":"CSS","slug":"css","permalink":"https://jesse121.github.io/tags/css/"}]},{"title":"innerHTML,innerText,textContent的区别详解","date":"2017-07-18T13:07:06.000Z","path":"articles/javascript/the-different-between-innerHTML-innerText-and-textContent.html","text":"用惯了jQuery的html()方法，突然有一天不用jQuery的时候发现自己懵逼了，只知道有innerHTML,innerText,textContent这三种属性可以改变DOM元素的内容，可是他们具体的区别及适用场合在头脑中却不够清晰。本着一查到底的精神，今天就来膜拜一下这三个属性的各自成名绝技。本文将从以下几个方面来介绍： 规范解读 属性的异同 各自适用场合 规范解读innerHTMLelement.innerHTMLReturns a fragment of HTML or XML that represents the element's contents.//取值操作，返回内容包含描述所有后代元素的序列化HTML代码。 element.innerHTML = value Can be set, to replace the contents of the element with nodes parsed from the given string.//赋值操作，用解析后的字符串替换元素的内容 innerTextelement.innerTextReturns the element's text content \"as rendered\".//取值操作，返回元素“渲染”后的文本内容element.innerText = value Can be set, to replace the element's children with the given value, but with line breaks converted to br elements.//赋值操作，用所给的值替换该元素的子元素，其中换行符会被替换为`&lt;br&gt;`元素 textContentelement.textContentreturns the text content of this node and its descendants. //取值操作，返回一个节点元素及其后代的文本内容element.textContent = valueOn setting, any possible children this node may have are removed and, if it the new string is not empty or null, replaced by a single Text node containing the string this attribute is set to. //赋值操作，用所给的值以字符串文本的形式替换该元素的子元素 属性的异同是不是对上面的规范的介绍一知半解？没关系，接下来将从取值操作和赋值操作的角度用实例来说明他们之间的差异&lt;style type=\"text/css\"&gt; #demo&#123;color:red;text-transform: uppercase;&#125;&lt;/style&gt;&lt;div id=\"demo\"&gt; This is &amp;&lt;&gt; '' \"\" &lt;br&gt; &lt;span&gt;some&lt;/span&gt; demo&lt;/div&gt;&lt;h2&gt;innerHTML&lt;/h2&gt;&lt;div id=\"asHTML\"&gt;&lt;/div&gt;&lt;h2&gt;innerText&lt;/h2&gt;&lt;div id=\"asText\"&gt;&lt;/div&gt;&lt;h2&gt;textContent&lt;/h2&gt;&lt;div id=\"asContent\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var get = document.getElementById('demo'); var string = \"&lt;a href='http://www.baidu.com'&gt; &amp;amp; www.baidu.com &lt;span&gt;child&lt;/span&gt; &lt;/a&gt;\"; var HTML = document.getElementById('asHTML'); console.log(get.innerHTML); HTML.innerHTML = string; var Text = document.getElementById('asText'); console.log(demo.innerText); Text.innerText = string; var content = document.getElementById('asContent'); console.log(demo.textContent); content.textContent = string;&lt;/script&gt; 取值操作返回结果innerHTMLThis is &amp;amp; &amp;lt;&amp;gt; '' \"\"&lt;br&gt;&lt;span&gt;some&lt;/span&gt;demo 返回经过序列化算法之后的html代码，其中 &amp; &lt; &gt;等特殊符号被转义,子元素原样输出innerTextTHIS IS &amp; &lt; &gt; '' \"\" SOME DEMO 返回被部分CSS渲染后的结果，多余的空格被合并textContentThis is &amp; &lt;&gt; '' \"\"somedemo 返回元素及其后代元素的文本内容，特殊字符不被转义 赋值操作返回结果innerHTML&amp; www.baidu.com child 后代元素html标签被解析,实体字符被解析innerText&lt;a href='http://www.baidu.com'&gt; &amp;amp; www.baidu.com &lt;span&gt;child&lt;/span&gt; &lt;/a&gt; textContent&lt;a href='http://www.baidu.com'&gt; &amp;amp; www.baidu.com &lt;span&gt;child&lt;/span&gt; &lt;/a&gt; 差异浏览器兼容性从Caniuse网站上查询结果来看：innerHTML IE8/9部分支持 IE10+ chrome45+在IE8/9中，innerHTML对以下元素是只读的：col, colgroup, frameset, html, head, style, table, tbody, tfoot, thead, title, and tr.innerText IE6+ chrome45+textContent IE9+ chrome45+ textContent与innerText的区别 textContent 会获取所有元素的内容，包括 &lt;script&gt; 和 &lt;style&gt; 元素，然而 innerText 不会。innerText意识到样式，并且不会返回隐藏元素的文本，而textContent会。由于 innerText 受 CSS 样式的影响，它会触发重排（reflow），但textContent 不会。在 Internet Explorer (对于小于等于 IE11 的版本) 中对 innerText 进行修改， 不仅会移除当前元素的子节点，而且还会永久性地破坏所有后代文本节点（所以不可能再次将节点再次插入到任何其他元素或同一元素中）。 textContent与innerHTML的区别 正如其名称，innerHTML 返回 HTML 文本。通常，为了在元素中检索或写入文本，人们使用innerHTML。但是，textContent通常具有更好的性能，因为文本不会被解析为HTML。此外，使用textContent可以防止 XSS 攻击。 相同点都可用于设置DOM元素的内容 适用场合在取值操作中如果取出DOM元素的后代元素及其内容的html代码，一般使用innerHTML如果需要考虑DOM元素内容的样式，一般使用innerText如果只想取得DOM元素及其后代元素的文本内容，一般使用textContent，在低版本的IE中可使用innerText在赋值操作中如果是需要赋值安全的html片段，一般使用innerHTML如果是需要赋值纯文本，一般使用textContent，在低版本的IE中可使用innerText 参考文章： 被玩坏的innerHTML、innerText、textContent和value属性 Node.textContent","tags":[{"name":"HTML","slug":"html","permalink":"https://jesse121.github.io/tags/html/"}]},{"title":"对JavaScript中this的理解","date":"2017-07-07T23:15:23.000Z","path":"articles/javascript/对JavaScript中this的理解.html","text":"在javascript中我们总是会遇到各种各样的this，由于this是在代码运行期确定的，它可以是全局对象、当前对象或者任意对象，这完全取决于this的调用方式。《javascript语言精粹》一书中将this的调用方式总结为以下四种： 作为对象方法调用 作为函数调用 作为构造函数调用 apply或call 调用 在补充2点： ES5中引入的bind调用 ES6中箭头函数里的this 下面我们将按照调用方式的不同，分别讨论 this 的含义。 作为对象方法调用当一个函数被保存为对象的一个属性时，我们称它为一个方法。方法被调用时,this被绑定到该对象。通过this可取得所属对象的公有方法var myObject = &#123; value:0, increment:function(inc)&#123; this.value += typeof inc === 'number' ? inc : 1; console.log(this); //&#123;value:1,increment:function()&#123;&#125;&#125; &#125;&#125;myObject.increment(); //作为对象方法调用 作为函数调用当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的，以此模式调用函数时，this被绑定到全局对象。var myObject = &#123; value : 0, double : function()&#123; var helper = function()&#123; console.log(this); //window &#125;; helper(); //作为函数调用 &#125;&#125; 作为构造函数调用如果一个函数前面带上new来调用，那么背地里将会创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到那个新对象上。function Quo(string)&#123; this.status = string;&#125;Quo.prototype.getStatus = function()&#123; return this;&#125;var myQuo = new Quo(\"confused\");console.log(myQuo.getStatus()); //作为构造函数调用 this指向这个新对象Quo &#123;status: \"confused\"&#125; apply或call 调用apply方法允许我们构建一个函数数组传递给调用函数，也允许选择this的值var statusObject = &#123; status: \"ok\"&#125;;function Quo(string)&#123; this.status = string;&#125;Quo.prototype.getStatus = function()&#123; return console.log(this); //&#123;status: \"ok\"&#125;&#125;Quo.prototype.getStatus.apply(statusObject); //将方法中的this指向传入的对象Quo.prototype.getStatus.call(statusObject); //将方法中的this指向传入的对象 通过bind调用bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。fun.bind(thisArg[, arg1[, arg2[, ...]]]) 返回由指定的this值和初始化参数改造的原函数拷贝window.color = \"red\";var o = &#123;color:\"blue\"&#125;;function sayColor()&#123; return this.color;&#125;var objectSayColor = sayColor.bind(o); //此处将方法中的this指向了o对象objectSayColor();//由于bind返回的是改造后的原函数的拷贝，并没有执行 箭头函数里的this函数体内的 this 对象，是定义时所在的对象，而不是使用时所在的对象。var handler = &#123; id: '123456', init: function() &#123; document.addEventListener('click',event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125;; 上面代码的 init 方法中，使用了箭头函数，这导致这个箭头函数里面的 this ，总是指向 handler 对象。否则，回调函数运行时， this.doSomething 这一行会报错，因为此时 this 指向 document 对象。this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this ，导致内部的 this 就是外层代码块的 this 。正是因为它没有 this ，所以也就不能用作构造函数。","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"搭建自己的Webpack前端构建工具","date":"2017-06-19T16:00:00.000Z","path":"articles/tool/set-up-my-front-end-build-tool-webpack.html","text":"前端开发技术的更新速度可谓是越来越快，前段时间还在用Gulp打包工具，转眼间Webpack就要一统江湖了。为了体验一下webpack新技术带来的好处，于是就用webpack搭建了一款适合自己使用的前端脚手架，主要用于提高开发速度。在前端开发中切记不要因为某种新技术很火就盲目跟风的在实际项目中使用，而是要根据项目自身特点来选择工具。网上关于webpack工具的使用教程也是非常多，写下此篇博客的目的是记录下自己的搭建过程，熟悉webpack工具打包流程并用于交流。目前配置的是适用于多个项目的单页应用。其中React-app是用于快速构建基于webpack打包的React项目，暂不做介绍。工具的基本功能： 能转化ES6代码，能分离打包并压缩js文件 支持sass预编译，能分离打包并压缩css文件 支持图片压缩 支持HTML模板，并压缩输出 开发过程中开启静态服务器并启动热更新，实时调试 环境搭建初始化默认已安装node新建项目文件夹及package.json文件mkdir webpackcd webpacknpm init 一路回车，按需填写即可。 全局安装这里为了构建多项目并行开发需要全局安装webpack和webpack-dev-servernpm i -g webpack@2.2.1 webpack-dev-server@2.5.0 安装依赖包这里都指定了安装版本，在配置的时候就不会因为依赖包的升级而导致不能用npm i --save-dev autoprefixer@7.1.1 babel-core@6.25.0 babel-loader@7.1.0 babel-preset-env@1.5.2 css-loader@0.28.4 extract-text-webpack-plugin@2.1.2 file-loader@0.11.2 html-webpack-plugin@2.29.0 node-sass@4.5.3 postcss-loader@2.0.6 style-loader@0.18.2 webpack@2.2.1 webpack-dev-server@2.5.0 新建配置文件新建项目文件夹及webpack.config.js文件mkdir Democd Demo webpack.config.jsconst path = require(\"path\");const webpack = require('webpack');//html模板插件 详见https://www.npmjs.com/package/html-webpack-pluginconst htmlWebpackPlugin = require('html-webpack-plugin');//代码分离插件 详见https://www.npmjs.com/package/extract-text-webpack-pluginconst ExtractTextPlugin = require(\"extract-text-webpack-plugin\");module.exports = &#123; //错误定位 devtool: '#cheap-eval-source-map', //程序入口文件 其他详细配置参见http://webpack.github.io/docs/configuration.html#entry entry: __dirname + '/src/js/main.js', //程序出口文件 其他详细配置参见http://webpack.github.io/docs/configuration.html#output output: &#123; path: path.join(__dirname, \"dist\"), filename: 'js/bundle-[hash:5].js', // 用户添加CDN // publicPath:'http://cdn.com/' &#125;, // webpack-dev-server配置 详见https://webpack.js.org/configuration/dev-server/ devServer: &#123; //设置服务器主文件夹，默认情况下，从项目的根目录提供文件 contentBase: path.join(__dirname, \"dist\"), //使用inlilne模式 inline: true, //当编译错误的时候，网页上显示错误信息 overlay: &#123; warnings: true, errors: true &#125;, //设置域名，默认是localhost // host: \"10.74.138.249\", // port: 3000 &#125;, module: &#123; rules: [&#123; test: /\\.(js|jsx)$/, include: [ path.join(__dirname, \"src\") ], loader: 'babel-loader', query: &#123; presets: ['env'] &#125; &#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ &#123; loader: 'css-loader', options: &#123; minimize: true //css压缩 &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; plugins: function () &#123; return [require('autoprefixer')] &#125; &#125; &#125; ] &#125;) &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpe?g|gif)$/i, use: [&#123; loader: 'file-loader', query: &#123; limit: 10000, name: './img/[name]-[hash:5].[ext]' &#125; &#125;] &#125;] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), // webpack.optimize.CommonsChunkPlugin(), new htmlWebpackPlugin(&#123; template: 'src/index.html', inject: 'body', minify: &#123; removeComments: true, collapseWhitespace: true &#125; &#125;), new ExtractTextPlugin('css/common.css') ]&#125; 目录结构|--Demo| |--dist/| |--src| |--css/| |--js/| |--index.html| |--webpack.config.js|--React-app/ //react项目暂不做介绍|--package.json 如何使用以上这些内容只是对webpack脚手架工具的构建过程的基本介绍，当然如果你想使用的话也可以直接下载使用//下载webpack脚手架工具git clone git@github.com:Jess121/Webpack.git//安装依赖 在此之前需要全局安转webpack和webpack-dev-servernpm i -g webpack@2.2.1 webpack-dev-server@2.5.0 npm install//启动项目，输入以下命令会自动打浏览器并访问localhost:8080(而配置中未修改host和port)webpack-dev-server --open//打包项目，并展示打包进度webpack --progress PS: 以上展示的是脚手架工具的基本功能，其他功能结合项目需要后期在做补充","tags":[{"name":"Webpack","slug":"webpack","permalink":"https://jesse121.github.io/tags/webpack/"}]},{"title":"《高性能网站建设进阶指南》--读书笔记","date":"2017-06-04T16:00:00.000Z","path":"articles/notes/performance-best-practices-for-web-developer.html","text":"最近在关注如何提升网站性能方面的内容，连续看了《高性能网站建设指南》和《高性能网站建设进阶指南》。看完后的觉得收获颇丰，书中提出了很多在提升网站性能方面应注意的事项和所运用的技术，尽管有些内容很老旧，但是仍有部分内容在工作中还是发挥出巨大的效果的。书中有些部分添加了自己的见解，如有错误之处还望提出。 第一章、理解Ajax性能1.2 优化原则优化的目的是降低程序的整体开销，我们应该把重点放在对程序整体开销影响最大的那部分 第二章、创建快速响应的WEB应用2.1 怎样才算足够快 Javascript代码执行时间超过0.1秒，页面将会给人不够平滑的感觉 超过1秒，用户会感到程序缓慢 超过10秒，用户非常沮丧 2.2 测量延迟时间手动代码检测利用new Date()var start = new Date().getMilliseconds();//这里是你需要检测的javascript代码var end = new Date().getMilliseconds();console.log(\"your javascript code executed in \"+ (end - start) +\" milliseconds\"); 利用console.time()//这两个方法中都可以传入一个参数，作为计时器的名称，它的作用是在代码并行运行时分清楚各个计时器。//对console.timeEnd的调用会立即输出执行总共消耗的时间，单位是毫秒。console.time('计时器');//这里是你需要检测的javascript代码console.timeEnd('计时器'); Performance API网页性能检测var performance = &#123; // memory 是非标准属性，只在 Chrome 有 // 财富问题：我有多少内存 memory: &#123; usedJSHeapSize: 16100000, // JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize totalJSHeapSize: 35100000, // 可使用的内存 jsHeapSizeLimit: 793000000 // 内存大小限制 &#125;, // 哲学问题：我从哪里来？ navigation: &#123; redirectCount: 0, // 如果有重定向的话，页面通过几次重定向跳转而来 type: 0 // 0 即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等） // 1 即 TYPE_RELOAD 通过 window.location.reload() 刷新的页面 // 2 即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录） // 255 即 TYPE_UNDEFINED 非以上方式进入的页面 &#125;, timing: &#123; // 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳， // 如果无前一个网页 unload ，则与 fetchStart 值相等 navigationStart: 1441112691935, // 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0 unloadEventStart: 0, // 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳 unloadEventEnd: 0, // 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 redirectStart: 0, // 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0 redirectEnd: 0, // 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前 fetchStart: 1441112692155, // DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 domainLookupStart: 1441112692155, // DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 domainLookupEnd: 1441112692155, // HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等 // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间 connectStart: 1441112692155, // HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等 // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间 // 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过 connectEnd: 1441112692155, // HTTPS 连接开始的时间，如果不是安全连接，则值为 0 secureConnectionStart: 0, // HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存 // 连接错误重连时，这里显示的也是新建立连接的时间 requestStart: 1441112692158, // HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存 responseStart: 1441112692686, // HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存 responseEnd: 1441112692687, // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件 domLoading: 1441112692690, // 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件 // 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源 domInteractive: 1441112693093, // DOM 解析完成后，网页内资源加载开始的时间 // 在 DOMContentLoaded 事件抛出前发生 domContentLoadedEventStart: 1441112693093, // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕） domContentLoadedEventEnd: 1441112693101, // DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件 domComplete: 1441112693214, // load 事件发送给文档，也即 load 回调函数开始执行的时间 // 注意如果没有绑定 load 事件，值为 0 loadEventStart: 1441112693214, // load 事件的回调函数执行完毕的时间 loadEventEnd: 1441112693215 &#125;&#125; performance.now方法返回当前网页自从performance.timing.navigationStart到当前时间之间的微秒数（毫秒的千分之一）。也就是说，它的精度可以达到100万分之一秒。并且与 Date.now() 会受系统程序执行阻塞的影响不同，performance.now() 的时间是以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整）。注意 Date.now() 输出的是 UNIX 时间，即距离 1970 的时间，而 performance.now() 输出的是相对于 performance.timing.navigationStart(页面初始化) 的时间。使用 Date.now() 的差值并非绝对精确，因为计算时间时受系统限制（可能阻塞）。但使用 performance.now() 的差值，并不影响我们计算程序执行的精确时间。var start = performance.now();//这里是你需要检测的javascript代码var end = performance.now();console.log(\"your javascript code executed in \"+ (end - start) +\" microseconds\"); 检测网页更多其他性能可用以下方法// 计算加载时间function getPerformanceTiming() &#123; var performance = window.performance; if (!performance) &#123; // 当前浏览器不支持 console.log('你的浏览器不支持 performance 接口'); return; &#125; var t = performance.timing; var times = &#123;&#125;; //【重要】重定向的时间 //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com times.Redirect = t.redirectEnd - t.redirectStart; // DNS 缓存时间 times.Appcache = t.domainLookupStart - t.fetchStart; //【重要】DNS 查询时间 //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？ times.DNS = t.domainLookupEnd - t.domainLookupStart; // TCP 建立连接完成握手的时间 times.TCP = t.connectEnd - t.connectStart; //【重要】读取页面第一个字节的时间 //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？ // TTFB 即 Time To First Byte 的意思 times.ttfb = t.responseStart - t.navigationStart; //【重要】内容加载完成的时间 //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？ times.loadResources = t.responseEnd - t.requestStart; //【重要】解析 DOM 树结构的时间 //【原因】反省下你的 DOM 树嵌套是不是太多了！ times.domReady = t.domComplete - t.responseEnd; //t.domLoading //【重要】执行 onload 回调函数的时间 //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？ times.loadEvent = t.loadEventEnd - t.loadEventStart; //【重要】页面加载完成的时间 //【原因】这几乎代表了用户等待页面可用的时间 times.loadPage = t.loadEventEnd - t.navigationStart; // 前一个网页卸载页面的时间 times.unloadEvent = t.unloadEventEnd - t.unloadEventStart; return times;&#125; 2.3 线程处理为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。可以使用Web worker将开销很大的代码从与用户交互的线程中剥离webworker简单示例：//main.jsif (window.Worker) &#123; console.log(\"Yes! Web worker support!\"); // Some code.....&#125; else &#123; console.log(\"Sorry! No Web Worker support..\");&#125;var worker = new Worker(\"worker.js\");//子线程新建之后，并没有启动，必需等待主线程调用postMessage方法，即发出信号之后才会启动。worker.postMessage(\"hello world!\");worker.onmessage = function(e) &#123; console.log(e.data);//'You said: hello world! //终止worker worker.terminate();&#125;;worker.onerror = function(e) &#123; console.log('Error:' + e);&#125;;//worker.jsself.onmessage = function (e) &#123; self.postMessage('You said: ' + e.data);&#125;; 2.4 内存管理Javascript使用的是自动垃圾回收机制，随着应用程序内存占用的增加，遍历整个堆区查找不再使用的对象所需要的时间将增长并最终引起用户的注意一旦确定内存有问题，应该手动解除引用优化内存： 将不再需要的对象赋值为null 从网页的DOM树上移除不再是必需的节点 第4章、无阻赛加载脚本defer &amp; asyncHTML5为script引入的新属性用于改变脚本的执行方式，只适用于外部脚本文件。这些属性告知浏览器引入进来的脚本文件不会影响DOM结构，可以在下载脚本的同时继续解析和渲染文档，都会在window.onload事件之前执行。区别： defer 异步下载，下载完成后等到页面中其他外链js文件执行完毕，在DOMContentLoaded Event事件之前执行 async 异步下载，下载完后立即执行，不能保证脚本执行顺序 兼容性： defer: IE8+ chrome45+ firefox52+ async：IE11+ chrome45+ firefox52+同时支持两者的浏览器会遵从async而忽略defer Script DOM elementvar scriptElem = document.createElement('script');scriptElem.src = \"2.js\";document.getElementsByTagName('head')[0].appendChild(scriptElem); 动态脚本插入DOM后开始发出请求外部js文件，在DOMContentLoaded事件之后执行 XMLHttpRequest该方法不能跨域，不推荐使用var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; var scriptElem = document.createElement(\"script\"); document.getElementsByTagName(\"head\")[0].appendChild(scriptElem); scriptElem.text = xhr.responseText; &#125;&#125;;xhr.open(\"GET\", \"A.js\", true);xhr.send(\"\"); 第5章、整合异步脚本代码异步执行可能会出现竞争状态从而导致出现未定义标识符错误，当异步加载的外部脚本与行内脚本之间存在代码依赖时，我们必须通过一种保证执行顺序的方法来整合这两个脚本 script Onloadvar scriptElem = document.createElement('script');scriptElem.src = \"js/jquery-1.11.0.js\";scriptElem.onloadDone = false;scriptElem.onload = function() &#123; scriptElem.onloadDone = true; init();&#125;;//兼容IE8scriptElem.onreadystatechange = function() &#123; if ((\"loaded\" === scriptElem.readyState || \"complete\" === scriptElem.readyState) &amp;&amp; !scriptElem.onloadDone) &#123; scriptElem.onloadDone = true; init(); &#125;&#125;;document.getElementsByTagName('head')[0].appendChild(scriptElem);function init() &#123; console.log($);&#125; Script Onload是整合单个异步加载外部脚本和行内脚本的首选 多个外部脚本function loadDomScript(url, callback) &#123; var domscript = document.createElement('script'); domscript.src = url; if (callback) &#123; domscript.onloadDone = false; domscript.onload = function() &#123; domscript.onloadDone = true; callback(); &#125;; //IE8 domscript.onreadystatechange = function() &#123; if ((\"loaded\" === domscript.readyState || \"complete\" === domscript.readyState) &amp;&amp; !domscript.onloadDone) &#123; domscript.onloadDone = true; callback(); &#125; &#125;; &#125; document.getElementsByTagName('head')[0].appendChild(domscript);&#125;loadDomScript(\"https://cdn.bootcss.com/underscore.js/1.8.3/underscore-min.js\");loadDomScript(\"http://apps.bdimg.com/libs/jquery/1.11.3/jquery.min.js\", init);function init() &#123; console.log(_); console.log($);&#125; 多个外部脚本暂无更好的方法 第6章、布置行内脚本异步执行行内脚本function asyncJs()&#123; //your javascript code&#125;setTimeout(async,0); setTimeout(async,0)作用是让async在现有的任务（脚本的同步任务和“任务队列”中已有的事件）一结束就立刻执行。 第9章、超越Gzip压缩Gzip失效原因web代理和PC安全软件 对Gzip的支持进行直接探测第11章、划分主域当从单个域下载资源成为瓶颈时，可将资源分配到多个域上，通过增加并行的下载数来提高页面速度对那些想把资源分配到多个域的人来说，他们不必额外部署服务器，只需建立一条CNAME记录，CNAME仅仅是域名的一个别名。","tags":[{"name":"WEB","slug":"web","permalink":"https://jesse121.github.io/tags/web/"}]},{"title":"《高性能网站建设指南》--读书笔记","date":"2017-05-27T16:00:00.000Z","path":"articles/notes/high-performace-web-sites.html","text":"在前端开发中如何提升网站性能是每个前端工程师必须所考虑的内容。通过阅读《高性能网站建设指南》加深了对提升网站性能的各种方法的认识，同时在今后的开发中也能更好的运用。 规则一、减少HTTP请求 CSS Sprites合并图片，减少HTTP请求 内联图片。 使用Data URL技术，图片数据以base64字符串格式嵌入到了页面中，减少了HTTP请求。 使用场景： 当图片很小时，可用dataURL，这样既可以避免HTTP请求，同时数据量也不大 当图片是服务器生成且每个用户都不一样的时候，例如验证码 dataURL用在css文件中可避免单纯的dataURL图片不被浏览器缓存这个缺点 缺点： Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。 Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次，不适合在网站中大量使用。 合并脚本和样式表，尽量减少js和css的请求数量 规则二、使用内容发布网络内容发布网络（CDN）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。常用的CDN有： baidu cdnjs Bootstrap 规则三、添加Expires页面中都包含大量的组件，通过web服务器使用一个长久的expires头，使得这些组件可以被缓存，这样在后续页面中避免不必要的HTTP请求缺点：要求服务器和客户端的时间严格同步，过期日期需要检查，并提供新日期HTTP1.1引入Cache-Control头来克服Expires头的限制cache-control使用max-age指令max-age请求的内容过多久过期（相对于请求时间Date）失效，默认以秒为单位具体的过期时间配置可在Apache配置文件中添加mod_expires.c配置信息。&lt;IfModule mod_expires.c&gt; ExpiresActive On ExpiresByType text/css \"now plus 1 month\" ExpiresByType application/x-javascript \"now plus 5 day\" ExpiresByType image/jpeg \"access plus 1 month\" ExpiresByType image/gif \"access plus 1 month\" ExpiresByType image/bmp \"access plus 1 month\" ExpiresByType image/x-icon \"access plus 1 month\" ExpiresByType image/png \"access plus 1 minutes\" ExpiresByType application/x-shockwave-flash \"access plus 1 month\" ExpiresDefault \"now plus 1 minutes\"&lt;/IfModule&gt; 配置信息可参考Apache Module mod_expires 规则四、压缩组件通过开启gzip压缩来减小HTTP响应数据包的大小值得压缩的内容有HTML xml css js json不该压缩的内容图片 pdf，他们在上传到服务器的时候一般就已压缩好，再压缩只会浪费CPU通过配置Apache 2.x的mod_deflate模块&lt;IfModule mod_deflate.c&gt; DeflateCompressionLevel 6 SetOutputFilter DEFLATE SetEnvIfNoCase Request_URI .(?:gif|jpe?g|png)$ no-gzip dont-vary SetEnvIfNoCase Request_URI .(?:exe|t?gz|zip|bz2|sit|rar)$ no-gzip dont-vary SetEnvIfNoCase Request_URI .(?:pdf|doc)$ no-gzip dont-vary AddOutputFilterByType DEFLATE text/html text/plain text/xml text/css application/x-javascript application/json &lt;IfModule mod_setenvif.c&gt; BrowserMatch ^Mozilla/4 gzip-only-text/html BrowserMatch ^Mozilla/4.0[678] no-gzip BrowserMatch \\bMSIE !no-gzip !gzip-only-text/html &lt;/IfModule&gt;&lt;/IfModule&gt; 配置信息可参考Apache Module mod_deflate 规则五、将样式表放在顶部将样式表放在head标签里可以避免白屏，这样浏览器能更快的展现内容，用户体验更好而将样式表放在底部会导致浏览器阻止内容逐步呈现，为避免当样式变化时重绘页面，浏览器会延迟显示页面中的元素 规则六、将脚本放在底部在下载脚本时浏览器会阻塞并行下载，原因： 脚本可能会修改页面内容，因此浏览器会等待 需要保证脚本能够按照正确的顺序执行 将脚本放到页面底部，这不会阻止页面内容呈现而且页面中的可视组件能尽早下载 规则七、避免CSS表达式表达式的问题在于对其进行的求值的频率比人们期望的要高，它们不只在页面呈现和大小改变时求值，当页面滚动、甚至用户鼠标在页面上移过时都要被求值。频繁地求值计算会导致性能底下解决方法： 避免使用css表达式 若必须使用css表达式，可使用一次性表达式{background-color:expression(altBgcolor(this));} 使用事件处理器 规则八、使用外部的JS和CSS好处： 外部js和css文件有机会被浏览器缓存起来 外部文件可以提高页面组件的重用率 规则九、减少DNS查找方法： 通过使用Keep-Alive，重用现有连接避免重复DNS查找 使用较少的域名可以减少DNS查找的数量（页面性能需要在减少DNS查找和并行下载之间权衡） 规则十、精简JavaScript和CSS通过精简从代码中移除不必要的字符，注释，空白符等，从而达到减小请求文件大小的目的在实际开发中一般将js和css通过工具压缩为min文件 规则十一、避免重定向常见的重定向状态码有： 301 Moved Permancently 302 Moved Temporarily(Found) 304 Not Modified 并不是真正的重定向，避免下载已经存在的缓存 重定向会延长从发出请求到请求资源被下载的这段时间有一种重定向最浪费也发生的很频繁 缺少结尾的斜线当缺少结尾的斜线时它允许自动索引(自动转到默认的index.html)并且能够获得与当前目录相关的URL避免重定向方法 通过这事Alias mod_rewrite等 如果域名变了可以使用CNAME记录 规则十二、移除重复脚本重复脚本损伤性能的两种方式 带来不必要的HTTP请求 执行脚本所浪费的时间 规则十三、配置或移除EtagEtag是web服务器和浏览器用于确认缓存组件的有效性的一种机制服务器在检测缓存的组件是否和原始服务器上的组件匹配时有两种方式： 比较最新修改时间 比较实体标签 最新修改日期原始服务器通过Last-Modified响应头来返回组件的最新修改日期当组件第一次被请求成功后浏览器缓存了该组件以及它的最新修改日期（允许缓存），当再次请求该组件时，浏览器会使用If-Modified-Since头将最新修改时间和原始服务器上该组件的最新修改时间进行比较，如果相同则返回一个304，而不传输数据，浏览器将使用缓存数据。 实体标签ETag是唯一标识了一个组件的一个特性版本的字符串ETag:&quot;24-54c6a9bd53bd1&quot;当组件第一次被请求成功后浏览器缓存了该组件以及它的最新修改日期（允许缓存）还有ETag信息，当再次请求该组件时，浏览器会使用If-None-Match头将ETag和原始服务器上该组件的ETag进行比较，如果相同则返回一个304，而不传输数据，浏览器将使用缓存数据。 ETag带来的问题当你使用服务器集群时，相同的组件从一台服务器带另一台服务器，Aapache和IIS产生的ETag是不同的，这样组件下载次数将增加，导致性能下降当If-None-Match比If-Modified-Since共存时，只有If-Modified-Since和If-None-Match在完全匹配时，服务器才能返回304。否则由于If-None-Match比If-Modified-Since具有更高的优先级,ETag不同，服务器就会返回200 解决办法 配置ETag FileEtag INode Mtime Size INode:文件的索引节点(inode)数 MTime:文件的最后修改日期及时间 Size:文件的字节数 All:所有存在的域，等价于：FileETag INode MTime Size None:移除ETag 有网友建议只是用MTime和Size就好了，有待验证 移除ETag 在Aapache配置文件按中添加FileETag none 规则十四、使用Ajax可缓存如果使用ajax向服务器发起大量的GET请求则可以为其请求的资源设置长久的expires头","tags":[{"name":"WEB","slug":"web","permalink":"https://jesse121.github.io/tags/web/"}]},{"title":"常见的前端漏洞及防御措施","date":"2017-05-22T16:00:00.000Z","path":"articles/web/常见的前端漏洞及防御措施.html","text":"随着WEB应用越来越复杂，用户对WEB安全也越来越重视。再加上前端工程师的工作面已逐渐扩大，开始覆盖到各种业务逻辑，因此如何应对各种WEB安全问题就显得十分重要，今天我们就来探讨下前端开发编码工作中可能造成的WEB安全问题及防御措施 a链接target=”_blank”属性可造成钓鱼攻击简介如果你在页面上的超链接a标记上添加了target=&#39;_blank&#39;属性，当用户点击了该超链接后，浏览器会单独新建一个标签页来显示该链接所指向的内容。但是在这一瞬间，浏览器会允许新建的标签页通过一个名为”window.opener”的浏览器API来与之前的网页进行短暂通信。此时，攻击者就可以将恶意代码嵌入在新打开的网站中，然后检测用户是从哪一个网站跳转过来的，最后再利用window.opener接口来迫使原始网页打开一个新的URL地址。 攻击实例你的正常登陆的网页&lt;!-- test1.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"./test2.html\" target=\"_blank\"&gt;你想去的地方&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 点击超链接，打开test2.html&lt;!-- test2.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; window.opener.location = \"http://www.baidu.com/\"; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; test2页面打开后通过js修改window.opener.location使得之前的test1页面的地址被更改，例子中改的是百度页面，在现实中攻击者可将其改为模拟的该网站的登录界面，用户在未发现网页已被篡改的情况下将登录信息填写提交给了攻击者 防御措施a链接中使用target=”_blank”属性时需添加上 rel=&quot;noopener noreferrer&quot;，noreferrer是由于Firefox不支持noopener而添加的 XSS攻击简介跨站脚本攻击，英文全称是Cross Site Script，在安全领域叫做“XSS”。XSS攻击通常指黑客通过“HTML注入”篡改了网页，插入了恶意脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。XSS根据效果的不同可以分为如下几类： 反射性 XSS发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码，这个过程像一次反射，因此叫做反射型XSS 存储型XSS存储型XSS会把用户输入的数据存储到服务器，这种攻击具有很强的稳定性,也叫“持久型XSS” DOM Based XSS通过修改页面的DOM节点形成的XSS 反射性 XSS有一个xss.php页面用于接收并显示传递过来的参数$input = $_GET[\"test\"];echo \"&lt;div&gt;\".$input.\"&lt;/div&gt;\"; 在其他网页上有如下一个链接&lt;a href=\"xss.php?test=&lt;script&gt;alert('XSS')&lt;/script&gt;\"&gt;诱你点击&lt;/a&gt; 测试得知：IE8和firfox都弹窗显示XSS，攻击成功。chrome则被浏览器的xss保护策略阻止 存储型XSS发表的文章中含有恶意脚本例如：你可以试试看&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;，后端没有对文章进行过滤就将内容存到数据库，当其他用户再次看这篇文章时，包含的恶意脚本被执行 DOM Based XSS&lt;script type=\"text/javascript\"&gt; function test() &#123; var str = document.getElementById(\"test\").value; document.getElementById(\"t\").innerHTML = \"&lt;a href='\" + str + \"'&gt;test&lt;/a&gt;\"; &#125;&lt;/script&gt;&lt;div id=\"t\"&gt;&lt;/div&gt;&lt;input type=\"text\" id=\"test\" value=\"\"&gt;&lt;input type=\"submit\" value=\"submit\" onclick=\"test()\"&gt; 如果在输入框中填写&#39;&gt;&lt;img src=# onerror=alert(&#39;xss&#39;) /&gt;&lt;&#39;，点击按钮提交后浏览器会产生XSS弹窗，攻击成功。 防御措施 后端在接收请求数据时，需要做输入检查，过滤特殊符号和标签 前端在显示后端数据时，需要做输出检查，不仅是标签内容需要过滤、转义，就连属性值和样式也都可能需要。 在处理富文本时可以设置标签白名单 设置HttpOnlly防止cookie劫持 CSRF攻击简介CSRF（Cross Site Request Forgery），中文是跨站点请求伪造。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。 攻击实例// submit.php 通过get请求获取数据$username = $_COOKIE['username'];$productId = $_GET['pid'];// 这里进行购买操作store_into_database($username, $productId);echo $username . '买入商品：' . $productId; 黑客攻击页面&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"http://localhost:8080/csrf/submit.php?pid=1\" /&gt; &lt;/body&gt;&lt;/html&gt; 当你正常浏览网页的时候会生成认证信息，此时黑客诱使你点击攻击页面，该页面会利用你当前的认证信息，从而对数据进行操作 防御措施1.合理使用POST和GETGET方法提交数据很容易被拿来做CSRF攻击，使用POST只能降低攻击风险，并不能杜绝，攻击者在第三方页面构造一个form就可以用POST提交数据构成CSRF攻击。 2.使用验证码在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。 3.Referer信息检查通过检查referer信息是否合法来判断用户是否被CSRF攻击，仅仅是满足防御的充分条件，Referer Check的缺陷在于服务器并非什么时候都收到Referer，并且Referer信息可以伪造 4.使用 TokenToken需要足够随机，必须使用足够安全的随机数生成算法Token可以放在用户的Session中或Cookie中，在提交请求时，服务器只需要验证表单中Token与用户Session（或Cookie）中的Token是否一致，一致则认为合法在使用Token时尽量把Token放在表单中，使用POST提交，以避免Token泄露如果该网站还存在XSS漏洞，那么使用Token方法防御CSRF攻击也就无效了（XSRF攻击） 参考文献：1.《白帽子讲WEB安全》2.浅谈CSRF攻击方式","tags":[{"name":"WEB","slug":"web","permalink":"https://jesse121.github.io/tags/web/"}]},{"title":"CSS页面布局常见问题总结","date":"2017-05-19T16:00:00.000Z","path":"articles/html-css/css-layout-faq.html","text":"在前端开发中经常会碰到各种类型布局的网页，这要求我们对css网页布局非常熟悉。其中水平垂直居中布局，多列布局等经常会被使用到，今天就来解决一下css布局方面的问题。 水平垂直居中的几种方法说到水平垂直居中布局我们一般会立马想到以下几种情况：实验参数设置&lt;div class=\"container\"&gt; 123 &lt;p class=\"inner\"&gt;456&lt;/p&gt; &lt;span class=\"inner\"&gt;789&lt;/span&gt; &lt;img class=\"inner\" src=\"img/1.jpg\"&gt;&lt;/div&gt; 未脱离文档流时文本元素/*方法一：*//*配合单行文字使用*/.container&#123; height: 400px; width: 400px; border: 1px solid red; text-align:center; line-height:400px;&#125;/*方法二：*/ .container&#123; height: 400px; width: 400px; border: 1px solid red; text-align:center;&#125;.container:after&#123; display:inline-block; content:\"\"; height:100%; vertical-align:middle;&#125; 行内元素/*方法一：*/.container&#123; height: 400px; width: 400px; border: 1px solid red; text-align:center; display:table-cell; vertical-align:middle;&#125;/*方法二：*/.container&#123; height: 400px; width: 400px; border: 1px solid red; text-align:center;&#125;.container:after&#123; display:inline-block; cotent:\"\"; height:100%; vertical-align:middle;&#125; 块状元素/*方法一：*/.container&#123; height: 400px; width: 400px; border: 1px solid red; text-align:center; display:table-cell; vertical-align:middle;&#125;/*方法二：*//*配合多行文本使用*/.container&#123; height: 400px; width: 400px; border: 1px solid red; text-align:center; display:table-cell; vertical-align:middle;&#125;.inner&#123; width:200px; /*需要给子元素一个宽度*/ margin: auto;&#125; 替换元素常见的替换元素有：&lt;img&gt; &lt;input&gt; &lt;textarea&gt; &lt;select&gt; &lt;button&gt;/*方法一：*/.container&#123; height: 400px; width: 400px; border: 1px solid red; text-align:center;&#125;.container:after&#123; display:inline-block; cotent:\"\"; height:100%; vertical-align:middle;&#125;.inner&#123; vertical-align:middle;&#125;/*方法二：*/.container&#123; height: 400px; width: 400px; border: 1px solid red; text-align:center; display:table-cell; vertical-align:middle;&#125;.inner&#123; vertical-align:middle;&#125; 水平垂直居中的终极方法：.container&#123; height: 400px; width: 400px; border: 1px solid red; display: flex; align-items: center; justify-content: center; /*以下是个各种兼容代码*/ /* 老版本语法: 比较少用*/ display: -webkit-box; display: -moz-box; display: -webkit-flex; display: -ms-flexbox; -webkit-box-align: center; -moz-box-align: center; -ms-flex-align: center; -webkit-align-items: center; -webkit-box-pack: center; -moz-box-pack: center; -ms-flex-pack: center; -webkit-justify-content: center;&#125; 优点：同样的代码解决各种问题缺点：IE8及以下不兼容 脱离文档流时行内元素、块状元素、替换元素由于行内元素加上position:absolute;之后会生成一个块级框，与块状元素类似，其高宽可控/*当知道子元素高宽时*/.container&#123;position:relative;&#125;.inner&#123; position: absolute; width:100px; height: 50px; top:50%; left:50%; margin-left:-50px; margin-top:-25px; &#125;或者 .inner&#123; position:absolute; top:0; bottom:0; left:0; right:0; width:200px; height:设置为适当的高度; margin: auto;&#125;/*当子元素高宽未知时*/.inner&#123; position: absolute; top:50%; left:50%; -webkit-transform: translate(-50%,-50%); -o-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%);&#125; 常见的几种页面布局固定布局负边距除去列表右边框&lt;style type=\"text/css\"&gt;#div1 &#123; width: 580px; height: 380px; margin: 0 auto; border: 3px solid lightblue; overflow: hidden; margin-top: 10px; &#125;.box &#123; width: 180px; height: 180px; margin: 0 20px 20px 0; background: lightgreen; float: left; &#125;#div2 &#123; margin-right: -20px; /*通过在外面包裹的div上添加负边距，除去列表的右边框*/&#125;&lt;/style&gt;&lt;div id=\"div1\"&gt; &lt;div id=\"div2\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 双飞翼布局 三列布局，中间宽度自适应，两边定宽； 中间栏要在浏览器中优先展示渲染； 允许任意列的高度最高； 要求只用一个额外的DIV标签； 要求用最简单的CSS、最少的HACK语句； body,html &#123; height: 100%; font: 20px/40px \"microsoft yahei\"; color: white; &#125;#container &#123; width: 90%; margin: 0 auto; height: 100%; &#125;#header,#footer &#123; height: 12.5%; background: deepskyblue; &#125;#main &#123; height: 75%; &#125;#center,#left,#right &#123; height: 100%; float: left; &#125;#center &#123; width: 100%; background: lightgreen; &#125;#left &#123; background: lightcoral; width: 20%; margin-left: -100%; &#125;/*左侧设置margin-left: -100%;使得left移上去*/#right &#123; background: lightblue; width: 20%; margin-left: -20%; &#125;/*右侧设置margin-left: -20%;使得right在右侧*/#main-inner &#123; margin: 0 20%; &#125;/*双飞翼布局和圣杯布局的区别在于是否有main-inner块，如果没有可直接通过设置#center&#123;padding: 0 20%;&#125;#left&#123;position:relative;left:-leftwidth;&#125;#right&#123;position:relative;right:-rightwidth;&#125;&lt;/style&gt;&lt;div id=\"container\"&gt; &lt;div id=\"header\"&gt; header &lt;/div&gt; &lt;div id=\"main\"&gt; &lt;div id=\"center\"&gt; &lt;div id=\"main-inner\"&gt; center &lt;/div&gt; &lt;/div&gt; &lt;div id=\"left\"&gt; left &lt;/div&gt; &lt;div id=\"right\"&gt; right &lt;/div&gt; &lt;/div&gt; &lt;div id=\"footer\"&gt; footer &lt;/div&gt;&lt;/div&gt; 流式布局网页中主要的划分区域的尺寸使用百分数（搭配min-、max-属性使用）图片也作类似处理（width:100%, max-width一般设定为图片本身的尺寸，防止被拉伸而失真）。这种布局方式在Web前端开发的早期历史上，用来应对不同尺寸的PC屏幕，在当今的移动端开发也是常用布局方式。缺点：宽度使用百分比定义，但是高度和文字大小等大都是用px来固定(现在用em,rem)，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。 弹性布局由于前人总结的很好，我就不造轮子了一劳永逸的搞定 flex 布局由于flex是css3的属性，低版本浏览器不兼容 瀑布流布局masonry实现瀑布流布局具体使用方法可参考官网教程 响应式布局@media screen and (max-width:320px)&#123; /*视窗&lt;=320px*/ /*css code */&#125; @media screen and (min-width:769px)and(max-width:1000px)&#123; /* 769px&lt;=视窗&lt;=1000px */ /*css code */&#125; 清除浮动的几种方法空标签&lt;div style=\"clear:both;\"&gt;&lt;/div&gt; 优点：简单明了缺点：增加无意义的空标签，违背了结构表现分离，给后期维护带来了问题。 利用BFCBFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 以下元素会生成BFC：根元素float属性不为noneoverflow不为visibleposition为absolute或fixeddisplay为inline-block, table-cell, table-caption, flex, inline-flex中任何一个 after伪类样式给父元素增加clearfix类即可,推荐使用.clearfix:after&#123; content: \".\"; display: block; height: 0px; clear: both; visibility: hidden;&#125; 参考文章： CSS3与页面布局学习总结（四）——页面布局大全 一劳永逸的搞定 flex 布局","tags":[{"name":"CSS","slug":"css","permalink":"https://jesse121.github.io/tags/css/"}]},{"title":"【译】编写整洁 CSS 代码的黄金法则","date":"2017-05-03T16:00:00.000Z","path":"articles/translation/golden-guidelines-for-writing-clean-css.html","text":"要编写整洁的CSS代码，你必须准守以下规则，它将有助于你写出轻量的可复用的CSS代码： 避免使用全局选择器和元素选择器 避免使用权重过高的选择器 使用语义化类名 避免 CSS 和标签结构的紧耦合 本文将依次阐述上述规则。 避免使用全局选择器全局选择器包括通配选择器（*）、元素选择器（例如p、button、h1等）和属性选择器（例如[type=checkbox]），这些选择器的样式声明会被应用到全站所有符合要求的元素上，例如：button &#123; background: #FFC107; border: 1px outset #FF9800; display: block; font: bold 16px / 1.5 sans-serif; margin: 1rem auto; width: 50%; padding: .5rem;&#125; 这段代码看起来没什么问题，但是倘若我们需要新建一个样式不同的button元素选择器呢？我们需要定义一个类名为close的button元素用于关闭对话框组件：&lt;section class=\"dialog\"&gt; &lt;button type=\"button\" class=\"close\"&gt;Close&lt;/button&gt;&lt;/section&gt; PS: 为什么不使用 dialog 元素？我们这里使用section元素而不使用dialog元素是因为只有基于 Blink 内核的浏览器才支持 dialog 元素， 例如 Chrome/Chromium、Opera、和 Yandex 等。 现在，需要编写 CSS 代码来覆盖那些不需要继承于button元素选择器的属性：.close &#123; background: #e00; border: 2px solid #fff; color: #fff; display: inline-block; margin: 0; font-size: 12px; font-weight: normal; line-height: 1; padding: 5px; border-radius: 100px; width: auto; &#125; 我们仍然需要许多类似的样式来覆盖浏览器的默认样式。但如果我们将button元素选择器的样式用一个default类选择器来替换会如何呢？结果发现close类中不需要指定display、font-weight、 line-height、margin、 padding和width等属性，这便减少了 23% 的代码量：.default &#123; background: #FFC107; border: 1px outset #FF9800; display: block; font: bold 16px / 1.5 sans-serif; margin: 1rem auto; width: 50%; padding: .5rem;&#125;.close &#123; background: #e00; border: 2px solid #fff; color: #fff; font-size: 12px; padding: 5px; border-radius: 100px;&#125; 还有一点非常重要：避免使用全局选择器将有助于减少样式冲突，即在某个模块或页面的开发中添加样式不会对其他模块或页面造成影响 全局样式和选择器非常适合用于重置和统一浏览器默认样式，在其他情况下，它们只会造成代码臃肿。 避免使用权重过高的选择器保持选择器的低权重是编写轻量级、可复用和可维护的 CSS 代码的又一关键所在。正如你所回忆起的权重，一个元素选择器的权重是 0,0,1，而类选择器的权重则是 0,1,0：/* Specificity of 0,0,1 */p &#123; color: #222; font-size: 12px;&#125;/* Specificity of 0,1,0 */.error &#123; color: #a00;&#125; 当你为一个元素添加类名后，这个元素选择器的的优先级将高于一般元素选择器。这里没有必要将类选择器和属性选择器组合在一起来提升优先级，这样做只会增加选择器的权重和文件的大小。 换句话说，没有必要使用 p.error 这样的选择器，因为仅仅一个 .error 就能达到同样的效果，此外还有一个好处是 .error 还可以被其他元素所复用，而 p.error 选择器则会将 .error 这个类限制于 p 元素上。 避免链式类选择器同时还需要避免链式类选择器。比如：.message.warning这样的选择器的权重为0,2,0。权重越高意味着越难进行样式覆盖，增长连接都会导致这种副作用，举例如下：.message &#123; background: #eee; border: 2px solid #333; border-radius: 1em; padding: 1em;&#125;.message.error &#123; background: #f30; color: #fff;&#125;.error &#123; background: #ff0; border-color: #fc0;&#125; 如图所示，在上述CSS作用下&lt;p class=&quot;message&quot;&gt;会呈现一个带有深灰色边框和灰色背景的盒子。 A message而&lt;p class=&quot;message error&quot;&gt;会呈现 .message.error 类的背景和 .error 类的边框： A error occured要想覆盖链式类选择器的样式，只能使用权重更高的选择器。为了消除黄色的边框，需要在已有选择器上再加一个类名或一个标签选择器：.message.warning.exception 或 div.message.warning，更好的做法是创建一个新类。如果你发现你正在使用链式类选择器，那就该回过头重新考虑了。要么是设计上存在不合理的地方，要么就是过早的使用链式类从而想避免那些尚不存在的问题。解决这些问题将会带来更高的可维护性和可复用性。 避免使用 id 选择器因为在一篇文档中每个 id 只能对应一个元素，所以id 选择器的 CSS 规则是很难复用的。这样做一般都会涉及到一系列的 id 选择器，例如#sidebar-features和#sidebar-sports。 id标识符是具有很高的权重的，要想覆盖它就必须使用更“长”的选择器。例如下面这段 CSS 代码，为了覆盖 #sidebar 的背景颜色属性，必须使用 #sidebar.sports 和 #sidebar.local： #sidebar &#123; float: right; width: 25%; background: #eee;&#125;#sidebar.sports &#123; background: #d5e3ff;&#125;#sidebar.local &#123; background: #ffcccc;&#125; 改用类选择器，例如 .sidebar，就可以简化我们的 CSS 选择器：.sidebar &#123; float: right; width: 25%; background: #eee;&#125;.sports &#123; background: #d5e3ff;&#125;.local &#123; background: #ffcccc;&#125; 这不仅能减少字节，而且.sport和.local类还能添加到其他元素上。 使用属性选择器例如[id=sidebar]可以解决 id 选择器高权重的问题，尽管其复用性不如类选择器，但其低权重可以让我们避免使用链式类选择器。 PS id 选择器的高权重也确有用武之地在某些情况下，你可能确实需要 id 选择器的高权重性。例如，一些网络上的媒体站点可能需要其所有子站都使用同样的导航条组件，该组件必须在所有站点都表现一致并且其样式是难以被覆盖的。此时，使用 id 选择器就可以减少导航条样式被意外覆盖的情况。 最后，让我们再来讨论一下形如 #main article.sports table#stats tr:nth-child(even) td:last-child 这样的选择器。不仅它长的离谱，而且其权重为 2,3,4，也很难复用。在你的HTML标记文档中又有多少标签真能匹配这一选择器呢？我们稍作修改，可以将选择器拆分为#stats tr:nth-child(even) td:last-child，其权重也足够满足需求了。当然最好的办法是使用类选择器，这样既能提高复用性又能减少代码量。 PS：预处理器嵌套综合症权重过高的选择器大多是由预处理器中过多的嵌套造成的 使用语义化类名所谓的语义化，是指要有意义，类名应该表明这是什么规则或者这些规则影响到那些内容。此外类名也要能够适应 UI 需求的变化。命名看似简单，实则不然。 不要使用.red-text、.blue-button、.border-4px 和 .margin10px 这样的类名，因为这些类名和当前的设计耦合的太紧密。用class=&quot;red-text&quot;来标记一个错误的信息，看似可行，但如果设计稿发生了变化并要求将错误信息用橙底黑字表示呢？这时原有类名就不准确了，使得你和你的同事更难以理解代码的真正含义。 在这种情况下，比较好的做法是用.alert, .error, 或者 .message-error等类名。这些类名指明了这些类如何使用以及他们会影响到哪些内容。对于定义页面布局的类名，不妨加上 layout-、 grid-、col-或 l- 等前缀，使人一眼可以看出它们的作用。之后关于 BEM 方法论的章节会详细阐述了这一过程。 避免 CSS 和标签结构的紧耦合你可能在代码中使用过子元素选择器和后代选择器。子元素选择器形如E &gt; F，其中 F 是某个元素，而 E 是 F 的直接父元素。例如，article &gt; h1 会影响 &lt;article&gt;&lt;h1&gt;Advanced CSS&lt;/h1&gt;&lt;/article&gt; 中的 h1 元素，但不会影响 &lt;article&gt;&lt;section&gt;&lt;h1&gt;Advanced CSS&lt;/h1&gt;&lt;/section&gt;&lt;/article&gt; 中的 h1 元素。另一方面，后代选择器形如E F，其中 F 是某个元素而 E 是 F 的祖先元素。还用上述例子，则那两种标签结构中的 h1 元素都会受到 article h1的影响。 不是说子元素选择器和后代元素选择器的继承性不好，实际上它们在限制 CSS 规则的作用域方面确实发挥着很好的作用。但它们也绝非理想之选，因为标签结构经常会发生改变。 你可能会有以下经历，你为某个客户编写了一些模版，并且在 CSS 代码中用到了子元素选择器和后代选择器，并且大多数都是元素选择器，即形如 .promo &gt; h2 和 .media h3 这样的选择器；后来你的客户又聘请了一位 SEO 技术顾问，他检查了你代码中的标签结构并建议你将 h2 和 h3 分别改为 h1 和 h2，这时候问题来了 —— 你必须同时修改 CSS 代码。 这个时候类选择器再一次表现出其优点。使用 .promo &gt; .headline或 .media .title（或者更简单一些： .promo-headline 和 .media-title）使得在改变标签结构的时候无需改变 CSS 代码。 当然，这条规则假设你对标签结构有足够的控制权，当在面对一些遗留的 CMS 系统的时候这些可能是不正确的，在这种情况下使用子元素选择器、后代选择器和伪类选择器是适当的同时也是必要的。 PS：更多架构合理的 CSS 规则Philip Walton 在其 “CSS 架构”一文中讨论了相关规则，有关 CSS 架构的更多想法参见 Roberts 的网站 CSS 原则 以及 Nicolas Gallagher 的博客文章 HTML 语义化及前端架构。 接下来将会探讨有关 CSS 架构的两种方法，这两种方法主要用于提升大规模团队和大规模站点的开发效率，但对于小团队来说其实也是十分适用的。 译文链接：编写整洁 CSS 代码的黄金法则原文链接：Golden Guidelines for Writing Clean CSS翻译作者：Jesse转载必须保留译文链接、原文链接、翻译作者等信息。","tags":[{"name":"CSS","slug":"css","permalink":"https://jesse121.github.io/tags/css/"}]},{"title":"前端开发工作中常用的JavaScript片段","date":"2017-05-02T16:00:00.000Z","path":"articles/javascript/JavaScript-Fragments-Used-In-Front-End-Development.html","text":"前端开发过程中总是会发现有些JS片段需要被经常使用，今天就来总结一下工作中常用到的一些JS片段，如果你经常使用jQuery库有可能很多片段用不到，但是我还是提倡大家使用原生JS，毕竟这才是根本，很多库文件的源码也是这么写的 目录 常用兼容方法(IE8+) insertAfter() 紧挨着某元素后面插入DOM元素 getElementByClassName() 根据类名获取DOM元素，IE9+已实现 trim() 除去字符串左右空格 EventUtil 跨浏览器的事件处理程序，属于一个名为EventUtil的对象 常用工具类 移动端和PC端网址自动切换 常用正则表达式 获取DOM元素的实际样式 日期格式化 将url中参数以对象的形式输出 将cookie中内容以对象形似输出 设置cookie 浏览器类型及IE浏览器版本检测 简单特效类 返回页面顶部 常用兼容方法(IE8+)insertAfter()function insertAfter(newElement, targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement) &#123; parent.appendChild(newElement); &#125; else &#123; parent.insertBefore(newElement, targetElement.nextSibling); &#125;&#125; getElementByClassName()这个方法比较少用，IE8+已支持querySelector()和querySelectorAll()function getElementsByClassName(element, names) &#123; if (element.getElementsByClassName) &#123; return element.getElementsByClassName(names); &#125; else &#123; var elements = element.getElementsByTagName('*'); var result = [], element, classNameStr, flag; names = names.split(' '); for (var i = 0; element = elements[i]; i++) &#123; classNameStr = ' ' + element.className + ' '; flag = true; for (var j = 0, name; name = names[j]; j++) &#123; if (classNameStr.indexOf(' ' + name + ' ') == -1) &#123; flag = false; break; &#125; &#125; if (flag) &#123; result.push(element); &#125; &#125; return result; &#125;&#125; trim()if (!String.prototype.trim) &#123; String.prototype.trim = function () &#123; return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''); &#125;;&#125; EventUtilvar EventUtil = &#123; //添加事件 addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); //使用DOM2级方法添加事件 &#125; else if (element.attachEvent) &#123; //使用IE方法添加事件 element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; //使用DOM0级方法添加事件 &#125; &#125;, //取消事件 removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;, //使用这个方法跨浏览器取得event对象 getEvent: function(event) &#123; return event ? event : window.event; &#125;, //返回事件的实际目标 getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, //阻止事件的默认行为 preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, //阻止事件冒泡 stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, //获取mouseover和mouseout相关元素 getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; return event.toElement; &#125; else if (event.formElement) &#123; return event.formElement; &#125; else &#123; return null; &#125; &#125;, //获取mousedown或mouseup按下或释放的按钮是鼠标中的哪一个 getButton: function(event) &#123; if (document.implementation.hasFeature(\"MouseEvents\", \"2.0\")) &#123; return event.button; &#125; else &#123; switch (event.button) &#123; //将IE模型下的button属性映射为DOM模型下的button属性 case 0: case 1: case 3: case 5: case 7: return 0; //按下的是鼠标主按钮（一般是左键） case 2: case 6: return 2; //按下的是中间的鼠标按钮 case 4: return 1; //鼠标次按钮（一般是右键） &#125; &#125; &#125;, //获取表示鼠标滚轮滚动方向的数值 getWheelDelta: function(event) &#123; if (event.wheelDelta) &#123; return event.wheelDelta; &#125; else &#123; return -event.detail * 40; &#125; &#125;, //以跨浏览器取得相同的字符编码，需在keypress事件中使用 getCharCode: function(event) &#123; if (typeof event.charCode == \"number\") &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;&#125;; 常用工具类移动端和PC端网址自动切换var system = &#123; win: false, mac: false, xll: false, ipad:false &#125;; var p = navigator.platform; system.win = p.indexOf(\"Win\") == 0; system.mac = p.indexOf(\"Mac\") == 0; system.x11 = (p == \"X11\") || (p.indexOf(\"Linux\") == 0); system.ipad = (navigator.userAgent.match(/iPad/i) != null)?true:false; if (system.win || system.mac || system.xll||system.ipad) &#123; window.location.href = \"http://www.baidu.com/\"; &#125; else &#123; window.location.href = \"http://wap.baidu.com/\"; &#125; 常用正则表达式虽然这里列出了常用的正则表达式，但是还是建议各位看官在用的时候多加考虑一下是否适合你的项目//验证邮箱//验证规则：姑且把邮箱地址分成“第一部分@第二部分”这样//第一部分：由字母、数字、下划线、中划线、点号组成，//第二部分：为一个域名，域名由字母、数字、中划线、根域名组成，而根域名一般为.xx或.xxx/^[A-Za-z0-9]+([\\-\\_\\.][A-Za-z0-9])*@[A-Za-z0-9]+([\\-\\.][A-Za-z0-9]+)*\\.[A-Za-z]&#123;2,3&#125;$/;//验证固定电话（区号+号码 010-88888888,0955-7777777 ）//验证规则:区号以0开头后面2~3位是数字,区号与号码之间可以无连接符，也可以“-”连接,后面的号码由7~8位数字组成,/^0\\d&#123;2,3&#125;-?\\d&#123;7,8&#125;$///验证手机号//验证规则：首位以数字1开头，第二位数字目前包括3,4,5,7,8，剩下的是9位数字/^1[3|4|5|7|8]\\d&#123;9&#125;$///验证规则：11位数字，以1开头。/^1\\d&#123;10&#125;$///考虑到第二位可能会出现新的数字，建议使用第二种方式 //验证QQ//验证规则：首位不以数字0开头，剩下的4~9位是数字/^[1-9]\\d&#123;4,9&#125;$///验证身份证号码 这里是非严格验证//验证规则：这里分为18为纯数字的身份证号和17位数字加字母X或x的两种情况/(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)///验证URL/^((https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\/\\w \\.-]*)*\\/?$///匹配字母、数字、中文字符/^([A-Za-z0-9]|[\\u4e00-\\u9fa5])*$///匹配中文字符的正则表达式/[\\u4e00-\\u9fa5]///匹配双字节字符(包括汉字在内)/[^\\x00-\\xff]///密码强度正则//最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符/^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/; 获取DOM元素的实际样式function getStyle(element, cssPropertyName) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(element)[cssPropertyName]; &#125; else &#123; return element.currentStyle[cssPropertyName]; &#125;&#125; 日期格式化function add0(t)&#123;return t = t &lt; 10 ? '0'+ t : t&#125;function format(time)&#123; var y = time.getFullYear(), m = time.getMonth() + 1, d = time.getDate(), hh = time.getHours(), mm = time.getMinutes(), ss = time.getSeconds(); return y+\"-\"+add0(m)+\"-\"+add0(d)+\" \"+add0(hh)+\":\"+add0(mm)+\":\"+add0(ss);&#125; 将url中参数以对象的形式输出function parseQueryString(url)&#123; var str=url.split(\"?\")[1]; var items=str.split(\"&amp;\"); var result=&#123;&#125;; var arr=[]; for(var i=0; i&lt;items.length; i++)&#123; arr=items[i].split('='); result[arr[0]]=arr[1]; &#125; return result;&#125; 将cookie中内容以对象形似输出/** * 获取cookie并以对象形式输出 * @return &#123;name:value&#125; */function getCookie() &#123; var cookie = &#123;&#125;; var all = document.cookie; if (all === \"\") return cookie; var list = all.split(\";\"); for (var i = 0; i &lt; list.length; i++) &#123; var item = list[i]; var p = item.indexOf(\"=\"); var name = item.substring(0, p); name = decodeURIComponent(name); var value = item.substring(p + 1); value = decodeURIComponent(value); cookie[name] = value; &#125; return cookie;&#125; 设置Cookie/** * 设置cookie * @param &#123;[type]&#125; name [设置的cookie名称] * @param &#123;[type]&#125; value [设置的cookie值] * @param &#123;[type]&#125; expires [设置的cookie的过期时间] * @param &#123;[type]&#125; path [设置的cookie的路径] * @param &#123;[type]&#125; domain [设置的cookie关联的域名] * @param &#123;[type]&#125; secure [设置的cookie是否使用安全协议传输数据，默认为空] */function setCookie(name, value, expires, path, domain, secure) &#123; var cookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value); if (expires) cookie += \"; expires=\" + expires.toGMTString(); if (path) cookie += \"; path=\" + path; if (domain) cookie += \"; domain=\" + domain; if (secure) cookie += \"; secure=\" + secure; document.cookie = cookie;&#125; 浏览器类型及IE浏览器版本检测function browserType() &#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isOpera = userAgent.indexOf(\"Opera\") &gt; -1; //判断是否Opera浏览器 var isIE = userAgent.indexOf(\"compatible\") &gt; -1 &amp;&amp; userAgent.indexOf(\"MSIE\") &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器 var isEdge = userAgent.indexOf(\"Windows NT 6.1; Trident/7.0;\") &gt; -1 &amp;&amp; !isIE; //判断是否IE的Edge浏览器 var isFF = userAgent.indexOf(\"Firefox\") &gt; -1; //判断是否Firefox浏览器 var isSafari = userAgent.indexOf(\"Safari\") &gt; -1 &amp;&amp; userAgent.indexOf(\"Chrome\") == -1; //判断是否Safari浏览器 var isChrome = userAgent.indexOf(\"Chrome\") &gt; -1 &amp;&amp; userAgent.indexOf(\"Safari\") &gt; -1; //判断Chrome浏览器 if (isIE) &#123; var reIE = new RegExp(\"MSIE (\\\\d+\\\\.\\\\d+);\"); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[\"$1\"]); if (fIEVersion == 7) &#123; console.log(\"this is IE7\"); return false; &#125; else if (fIEVersion == 8) &#123; console.log(\"this is IE8\"); return false; &#125; else if (fIEVersion == 9) &#123; console.log(\"this is IE9\"); return false; &#125; else if (fIEVersion == 10) &#123; console.log(\"this is IE10\"); return false; &#125; else if (fIEVersion == 11) &#123; console.log(\"this is IE11\"); return false; &#125; else &#123; console.log(\"IE版本过低\"); return false; &#125; &#125; if (isFF) &#123; console.log(\"this is firefox\"); return false; &#125; if (isOpera) &#123; console.log(\"this is opera\"); return false; &#125; if (isSafari) &#123; console.log(\"this is safari\"); return false; &#125; if (isChrome) &#123; console.log(\"this is chrome\"); return false; &#125; if (isEdge) &#123; console.log(\"this is edge\"); return false; &#125;&#125; 简单特效类返回页面顶部$(window).scroll(function() &#123; if($(window).scrollTop() &gt; $(window).height() / 2) &#123; $(\"#toTop\").show(500); &#125;else&#123; $(\"#toTop\").hide(500); &#125;&#125;)$(\"#toTop\").click(function() &#123; $(\"html,body\").animate(&#123; scrollTop: 0 &#125;, 500);&#125;);","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"【译】如何成为一个优秀的前端工程师？","date":"2017-04-27T16:00:00.000Z","path":"articles/translation/how-to-become-a-great-front-end-engineer.html","text":"最近我收到一封来自我的博客读者的电子邮件，里面的一些问题不禁让我陷入沉思，它是这样问的： 你好菲利普，能否告诉我你是如何成长为一个优秀的前端工程师的？有什么好的建议吗？ 我不得不承认看到这个问题的时候我很惊讶，因为我从来就没有把自己看作是一位“优秀的”前端工程师。事实上在这个行业工作的头几年，我一直认为我是不能胜任我所拥有的工作。我申请这些职位是因为我没有意识到我知道的太少了，而能顺利拿下这份工作则是因为面试官不知道该问什么。话虽这么说，可最后每一份工作我都完成得很好，并成为了团队中的重要成员。当我要辞职离开的时候（接受下一个挑战）,还常常被要求找到一个合适的人来顶替我。回顾我当初面试的时候，只将重点内容放在知识上给了我很深刻的印象。现在的我应该不会聘用之前的我，尽管从我的个人经验来看，胜任还是有可能的。 从事WEB工作的时间越长，我越发意识到能将优秀的人和真正优秀的人区分开的不是他们所掌握的知识，而是他们思考问题的方式。尽管在某些情况下知识很重要，但是在一个快速变化的领域，如何获取知识比你目前已经掌握的知识更重要（至少从长远来看）。也许最重要的是：你如何利用这些知识来解决日常工作中的问题。 现在有很多文章在谈论找工作的时候需要什么语言，什么框架，什么工具。我想换一种方式来谈论，在这篇文章中我将谈论有关前端工程师的思维模式，希望能给这个问题一个永久的答案：如何成为一个优秀的前端工程师？ 不要仅仅为了解决问题，弄要清楚问题的根本很多写CSS和JavaScript的程序员在修改bug的时候，总是一旦修改好立马离开。这在代码审查阶段很常见的。 我会经常问别人：“你为什么要在这里加入float:left;？”或“这里的overflow:hidden;真的有必要吗？”，他们会回答：“我不知道，但如果我删除它，它就不工作了”。 JavaScript中的情况也是如此。我会看到setTimeout被用来防止多线程之间的资源竞争，或者阻止传播那些不考虑对页面上其他事件处理程序产生影响的事件。 我意识到，当你需要完成某一个工作的时候，现在就解决出现的问题当然是好的。但如果你不花时间去了解这个问题的根源，那么你会发现自己将一次又一次地陷入同样的问题中。 花时间去弄明白为什么你的解决方案奏效看似很费时费力，但我保证将来它能节省你很多时间。对你工作的内容又个一个深入全面的了解，这将意味着在以后工作的道路上能减少很多疑惑和检查工作。 学会预测未来浏览器的变化一个前端和后端代码的主要区别是后端代码通常运行在一个受你控制的环境之下。相反，而前端则完全在你的控制之外。用户使用的平台和设备随时可能改变，所以你的代码得能够优雅地处理这样的情况。 我记得在2011年的时候看过一个流行的JavaScript框架的源代码，看到以下代码（为了简便起见已作修改）： var isIE6 = !isIE7 &amp;&amp; !isIE8 &amp;&amp; !isIE9; 在当时的情况下，IE6的确涵盖了所有的IE浏览器版本，能够处理所有高于IE6的版本但当IE10出来了之后，程序大部分地方就会功能丧失。 这让我明白，在实际开发中浏览器特征检测并不会100%的准确，有时你不得不依赖的bug行为或使用那些特征检测错误返回误报的白名单浏览器，但一旦你这样做，你就必须得能预测到未来某个时候这些bug将不复存在，这是非常关键的。 对我们大多数人来说，今天写的代码的存活时间会比我们就职于当前工作的时间更久。我8年前写的一些代码，今天依然在一些大型的生产网站运行，固步自封的思想，既令人满足，又让人害怕。 阅读规范浏览器的bug是不可避免的，但当两个浏览器对相同的代码有着不同呈现的时候，人们往往不去检查自己的代码，就直接认为，那所谓的“好”的浏览器是正确的，“坏”的浏览器是错误的。但事实并非总是如此，当你被这个假设所误导的时候，无论你选择了什么解决方案，将来几乎都会失效。 这方面的一个例子就是flex items的默认最小尺寸问题。根据规范 flex items的min-width和min-height的初始值为auto（而不是0），这意味着默认他们不能缩小到小于其内容的最小尺寸。在过去8个月时间里，Firefox是唯一正确实现这一目标的浏览器。[1] 如果你遇到跨浏览器不兼容并且注意到你的网站在Chrome、IE、Opera和Safari浏览器上呈现是相同的，但在Firefox上却不一样，你可能会认为火狐搞错了。事实上，这样的情况我亲眼见过很多次。在我的Firebugs项目上的许多问题报告就是由于这种不兼容引起的，而提出的解决方法，如果实施的话，会在两周前Chrome44出来的时候失败。不遵从规格说明的解决方法会在不知不觉中损害正确的行为。[2] 当两个或多个浏览器对相同的代码却有不同的呈现结果时，你应该花时间去弄明白哪一个是正确的，然后谨记这一点来写代码。这样你的解决方法才不会在不久的将来成为过时的技术。 此外，所谓的“优秀”的前端工程师往往是那些站在科技前沿，敢于在主流之前先使用新技术，甚至促进新技术发展的人。如果你能培养自己阅读规范和展望技术前景的能力，那么你就会成为影响规范发展的一份子。 读别人的代码为了乐趣而阅读别人的代码，很可能不是你的星期六晚上的一个好的主意，但它无疑是一个成为一个更好的开发者的最佳途径。 依靠自己的本事来解决问题，是一个学习的好方法，但如果你只这么做，那你很快就会到达你的瓶颈。阅读他人的代码可以帮助你发现解决问题的新方法。阅读和理解代码是团队工作和合作开源项目时必不可少的能力。 其实我认为很多公司犯的最大的错误就是他们在聘请新的工程师时只要求他们写代码——从头开始写新的代码。我从未在任何一场面试中被要求阅读一些现有的代码，去找这些代码中的问题，然后解决这些问题。这真是太糟糕了，因为作为一个工程师你的大部分时间是花在增加或更改现有的代码库上的。很少需要你从头开始构建新的东西。 和比你聪明的人工作在我的印象中前端开发人员比后端开发人员更想成为自由职业者。也许是因为前端开发人员往往都是靠自学成才的而后端开发人员往往来自正规院校。 但是自学成才和为自己工作也是有缺陷的，那就是你通常不会明白从比你聪明的人那儿学习的好处。不会有人给你建议，也没有人为你检查代码。 我强烈建议至少在职业生涯的开始阶段，一定要进入一个团队工作，尤其是团队中的其他成员比你聪明比你有经验。 如果你在你职业生涯某个时间点，不想只为自己工作了，不妨可以参与到开源项目中。积极参与开源项目能为你提供很多与团队工作相同的好处，有的时候甚至好处更多。 重新造轮子“重新造轮子”对企业是不利的，但却是最好的学习方式。比如说你想掌握来自于npm的预输入控件或事件委托类库，那么不妨设想一下如果你自己来构建这些东西，你能学到多少。 我敢肯定看到这里一定有人想臭骂我一顿。别误解我的意思。我不是说你不应该使用第三方代码库。使用经过充分测试的库——坐享多年测试案例和bug报告总是明智的行为。 但在这篇文章中，我要说的是如何从良好进步到优秀。在这个行业中大多数我认为优秀的人，都是我们无时无刻不在使用的超级流行的库的创造者或维护者。 可能你也有一个成功的职业生涯———但却不曾构建自己的JavaScript库，那么你可能从未真正接近过它的本质。 很多人会问的有关于这个行业的一个常见问题是：接下来我该构建什么？如果你也问这个问题，那么给你个建议：与其去学习新的工具或开发新的app，为什么不去尝试重建自己喜欢的JavaScript库或CSS框架呢。这样做的好处是，如果碰到问题的话，现有的库的源代码会很直白的告诉你答案。 记录下你所学到的东西最后但同样重要的是，你应该把你学到的东西写下来。这么做的理由有很多，但最好的理由或许是这能迫使你更好地理解主题。如果你无法解释它是如何工作的，那么很有可能其实你还没有真正地理解。通常只有当你尝试将内容写下来的时候，才意识到自己原来还是没弄明白。 根据我的经验，写作、发表演讲、以及创建演示都是强迫自己从外到内挖掘和充分理解事物的最佳方式之一。即使不会有人来阅读你写的东西，但是写的这个过程绝对物超所值。 脚注： 2014年12月1日Firefox在版本34中实现了规格说明变化，Chrome于2015年7月21日添加到日历在版本44中实施，这意味着Opera很快也会这么做。Edge于2015年7月29号发布实施，而Safari似乎正在实施酝酿中。对于这个问题可以参考Flexbug＃1作为适用于未来的跨浏览器解决方案 译文链接：如何成为一个优秀的前端工程师英文原文：How to Become a Great Front-End Engineer翻译作者：Jesse[ 转载必须保留原文链接、译文链接和翻译作者等信息。]","tags":[]},{"title":"Apache Web服务器安全配置","date":"2017-04-18T16:00:00.000Z","path":"articles/webserver/safe-config-about-Apache.html","text":"尽管现在购买的云服务器很多都有一键web环境安装包，但是如果是自己配置web环境则需要对各种安全配置十分了解，今天我们就来尝试这做好web服务器安全配置。这里的配置不尽完善，若有纰漏之处还望指出。 修改Apache配置文件http.conf以专用的apache用户运行一般情况下，Apache是由Root 来安装和运行的。如果Apache Server进程具有Root用户特权，那么它将给系统的安全构成很大的威胁，应确保Apache Server进程以最可能低的权限用户来运行。1.window系统中创建apache用户在命令行中输入net user 查看系统已经存在的用户net user apache 131978jesse /add 添加apahce用户net localgroup apachegroup /add 添加apachegroup用户组net localgroup apachegroup apache /add 将apache添加进apachegroup用户组 2.给予apache用户读取和执行所有文档和脚本目录(例如：htdocs 和cgi-bin)的权限。 对Apache的logs目录具有读/写/删除(RWD)的权限。3.在http.conf文件中修改以下内容：User apacheGroup apachegroup 4.在service.msc服务中选择Aapche属性，登录账号改为apache，重启apache即可 apache目录禁止访问Indexes 的作用就是当该目录下没有 index.html文件时，就显示目录结构。默认apache在当前目录下没有index.html入口就会显示目录。让目录暴露在外面是非常危险的事，如下操作禁止apache显示目录：Options FollowSymLinks 将Options Indexes FollowSymLinks中的Indexes 去掉，就可以禁止 Apache 显示该目录结构。 阻止用户修改系统设置在Apache 服务器的配置文件中进行以下的设置，阻止用户建立、修改 .htaccess文件，防止用户超越能定义的系统安全特性。AllowOveride NoneOptions NoneAllow from all 然后再分别对特定的目录进行适当的配置。 apache 隐藏版本信息ServerSignature Off ServerTokens Prod 自定义错误页面ErrorDocument 400 /custom400.htmlErrorDocument 401 /custom401.htmlErrorDocument 403 /custom403.htmlErrorDocument 404 /custom404.htmlErrorDocument 405 /custom405.htmlErrorDocument 500 /custom500.html 删除如下apache的默认文件删除默认的HTML文件： # apache网页根目录htdocs下的html文件删除默认的icons文件： # apache安装目录下的icons文件夹及里面的文件 删除默认的的CGI脚本： # apache安装目录下的cgi-bin文件夹及里面的文件 删除Apache说明文件： # apache安装目录下的manual文件夹及里面的文件以及安装目录下的其他介绍性文件 使用rotatelogs 每隔一天记录一个日志CustomLog \"|bin/rotatelogs.exe logs/access.log 86400 480\" combined rotatelogs logfile [ rotationtime [ offset ]] | [ filesizeM ]logfile：它加上基准名就是日志文件名。如果logfile中包含’%’，则它会被视为用于的strftime(3)的格式字串；否则，它会被自动加上以秒为单位的.nnnnnnnnnn后缀。这两种格式都表示新的日志开始使用的时间。rotationtime：日志文件回卷的以秒为单位的间隔时间，86400 表示一天，即每天生成一个新的日志文件。offset：相对于UTC的时差的分钟数。如果省略，则默认为0，并使用UTC时间。比如，要指定UTC时差为-5小时的地区的当地时间，则此参数应为-300，北京时间为+8时间，应设置为480。这样日志里的时间才会和服务器上的时间一致，方便查看日志。filesizeM：指定回卷时以兆字节为单位的后缀字母M的文件大小，而不是指定回卷时间或时差。 修改PHP配置文件php.ini将时区修改为东八区北京时间date.timezone = “PRC” 响应头中y隐藏PHP版本信息expose_php = Off 禁止相关函数disable_functions = phpinfo, get_cfg_varsafe_mode = On //开启安全模式，这个开了，可能会有些php功能没办法使用了","tags":[{"name":"Apache","slug":"apache","permalink":"https://jesse121.github.io/tags/apache/"}]},{"title":"Apache2.4.23 + PHP5.6.30 + MySQL5.7.18安装教程","date":"2017-04-14T16:00:00.000Z","path":"articles/webserver/Apache2.4.23+PHP5.6.30+MySQL5.7.18.html","text":"最近在工作中常常接触到PHP，自己也写过一些简单的PHP页面。我们知道PHP是在服务器端运行的脚本语言，因此我们需要配置服务器环境。之前为了省事直接使用的是wamp集成环境，但是突然某一天领导要求我们做好Apache服务器的安全配置工作，自己下来就开始查阅各种资料和教程，还好任务上线问啥大问题。今天我就来记录一下自己是如何安装并配置一个web服务器。 Apache2.4.23安装下载打开Apache官网，选择左侧的Download-&gt;From a Mirror，在网页中可以看到最新的Apache HTTP Server,由于我实在win7系统中安装，因此选择Files for Microsoft Windows,点开后可以看到Apache HTTP服务器项目本身不提供二进制版本的软件，只有源代码。如果你自己不能编译Apache HTTP服务器，你可以选择这些官方推荐的第三方提供编译的网站。。布置在windows系统上比较常用的配置包括Apache httpd,PHP,MySQL ApacheHaus提供Apache独立安装包 Apache Lounge提供Apache独立安装包 BitNami WAMP Stack提供集成环境安装包 WampServer提供集成环境安装包 XAMPP提供集成环境安装包 今天我们选择在Apache Lounge提供的安装包为例做一次演示，打开网站后选择适合自己电脑（32位or64位）的安装包，下载下来后将其解压到H：/Apache24文件夹（安装路径自定义），在安装之前需要确认你的电脑是否已安装对应的VC环境，这里我使用的是VC2015，这个文件在Apache Lounge网站上也提供下载Be sure that you have installed the latest C++ Redistributable Visual Studio 2015 : vc_redist_x64/86.exe至此安装Apache所需文件已下载完，接下来进行安装 安装我们需要通过命令行进入Apahce24目录下的bin文件夹，并执行http -k install命令win+r输入cmd,在cmd窗口命令行中输入D:cd webservercd Apache24cd binhttpd -k install 执行完后我们可以看到Installing the 'Apache2.4' serviceThe 'Apache2.4' service is successfully installed.Testing httpd.conf....Errors reported here must be corrected before the service can be started.AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using fe80::d4a4:6f0f:a01b:afb. Set the 'ServerName' directive globally to suppress this message 这里报错提示是无法确定服务器域名，请修改http.conf文件中ServerName指令我们进入Apache24目录下的conf文件夹找到httpd.conf文件，用文本编辑器将其打开,找到ServerName指令（220行），这里将#注释去掉并将www.example:80修改为127.0.0.1:80。httd.conf文件中默认是将Apache安装在C盘的。所以需要修改以下路径：37行改为ServerRoot \"D:/webserver/Apache24\" 244行改为DocumentRoot \"H:/\"将文档等目录改为H盘244行改为&lt;Directory \"H:/\"&gt; 361行改为ScriptAlias /cgi-bin/ \"D:/webserver/Apache24/cgi-bin/\" 377行改为&lt;Directory \"D:/webserver/Apache24/cgi-bin\"&gt; 修改完成后我们执行httpd -k start没有任何提示，通过windows任务管理器我们可以看到Apache2.4正在运行此时我们在浏览器中输入localhost，回车，我们能看到It works！至此Apache已安装完成 PHP5.6.30安装下载打开PHP官网点击Downloads，这里我们选择PHP5.6.30版本，点击windows downloads,这里我们可以看到有Non Thread Safe 非线程安全与IIS搭配环境Thread Safe 线程安全与apache搭配的环境 这里我选择的是VC11 x86 Thread Safe，这里的VC11提示我们在安装PHP之前需要安装Visual C++ Redistributable for Visual Studio 2012，网页也提供了下载的链接x86 or x64,安装好后我们将下载的PHP5.6.30安装包解压到D:/webserver/PHP5 安装PHP解压后无需其他安装，只需修改相关文件即可：将php.ini-production文件改名为php.ini，并用文本编辑器将其打开做以下修改：第734行取消extension_dir = “ext”前面的”;”并将其改为绝对路径(D:webserver\\PHP5\\ext)这个是指向扩展库目录的路径第882行这里展示的是windows下的各种库文件，可以自己手动载入要用到的扩展，我一般载入以下扩展文件：php_fileinfo.dll libmagic库的一个封装，可以用来获得文件的一些信息php_gd2.dll GD库图像函数库php_mysql.dll MySQL函数库php_mysqli.dll MySQLi函数库php_pdo_mysql.dll PDO mysql库 去掉库文件前面的”;”即可载入相应的库文件。保存，退出，至此PHP安装完成 与Apache2.4.23整合在apache配置文件httpd.conf文件末尾添加以下内容；# php5 supportLoadModule php5_module D:/webserver/PHP5/php5apache2_4.dllAddType application/x-httpd-php .php .html .htm# configure the path to php.iniPHPIniDir \"D:/webserver/PHP5\" 这里是载入PHP5模块和指明PHP.ini的位置我们可以将以下代码保存为phpinfo.php文件，并放在文档根目录中这里是H:/，在浏览器中输入localhost/phpinfo.php回车即可看到已安装的PHP全部信息&lt;?php php.info() ?&gt; MySQL5.7.18安装在MySQL官网点击Downloads -&gt; windows -&gt; MySQL Installer.这里我们可以看到两个mysql安装器：mysql-installer-web-community 如果在有网络的环境上运行MySQL，建议选择这个mysql-installer-community 如果在没有网络的环境上运行MySQL，建议选择这个 这里我们选择mysql-installer-web-community，下载后双击运行即可，和一般的软件安装方式一样，这里我们选择自定义安装，选择安装了MySQL Server 5.7.18和MySQL Documentation 5.7.18,这里直接默认安装在C盘,具体详细图文安装教程可参考如何安装mysql5.7安装完成后我们win+r输入mysql，选择command line client - Unicode，我们可以看到提示我们输入自己设置的MySQL数据库密码，输完密码回车看到Welcome to the MySQL monitor.…… 至此MySQL安装成功如果通过cmd进入mysql,我们需要将“C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin”添加到系统环境变量中，可通过mysql -u root -p连接上数据库 注意这种安装方式配置文件和数据库文件在“C:\\ProgramData\\MySQL\\MySQL Server 5.7” 结束通过此次亲自安装实验，加深了对Apache服务器的了解，为下一步的服务器安全配置打下基础。目前只是初步安装完成，要想达到上线使用还有很多安全配置工作要做，在接下来的一篇博客中我将总结一下基本的安全配置工作。","tags":[{"name":"MySQL","slug":"mysql","permalink":"https://jesse121.github.io/tags/mysql/"},{"name":"PHP","slug":"php","permalink":"https://jesse121.github.io/tags/php/"},{"name":"Apache","slug":"apache","permalink":"https://jesse121.github.io/tags/apache/"}]},{"title":"《ECMAScript6标准入门》第二版--读书笔记","date":"2017-04-09T16:00:00.000Z","path":"articles/notes/ECMAScript-6-primer-2nd-edition.html","text":"2015年6月，ECMAScript 6正式通过，成为国际标准。尽管在目前的工作中还没有使用ES6，但是每项新技术出来总是忍不住想尝尝鲜，想知道ES6能为前端开发带来哪些变化？对自己的工作有哪些方面可以提升。刚好看到阮一峰的《ES6标准入门》，便顺着这本书尝试着ES6的各种新特性。ES6的各种新特性的兼容性查询http://kangax.github.io/compat-table/es6/尽管我们的浏览器还不一定完全支持ES6代码，我们可以使用Babel转码器,在这里我们使用命令行转码babel-cli，命令行$ npm install --global babel-cli安装babel-cli let和const命令let命令ES6新增了 let 命令，用来声明变量。它的用法类似于 var ，但是所声明的变量，只在 let 命令所在的代码块内有效。let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 ES6明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。let不允许在相同作用域内，重复声明同一个变量。let 实际上为JavaScript新增了块级作用域。 ES6引入了块级作用域，明确允许在块级作用域之中声明函数。 const命令const 声明一个只读的常量。一旦声明，常量的值就不能改变。const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。 const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变const foo = &#123;&#125;;foo.prop = 123;foo.prop //123 ES6规定var 命令和 function 命令声明的全局变量，依旧是全局对象的属性；let 命令、 const 命令、 class 命令声明的全局变量，不属于全局对象的属性。 变量的解构赋值数组的解构赋值let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3 解构赋值允许指定默认值。[x, y = 'b'] = ['a']; // x='a', y='b'[x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6内部使用严格相等运算符（ === ），判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined ，默认值是不会生效的。 对象的解构赋值var &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"var &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not defined 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 函数参数的解构赋值[[1, 2], [3, 4]].map(function([a,b])&#123; return a + b; &#125;)//[3,7] 变量解构赋值用途 交换变量的值[x, y] = [y, x]; 提取JSON数据 var jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 函数参数的默认值 jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true&#125;) &#123; // ... do stuff&#125;; 字符串的扩展includes(), startsWith(), endsWith()includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。var s = 'Hello world!';s.startsWith('world', 6); // trues.endsWith('Hello', 5); // trues.includes('Hello', 6); // false 使用第二个参数 n 时， endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。 repeat()返回一个新字符串，表示将原字符串重复 n 次。'hello'.repeat(2) // \"hellohello\" padStart()，padEnd()padStart 用于头部补全， padEnd 用于尾部补全。'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' padStart 和 padEnd 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。 模板字符串模板字符串（template string）是增强版的字符串，用反引号标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。var name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 数值的扩展从ES5开始，在严格模式之中，八进制就不再允许使用前缀 0 表示，ES6进一步明确，要使用前缀 0o 表示。 Number.isFinite()Number.isFinite() 用来检查一个数值是否非无穷（infinity）。Number.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // false Number.isNaN()Number.isNaN() 用来检查一个值是否为 NaN 。Number.isNaN(NaN) // trueNumber.isNaN(15) // false 它们与传统的全局方法 isFinite() 和 isNaN() 的区别在于，传统方法先调用 Number() 将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回 false 。 Number.parseInt(), Number.parseFloat()ES6将全局方法 parseInt() 和 parseFloat() ，移植到Number对象上面，行为完全保持不变。 Number.isInteger()Number.isInteger() 用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。 安全整数和Number.isSafeInteger()JavaScript能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个常量，用来表示这个范围的上下限。Number.isSafeInteger() 则是用来判断一个整数是否落在这个范围之内。 Math对象的扩展Math.trunc 方法用于去除一个数的小数部分，返回整数部分。Math.sign 方法用来判断一个数到底是正数、负数、还是零。Math.cbrt 方法用于计算一个数的立方根。Math.fround方法返回一个数的单精度浮点数形式。Math.hypot 方法返回所有参数的平方和的平方根。 数组的扩展Array.from()Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的 arguments 对象。 Array.from 都可以将它们转为真正的数组。// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments);// ...&#125; Array.of()Array.of 方法用于将一组值，转换为数组。Array.of(3, 11, 8) // [3,11,8] 数组实例的copyWithin()Array.prototype.copyWithin(target, start = 0, end = this.length) target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 [1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5] 数组实例的find()和findIndex()数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined 。[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1 。 数组实例的fill()fill 方法使用给定值，填充一个数组。['a', 'b', 'c'].fill(7)// [7, 7, 7] 数组实例的entries()，keys()和values()ES6提供三个新的方法—— entries() ， keys() 和 values() ——用于遍历数组。唯一的区别是 keys() 是对键名的遍历、 values() 是对键值的遍历， entries() 是对键值对的遍历。 函数的扩展函数参数的默认值ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。function log(x, y = 'World') &#123; console.log(x, y);&#125; 函数的length属性指定了默认值以后，函数的 length 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后， length 属性将失真。(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 rest参数 ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 扩展运算符扩展运算符（spread）是三个点（ … ）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5// ES5的写法Math.max.apply(null, [14, 3, 77])// ES6的写法Math.max(...[14, 3, 77]) 扩展运算符的应用 合并数组 var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 扩展运算符还可以将字符串转为真正的数组。 [...'hello']// [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 实现了Iterator接口的对象 var nodeList = document.querySelectorAll('div');var array = [...nodeList]; 箭头函数ES6允许使用“箭头”（ =&gt; ）定义函数。var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;; 箭头函数有几个使用注意点 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 不可以使用 yield 命令，因此箭头函数不能用作Generator函数。 对象的扩展属性的简洁表示法ES6允许在对象之中，只写属性名，不写属性值。这时属性值等于属性名所代表的变量。var Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; Object.assign()Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性Object.assign 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。Object.assign 方法有很多用处。 为对象添加属性 class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 为对象添加方法 Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;); 克隆对象 function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 合并多个对象 const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 为属性指定默认值 const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;function processContent(options) &#123; let options = Object.assign(&#123;&#125;, DEFAULTS, options);&#125; ES6属性的遍历5种方法 for…in 循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。 Object.keys(obj)返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。 Object.getOwnPropertyNames(obj)返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。 Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有Symbol属性。 Reflect.ownKeys(obj)返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。 SymbolES5的对象属性名都是字符串，这容易造成属性名的冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。注意，Symbol值作为对象属性名时，不能用点运算符。var mySymbol = Symbol();var a = &#123;&#125;;a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // \"Hello!\" 因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个Symbol值。Symbol作为属性名，该属性不会出现在 for…in 、 for…of 循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。Reflect.ownKeys 方法可以返回所有类型的键名，包括常规键名和Symbol键名。let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// [Symbol(my_key), 'enum', 'nonEnum'] Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个Symbol值， Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。Symbol.for(\"bar\") === Symbol.for(\"bar\")// trueSymbol(\"bar\") === Symbol(\"bar\")// falsevar s1 = Symbol.for(\"foo\");Symbol.keyFor(s1) // \"foo\"var s2 = Symbol(\"foo\");Symbol.keyFor(s2) // undefined Set和Map数据结构ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。var s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));for (let i of s) &#123;console.log(i);&#125;// 2 3 5 4 Set实例的属性和方法 Set.prototype.constructor ：构造函数，默认就是 Set 函数。 Set.prototype.size ：返回 Set 实例的成员总数。 add(value) ：添加某个值，返回Set结构本身。 delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。 has(value) ：返回一个布尔值，表示该值是否为 Set 的成员。 clear() ：清除所有成员，没有返回值。 Map结构的目的和基本用法JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键Map原生提供三个遍历器生成函数和一个遍历方法。 keys() ：返回键名的遍历器。 values() ：返回键值的遍历器。 entries() ：返回所有成员的遍历器。 forEach() ：遍历Map的所有成员。 Generator 函数Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。形式上，Generator函数是一个普通函数，但是有两个特征。一是， function关键字与函数名之间有一个星号；二是，函数体内部使用 yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; Promise对象基本用法var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise实例生成以后，可以用 then 方法分别指定 Resolved 状态和 Reject 状态的回调函数。var getJSON = function(url) &#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); Promise.prototype.then()then 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。then 方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。 Promise.prototype.catch()Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。一般来说，不要在 then 方法里面定义Reject状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。 Classclass Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5的构造函数 Point ，对应ES6的 Point 类的构造方法。由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。 Object.assign 方法可以很方便地一次向类添加多个方法。class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 constructor方法constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。constructor 方法默认返回实例对象（即 this ），完全可以指定返回另外一个对象。 Class的继承Class之间可以通过 extends 关键字实现继承class ColorPoint extends Point &#123;&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。Class不存在变量提升（hoist），这一点与ES5完全不同。new Foo(); // ReferenceErrorclass Foo &#123;&#125; Object.getPrototypeOf()Object.getPrototypeOf 方法可以用来从子类上获取父类。因此，可以使用这个方法判断，一个类是否继承了另一个类。 super关键字super 这个关键字，有两种用法，含义不同。 作为函数调用时（即 super(…args) ）， super 代表父类的构造函数。 作为对象调用时（即 super.prop 或 super.method() ）， super 代表父类。注意，此时 super 即可以引用父类实例的属性和方法，也可以引用父类的静态方法。 Class的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 编程风格 let取代var 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 函数的参数如果是对象的成员，优先使用解构赋值。 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 const a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 数组 使用扩展运算符（…）拷贝数组。const itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。 const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 函数 立即执行函数可以写成箭头函数的形式。 (() =&gt; &#123; console.log('Welcome to the Internet.');&#125;)(); 使用默认值语法设置函数参数的默认值。 总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 这些笔记只是看第一遍消化的，还有更多的内容需要对研究几遍才行。","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"对JavaScript中闭包的理解","date":"2017-03-07T23:15:23.000Z","path":"articles/javascript/对JavaScript中闭包的理解.html","text":"在前端开发中闭包是一个很重要的知识点，是面试中一定会被问到的内容。之前我对闭包的理解主要是”通过闭包可以在函数外部能访问到函数内部的变量”，对闭包运用的也很少，甚至自己写过闭包自己都不太清楚，只知道这样写可以解决问题。最近在梳理自己的js知识点，发现自己对js闭包理解的很不透彻，于是想全面的分析一下闭包，特别是闭包的形成原因和闭包的使用场景。 闭包的定义闭包是指有权访问另一个函数作用域中的变量的函数 –《JavaScript高级程序设计》 函数对象可以通过作用域关联起来，函数体内的变量都可以保存在函数作用域内，这在计算机科学文献中称为“闭包”,所有的javascirpt函数都是闭包 –《Javascript权威指南》 看完这些专业的定义是不是感觉一头雾水，没关系，我和一样也没明白这些定义说的是啥，咱接着往下分析。 在认识闭包原理之前我们先必须对作用域、执行上下文、执行上下文堆栈、变量对象、活动对象、作用域链有着全面的认识 作用域 Scope作用域是一套规则，用于确定在何处以及如何查找变量(标识符)作用域共有两种主要的工作模型： 词法作用域：作用域是在编写代码的时候确定的 动态作用域：作用域是在代码运行的时候确定的 我们知道javascript使用的是词法作用域 执行上下文 Execution ContextsJavascript中代码的执行上下文分为以下三种： 全局级别的代码 – 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。 函数级别的代码 – 当执行一个函数时，运行函数体中的代码。 Eval的代码 – 在Eval函数内运行的代码。 一个执行的上下文可以抽象的理解为一个对象。每一个执行的上下文都有一系列的属性(变量对象(variable object)，this指针(this value)，作用域链(scope chain) )Execution Contexts = &#123; variable object：变量对象; this value: this指针; scope chain：作用域链;&#125; 执行上下文堆栈 Execution Contexts Stack活动的执行上下文组在逻辑上组成一个堆栈。堆栈底部永远都是全局上下文(globalContext)，而顶部就是当前(活动的)执行上下文。&lt;script&gt;function add(num)&#123; var sum = 5; return sum + num;&#125;var sum = add(4);&lt;/script&gt; 当add函数被调用时，add函数执行上下文被压入执行上下文堆栈的顶端，此时执行上下文堆栈可表示为：EC Stack = [ &lt;add&gt; functionContext globalContext]; add函数执行完毕后，其执行上下文将会从执行上下文堆栈顶端弹出并被销毁。全局执行上下文只有在浏览器关闭时才会从执行上下文堆栈中销毁 变量对象 Variable Object如果变量与执行上下文相关，那变量自己应该知道它的数据存储在哪里，并且知道如何访问。这种机制称为变量对象(variable object)。可以说变量对象是与执行上下文相关的数据作用域(scope of data) 。它是与执行上下文关联的特殊对象，用于存储被定义在执行上下文中的变量(variables)、函数声明(function declarations) 。当进入全局上下文时，全局上下文的变量对象可表示为：VO = &#123; add: &lt;reference to function&gt;, sum: undefined, Math: &lt;...&gt;, String: &lt;...&gt; ... window: global //引用自身&#125; 活动对象 Activation Object当函数被调用者激活时，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。当add函数被调用时，add函数执行上下文被压入执行上下文堆栈的顶端，add函数执行上下文中活动对象可表示为AO = &#123; num: 4, sum :5, arguments:&#123;0:4&#125;&#125; 作用域链 Scope Chain函数上下文的作用域链在函数调用时创建的，包含活动对象AO和这个函数内部的[[scope]]属性。var x = 10;function foo() &#123; var y = 20; function bar() &#123; var z = 30; alert(x + y + z); &#125; bar();&#125;foo(); 在这段代码中我们看到变量”y”在函数”foo”中定义（意味着它在foo上下文的AO中）”z”在函数”bar”中定义，但是变量”x”并未在”bar”上下文中定义，相应地，它也不会添加到”bar”的AO中。乍一看，变量”x”相对于函数”bar”根本就不存在；函数”bar”如何访问到变量”x”？理论上函数应该能访问一个更高一层上下文的变量对象。实际上它正是这样，这种机制是通过函数内部的[[scope]]属性来实现的。[[scope]]是所有父级变量对象的层级链，处于当前函数上下文之上，在函数创建时存于其中。 注意: [[scope]]在函数创建时被存储是静态的（不变的），直至函数销毁。即：函数可以永不调用，但[[scope]]属性已经写入，并存储在函数对象中。在这里我们逐步分析下全局上下文的变量对象是：globalContext.VO === Global = &#123; x: 10 foo: &lt;reference to function&gt;&#125;; 在”foo”创建时，”foo”的[[scope]]属性是：foo.[[Scope]] = [ globalContext.VO]; 在”foo”激活时（进入上下文），”foo”上下文的活动对象是：fooContext.AO = &#123; y: 20, bar: &lt;reference to function&gt;&#125;; “foo”上下文的作用域链为：fooContext.Scope = [ fooContext.AO, globalContext.VO]; 内部函数”bar”创建时，其[[scope]]为：bar.[[Scope]] = [ fooContext.AO, globalContext.VO]; 在”bar”激活时，”bar”上下文的活动对象为：barContext.AO = &#123; z: 30&#125;; “bar”上下文的作用域链为：bar.Scope= [ barContext.AO, fooContext.AO, globalContext.VO]; 介绍了一大堆内容，是不是有点晕忽忽的？坚持一下，下面是重点 闭包的原理我们通过一个闭包的例子来分析一下闭包的形成原理function add()&#123; var sum =5; var func = function () &#123; console.log(sum); &#125; return func;&#125;var addFunc = add();addFunc(); //5 js执行流进入全局执行上下文环境时,全局执行上下文可表示为：globalContext = &#123; VO: &#123; add: &lt;reference to function&gt;, addFunc: undefined &#125;, this: window, scope chain: window &#125; 当add函数被调用时，add函数执行上下文可表示为：addContext = &#123; AO: &#123; sum: undefined //代码进入执行阶段时此处被赋值为5 func: undefined //代码进入执行阶段时此处被赋值为function ()&#123;console.log(sum);&#125; &#125;, this: window, scope chain: addContext.AO + globalContext.VO &#125; add函数执行完毕后，js执行流回到全局上下文环境中，将add函数的返回值赋值给addFunc。 由于addFunc仍保存着func函数的引用，所以add函数执行上下文从执行上下文堆栈顶端弹出后并未被销毁而是保存在内存中。 当addFunc()执行时，func函数被调用，此时func函数执行上下文可表示为:funcContext = &#123; this: window, scope chain: addContext.AO + globalContext.VO &#125; 当要访问变量sum时，func的活动对象中未能找到，则会沿着作用域链查找，由于js遵循词法作用域，作用域在函数创建阶段就被确定，在add函数的活动对象中找到sum = 5; 介绍到这里你明白形成闭包的原因了吗？Javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 1. 保护变量的安全实现JS私有属性和私有方法利用闭包可以读取函数内部的变量，变量在函数外部不能直接读取到，从而达到保护变量安全的作用。因为私有方法在函数内部都能被访问到，从而实现了私有属性和方法的共享。常见的模块模式就是利用闭包的这种特性建立的var Counter = (function() &#123; //私有属性 var privateCounter = 0; //私有方法 function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125; &#125;)();console.log(privateCounter); //privateCounter is not defined console.log(Counter.value()); // 0Counter.increment();Counter.increment();console.log(Counter.value()); // 2Counter.decrement();console.log(Counter.value()); // 1 在jQuery框架的私有方法和变量也是这么设计的var $ = jQuery = function()&#123; return jQuery.fn.init();&#125;jQuery.fn = jQuery.prototype = &#123; init:function()&#123; return this; //this指向jQuery.prototype &#125;, length: 1, size: function()&#123; return this.length; &#125;&#125;console.log($().size()); // 1 2. 将处理结果缓存var CachedSearchBox = (function()&#123; var cache = &#123;&#125;,count = []; return &#123; attachSearchBox : function(dsid)&#123; if(dsid in cache)&#123;//如果结果在缓存中 return cache[dsid];//直接返回缓存中的对象 &#125; var fsb = new uikit.webctrl.SearchBox(dsid);//新建 cache[dsid] = fsb;//更新缓存 if(count.length &gt; 100)&#123;//保正缓存的大小&lt;=100 delete cache[count.shift()]; &#125; return fsb; &#125; &#125;; &#125;)(); CachedSearchBox.attachSearchBox(\"input\"); 这样我们在第二次调用的时候，就会从缓存中读取到该对象。 理解了闭包的原理我们发现闭包的这些用途都是利用了闭包保存了当前函数的活动对象的特点，这样闭包函数在作用域之外被调用时依然能够访问其创建时的作用域 闭包的缺点 闭包将函数的活动对象维持在内存中，过度使用闭包会导致内存占用过多，所以在使用完后需要将保存在内存中的活动对象解除引用； 闭包只能取得外部函数中任何变量的最后一个值，在使用循环且返回的函数中带有循环变量时会得到错误结果； 当返回的函数为匿名函数时，注意匿名函数中的this指的是window对象。 这里仅仅是我对闭包的一些见解，若有错误的地方，还望大家提出，一起交流共同进步！参考文献 《你不知道的JavaScript》上卷 深入理解JavaScript系列","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"ECMAScript5新特性总结","date":"2017-03-04T15:00:00.000Z","path":"articles/javascript/ECMAScript5新特性.html","text":"虽然ECMAScript5早就成为标准推出来了，但之前因为一直用的是ECMAScript3,并且工作中总是要求兼容IE的低版本，所以用的比较少。如今市场上大多数浏览器都能兼容ECMAScript5(IE8除外)，逐渐的就用的比较多了。今天主要是把ECMAScript5中新增奶的特性及方法总结一下，已备需要时方便查询。ECMAScript5的兼容性可参见http://kangax.github.io/compat-table/es5/ 严格模式（Strict Mode）是ECMAScript 5的新特性，它允许你把整个程序，或者某个函数，放置在“严格”的操作语境中。这种严格的语境会防止某些特定的操作并抛出更多的异常。严格模式下主要变化有： 未使用var创建的变量会报错 函数顶层的this不在指向window，而是undefined 强制为eval创建新作用域 禁止用delete删除变量 禁止使用arguments,callee,caller属性 禁止使用width语句 禁止函数参数重名 禁止对象属性重名 禁止使用八进制数字 不允许在非函数的代码块内声明函数。 新增保留字：implements, interface, let, package, private, protected, public, static, yield。 Object新增方法：Object.create()创建一个具有指定原型且可选择性地包含指定属性的对象 Object.create(proto, [ propertiesObject ]) proto:一个对象，作为新创建对象的原型。或者为 null。propertiesObject:可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。示例：//Shape - superclassfunction Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info(\"Shape moved.\");&#125;;// Rectangle - subclassfunction Rectangle() &#123; Shape.call(this); //call super constructor.&#125;Rectangle.prototype = Object.create(Shape.prototype);var rect = new Rectangle();rect instanceof Rectangle //true.rect instanceof Shape //true.rect.move(1, 1); //Outputs, \"Shape moved.\" Object.getPrototypeOf()返回该对象的原型(也就是该对象内部属性[[prototype]]的值) Object.getPrototypeOf(object) 在 ES5 中，如果参数不是一个对象类型，将抛出一个 TypeError 异常。在ES6中，参数被强制转换为Object。示例：var proto = &#123;&#125;;var obj = Object.create(proto);Object.getPrototypeOf(obj) === proto; // true Object.getOwnPropertyNames()返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。 Object.getOwnPropertyNames(obj) obj:一个对象，其自身的可枚举和不可枚举属性的名称被返回。示例：var arr = [\"a\", \"b\", \"c\"];console.log(Object.getOwnPropertyNames(arr).sort()); // [\"0\", \"1\", \"2\", \"length\"] Object.defineProperty()直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。 Object.defineProperty(obj, prop, descriptor) obj:需要定义属性的对象。prop:需定义或修改的属性的名字。descriptor:将被定义或修改的属性的描述符。示例：Object.defineProperty(obj, \"key\", &#123; enumerable: false, configurable: false, writable: false, value: \"static\"&#125;); Object.defineProperties()在一个对象上添加或修改一个或者多个自有属性，并返回该对象。 Object.defineProperties(obj, props) obj:将要被添加属性或修改属性的对象props:该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置示例：var obj = &#123;&#125;;Object.defineProperties(obj, &#123; \"property1\": &#123; value: true, writable: true &#125;, \"property2\": &#123; value: \"Hello\", writable: false &#125;&#125;);console.log(obj) //&#123;property1:true,property2:\"Hello\"&#125; Object.getOwnPropertyDescriptor()指定对象上一个自有属性对应的属性描述符（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）。如果指定的属性存在于对象上，则返回其属性描述符（property descriptor），否则返回 undefined。 Object.getOwnPropertyDescriptor(obj, prop) obj:在该对象上查看属性prop:一个属性名称，该属性的属性描述符将被返回示例：var o, d;o = &#123; bar: 42 &#125;;d = Object.getOwnPropertyDescriptor(o, &quot;bar&quot;);console.log(d);//&#123; configurable: true, enumerable: true, value: 42, writable: true &#125; Object.seal()可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。 Object.seal(obj) Object.freeze()可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。 Object.freeze(obj) Object.preventExtensions()让一个对象变的不可扩展，也就是永远不能再添加新的属性。 Object.preventExtensions(obj) Object.isExtrensible()判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。 Object.isExtensible(obj) 示例：// 新对象默认是可扩展的.var empty = &#123;&#125;;Object.isExtensible(empty); // === true// ...可以变的不可扩展.Object.preventExtensions(empty);Object.isExtensible(empty); // === false Object.isSealed()判断一个对象是否是密封的（sealed）。 Object.isSealed(obj) 示例：// 新建的对象默认不是密封的.var empty = &#123;&#125;;Object.isSealed(empty); // === false// 如果你把一个空对象变的不可扩展,则它同时也会变成个密封对象.Object.preventExtensions(empty);Object.isSealed(empty); // === true Object.isFrozen()判断一个对象是否被冻结（frozen）。 Object.isFrozen(obj) Object.keys()返回一个由给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。 Object.keys(obj) 示例：var arr = [\"a\", \"b\", \"c\"];console.log(Object.keys(arr));// [ '0', '1', '2' ] Object.prototype新增方法Object.prototype.isPrototypeOf()用于测试一个对象是否存在于另一个对象的原型链上。 Obj.prototype.isPrototypeOf(object) object:在该对象的原型链上搜寻示例：var arr = [];console.log(arr instanceof Array);//trueconsole.log(Array.prototype.isPrototypeOf(arr));//true isPrototypeOf 和 instanceof operator 是不一样的。在表达式 object instanceof AFunction 中，检测的是 AFunction.prototype 是否在object 的原型链中，而不是检测 AFunction 自身。 Object.prototype.propertyIsEnumerable()返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性。 obj.propertyIsEnumerable(prop) 示例：var o = &#123;&#125;;o.prop = 'is enumerable';o.propertyIsEnumerable('prop'); // 返回 true Function.prototype新增方法Function.prototype.bind()bind()方法会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的 this, 之后的一序列参数将会在传递的实参前传入作为它的参数。 fun.bind(thisArg[, arg1[, arg2[, ...]]]) thisArg:当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。arg1, arg2, …:当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 示例：this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，\"this\"指向全局作用域// 创建一个新函数，将\"this\"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 Array新增方法：Array.isArray()该方法适用于确定传递的值是否为Array。 Array.isArray(obj) 示例：Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(\"foobar\"); // falseArray.isArray(undefined); // false 位置方法： Array.prototype.indexOf()返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回-1。 arr.indexOf(searchElement) 示例：var a = [2, 9, 9]; a.indexOf(2); // 0 Array.prototype.lastIndexOf()返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1]) searchElement:被查找的元素。fromIndex:从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 示例：var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);//3 迭代方法： Array.prototype.every()测试数组的所有元素是否都通过了指定函数的测试。every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。 arr.every(callback[, thisArg]) callback:用来测试每个元素的函数。thisArg:执行 callback 时使用的 this 值。 示例：function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// true Array.prototype.some()测试数组中的某些元素是否通过了指定函数的测试。some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。 arr.some(callback[, thisArg]) 示例：function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [2, 5, 8, 1, 4].some(isBigEnough);// passed is falsepassed = [12, 5, 8, 1, 4].some(isBigEnough);// passed is true Array.prototype.filter()使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。 var new_arrary = arr.filter(callback[, thisArg]) 示例：function isBigEnough(value) &#123; return value &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);//[12, 130, 44] Array.prototype.forEach()方法对数组的每个元素执行一次提供的函数。 array.forEach(callback[, thisArg]) 示例：var a = ['a', 'b', 'c'];a.forEach(function(element) &#123; console.log(element);&#125;);// a// b// c forEach() 为每个数组元素执行callback函数；不像map() 或者reduce() ，它总是返回 undefined值，并且不可链式调用。 Array.prototype.map()创建一个新数组，其结果是该数组中的每个元素调用一个提供的函数。map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 var new_array = arr.map(callback[, thisArg]) 示例：var numbers = [1, 5, 10, 15];var roots = numbers.map(function(x) &#123; return x * 2;&#125;);// roots is now [2, 10, 20, 30]// numbers is still [1, 5, 10, 15] 归并方法： Array.prototype.reduce()对累加器和数组的每个值 (从左到右)应用一个函数，以将其减少为单个值。 arr.reduce(callback,[initialValue]) callback:执行数组中每个值的函数，包含四个参数accumulator:上一次调用回调返回的值，或者是提供的初始值（initialValue）currentValue:数组中正在处理的元素currentIndex:数据中正在处理的元素索引，如果提供了 initialValue ，从0开始；否则从1开始array:调用 reduce 的数组initialValue:可选项，其值用于第一次调用 callback 的第一个参数。 示例：var sum = [0, 1, 2, 3].reduce(function(acc, val) &#123; return acc + val;&#125;, 0);console.log(sum);// 6 Array.prototype.reduceRight();reduceRight() 方法接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反） arr.reduceRight(callback[, initialValue]) 示例：var flattened = [[0, 1], [2, 3], [4, 5]].reduceRight(function(a, b) &#123; return a.concat(b);&#125;, []);// flattened is [4, 5, 2, 3, 0, 1] StringString.trim()会删除一个字符串两端的空白字符。 var newStr = str.trim() 示例：var orig = ' foo ';console.log(orig.trim()); // 'foo' DateDate.now()返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数。 var timeInMs = Date.now(); IE8及以下可以用以下代码来兼容：if (!Date.now) &#123; Date.now = function now() &#123; return new Date().getTime(); &#125;;&#125; Date.prototype.toISOString()返回一个 ISO（ISO 8601 Extended Format）格式的字符串： YYYY-MM-DDTHH:mm:ss.sssZ。时区总是UTC（协调世界时），加一个后缀“Z”标识。 dateObj.toISOString() 示例：var today = new Date(\"05 October 2011 14:48 UTC\");console.log(today.toISOString()); // 返回2011-10-05T14:48:00.000Z JSONJSON.parse()解析一个JSON字符串，构造由字符串描述的JavaScript值或对象。可以提供可选的reviver函数以在返回之前对所得到的对象执行变换。 JSON.parse(text[, reviver]) text:要被解析成JavaSctipt值的字符串，查看 JSON 对象学习的JSON 语法的说明。reviver: 可选,如果是一个函数，则规定了原始值如何被解析改造，在被返回之前。 示例：JSON.parse('&#123;\"name\" : \"jesse\",\"age\":25 &#125;');//&#123; name: 'jesse', age: 25 &#125; JSON.stringfy()JSON.stringify() 方法将JavaScript值转换为JSON字符串 JSON.stringify(value[, replacer [, space]]) 示例：JSON.stringify(&#123; name: 'jesse', age: 25 &#125;);//&#123;\"name\":\"jesse\",\"age\":25&#125;","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"原生Javascript操作DOM方法汇总","date":"2017-02-28T15:00:00.000Z","path":"articles/javascript/原生JavaScript操作DOM方法汇总.html","text":"自从接触到jQuery之后顿时就被jQuery的简洁且连续调用的方式吸引，在之后的前端开发中一直使用jQuery。用久了之后就越想弄清楚jQuery的源码，研究过源码之后才弄清楚原来他的本质还是javascript,很多常用的方法还是用js的基本方法写的。包装过后的js虽然使用方便，但是性能却打了折扣。例如用$(‘#demo’)获取id为demo的节点需要经过各种判断排除其他最终还是用document.getElementById(‘demo’)获取的节点，所以觉得还是使用原生的js靠谱，毕竟这个才是根本。 在讲解操作DOM的api之前，首先我们来复习一下一些基本概念，这些概念是掌握api的关键，必须理解它们。 Node类型DOM1级定义了一个Node接口，该接口由DOM中所有节点类型实现。这个Node接口在JS中是作为Node类型实现的。在IE9以下版本无法访问到这个类型，JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法。每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：Node.ELEMENT_NODE:1Node.ATTRIBUTE_NODE:2Node.TEXT_NODE:3Node.CDATA_SECTION_NODE:4Node.ENTITY_REFERENCE_NODE:5Node.ENTITY_NODE:6Node.PROCESSING_INSTRUCTION_NODE:7Node.COMMENT_NODE:8Node.DOCUMENT_NODE:9Node.DOCUMENT_TYPE_NODE:10Node.DOCUMENT_FRAGMENT_NODE:11Node.NOTATION_NODE:12 假设我们要判断一个Node是不是元素，我们可以这样判断if(someNode.nodeType == 1)&#123;console.log(\"Node is a element\");&#125; 这些Node类型中，我们最常用的就是element，text，attribute，comment，document，document_fragment这几种类型。我们简单来介绍一下这几种类型： Element类型Element类型用于表现XML或HTML元素，提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。Element有下面几条特性： nodeType为1 nodeName为元素标签名，tagName也是返回标签名 nodeValue为null parentNode可能是Document或Element 子节点可能是Element，Text，Comment，Processing_Instruction，CDATASection或EntityReference Text类型Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。Text有下面的特性： nodeType为3 nodeName为”#text” nodeValue为文本内容 parentNode是一个Element 没有子节点 Attr类型Attr类型表示元素的特性，相当于元素的attributes属性中的节点，它有下面的特性： nodeType值为2 nodeName是特性的名称 nodeValue是特性的值 parentNode为null Document类型Javascript通过Document类型表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。Document有下面的特性： nodeType为9 nodeName为”#document” nodeValue为null parentNode为null 子节点可能是一个DocumentType或Element Comment类型Comment表示HTML文档中的注释，它有下面的几种特征： nodeType为8 nodeName为”#comment” nodeValue为注释的内容 parentNode可能是Document或Element 没有子节点 DocumentFragment类型DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。DocumentFragment有下面的特性： nodeType为11 nodeName为”#document-fragment” nodeValue为null parentNode为null 我们简单地介绍了几种常见的Node类型，要记住，HTML中的节点并不只是包括元素节点，它还包括文本节点，注释节点等等。在这里我们只是简单地说明了几种常见的节点，想要进一步学习的同学可以查找一下相关资料，下面我们来介绍本文的重点各种操作Dom的API。 节点创建型API在这里，我将常用的DOM操作api进行分类，首先要介绍的是创建型的api。这一类型的api，简而言之就是用来创建节点的。 document.createElement()这个方法只接受一个参数，既要创建的标签名，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。用法如下： var div = document.createElement(&quot;div&quot;); 使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild()或insertBefore()或replaceChild()等方法将其添加到HTML文档树中。 docuemnt.createTextNode()createTextNode用来创建一个文本节点，用法如下： var textNode = document.createTextNode(&quot;Hello World!&quot;); createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中 cloneNode()cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，true用来表示复制本身节点及整个子节点树，false表示只复制本身节点，使用如下：var parent = document.getElementById(\"parentElement\");var parent2 = parent.cloneNode(true);// 传入trueparent2.id = \"parent2\"; 这段代码通过cloneNode复制了一份parent元素，其中cloneNode的参数为true，表示parent的子节点也被复制，如果传入false，则表示只复制了parent节点。我们看看这个例子var parent = document.getElementById(\"parent\");document.getElementById(\"btnCopy\").onclick = function()&#123; var parent2 = parent.cloneNode(true); parent2.id = \"parent2\"; document.body.appendChild(parent2);&#125; 这段代码很简单，主要是绑定button事件，事件内容是复制了一个parent，修改其id，然后添加到文档中。这里有几点要注意： 和createElement一样，cloneNode创建的节点只是游离有html文档外的节点，要调用appendChild方法才能添加到文档树中 如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id 调用接收的bool参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同 除此之外，我们还有一个需要注意的点：如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论：（1）如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件（2）如果是内联方式绑定比如&lt;div onclick=&quot;showParent()&quot;&gt;&lt;/div&gt;这样的话，副本节点同样会触发事件。 document.createDocumentFragment()在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中。该方法主要是用于添加大量节点到文档中时。假设要循环一组数据，然后创建多个节点添加到文档中，比如示例document.getElementById(\"btnAdd\").onclick = function()&#123; var list = document.getElementById(\"list\"); for(var i = 0;i &lt; 100; i++)&#123; var li = document.createElement(\"li\"); li.textContent = i; list.appendChild(li); &#125;&#125; 这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。这个时候，就是使用createDocumentFragment了。DocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。我们修改上面的代码如下：document.getElementById(\"btnAdd\").onclick = function()&#123; var list = document.getElementById(\"list\"); var fragment = document.createDocumentFragment(); for(var i = 0;i &lt; 100; i++)&#123; var li = document.createElement(\"li\"); li.textContent = i; fragment.appendChild(li); &#125; list.appendChild(fragment);&#125; 优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list. 节点创建型API总结创建型api主要包括document.createElement()，document.createTextNode()，cloneNode()和document.createDocumentFragment()四个方法，需要注意下面几点： 它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中 cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题 使用createDocumentFragment来解决添加大量节点时的性能问题 页面修改型API前面我们提到创建型api，它们只是创建节点，并没有真正修改到页面内容，而是要调用appendChild来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。修改页面内容的api主要包括：appendChild()，insertBefore()，removeChild()，replaceChild()。 appendChild()appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。调用方法如下： parent.appendChild(child); child节点将会作为parent节点的最后一个子节点。appendChild这个方法很简单，但是还有一点需要注意：如果被添加的节点是一个页面中已经存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方。我们来看例子&lt;div id=\"child\"&gt; 要被添加的节点&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;div id=\"parent\"&gt; 要移动的位置&lt;/div&gt; &lt;input id=\"btnMove\" type=\"button\" value=\"移动节点\" /&gt;document.getElementById(\"btnMove\").onclick = function()&#123; var child = document.getElementById(\"child\"); document.getElementById(\"parent\").appendChild(child);&#125; 这段代码主要是获取页面上的child节点，然后添加到指定位置，可以看到原本的child节点被移动到parent中了。这里还有一个要注意的点：如果child绑定了事件，被移动时，它依然绑定着该事件。 insertBefore()insertBefore用来添加一个节点到一个参照节点之前，用法如下： parentNode.insertBefore(newNode,refNode); parentNode表示新节点被添加后的父节点newNode表示要添加的节点refNode表示参照节点，新节点会添加到这个节点之前我们来看这个例子&lt;div id=\"parent\"&gt; 父节点 &lt;div id=\"child\"&gt; 子元素 &lt;/div&gt;&lt;/div&gt;&lt;input type=\"button\" id=\"insertNode\" value=\"插入节点\" /&gt;var parent = document.getElementById(\"parent\");var child = document.getElementById(\"child\");document.getElementById(\"insertNode\").onclick = function()&#123; var newNode = document.createElement(\"div\"); newNode.textContent = \"新节点\" parent.insertBefore(newNode,child);&#125; 这段代码创建了一个新节点，然后添加到child节点之前。和appendChild一样，如果插入的节点是页面上的节点，则会移动该节点到指定位置，并且保留其绑定的事件。 关于第二个参数参照节点还有几个注意的地方： refNode是必传的，如果不传该参数会报错 如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾 removeChild()removeChild顾名思义，就是删除指定的子节点并返回该节点，用法如下： var deletedChild = parent.removeChild(node); deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除：if(node.parentNode)&#123; node.parentNode.removeChild(node);&#125; 通过节点自己获取节点的父节点，然后将自身删除。 replaceChild()replaceChild用于使用一个节点替换另一个节点，用法如下 parent.replaceChild(newChild,oldChild); newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置oldChild是被替换的节点 页面修改型API总结页面修改型api主要是这四个接口，要注意几个特点： 不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置 节点本身绑定的事件会不会消失，会一直保留着。 节点查询型API节点查询型API也是非常常用的api，下面我们分别说明一下每一个api的使用。 document.getElementById()这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。使用这个接口有几点要注意： 元素的id是大小写敏感的，一定要写对元素的id HTML文档中可能存在多个id相同的元素，则返回第一个元素 只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的 document.querySelector()document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素。我们来看这个例子：&lt;div&gt; &lt;div&gt; &lt;span class=\"test\"&gt;第三级的span&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"test\"&gt; 同级的第二个div&lt;/div&gt;&lt;input type=\"button\" id=\"btnGet\" value=\"获取test元素\" /&gt;document.getElementById(\"btnGet\").addEventListener(\"click\",function()&#123; var element = document.querySelector(\".test\"); alert(element.textContent);&#125;) 这个例子很简单，就是两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素。 document.querySelectorAll()document.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符，我们来看看下面这个例子 &lt;div class=\"test\"&gt; class为test&lt;/div&gt;&lt;div id=\"test\"&gt; id为test&lt;/div&gt;&lt;input id=\"btnShow\" type=\"button\" value=\"显示内容\" /&gt;document.getElementById(\"btnShow\").addEventListener(\"click\",function()&#123; var elements = document.querySelectorAll(\"#test,.test\"); for(var i = 0,length = elements.length;i&lt;length;i++)&#123; alert(elements[i].textContent); &#125; &#125;) 这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点： querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关 返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化 兼容性问题：querySelector()和querySelectorAll()在ie8以下的浏览器不支持。 document.getElementsByClassName()这个API是根据元素的class返回一个即时的HTMLCollection，用法如下 var elements = document.getElementsByClassName(names); 这个接口有下面几点要注意： 返回结果是一个即时的HTMLCollection，会随时根据文档结构变化 IE9以下浏览器不支持 如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如 var elements = document.getElementsByClassName(&quot;test1 test2&quot;); document.getElementsByTagName()这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型，什么是即时的HTMLCollection类型呢？我们来看看这个示例&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt; &lt;input type=\"button\" value=\"新增div\" id=\"btnAddDiv\"/&gt; &lt;input type=\"button\" value=\"显示数量\" id=\"btnShowCount\"/&gt;var divList = document.getElementsByTagName(\"div\");document.getElementById(\"btnAddDiv\").onclick = function()&#123; var div = document.createElement(\"div\"); div.textContent =\"div\" + (divList.length+1); document.body.appendChild(div);&#125; document.getElementById(\"btnShowCount\").onclick = function()&#123; alert(divList.length);//3&#125; 这段代码中有两个按钮，一个按钮可以新增一个div标签到文档中，另一个按钮是显示HTMLCollection元素的个数。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div。使用document.getElementsByTagName这个方法有几点要注意： 如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率 如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection “*”表示所有标签 document.getElementsByName()getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。使用这个接口主要要注意几点： 返回对象是一个即时的NodeList，它是随时变化的 在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的 在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name 其他特殊方法document.images:返回文档中所有的img元素documents.forms：返回文档中所有的form元素documents.links:返回文档中所有带href属性的a元素 以上方法都用的比较少 节点关系型API在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等，下面我们依次来看看每一种关系。 父级关系型apiparentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null 兄弟关系型apipreviousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。 子级关系型apichildNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。hasChildNodes()方法：可以用来判断是当前节点是否包含子节点。如果当前元素节点拥有子节点，则 hasChildNodes() 返回 true，否则返回 false。children：一个即时的HTMLCollection，子节点都是Element，IE6-8支持该属性，但是可能会错误地包含注释节点.firstChild：返回当前元素的第一个子节点lastChild：返回当前元素的最后一个子节点 元素属性型APIsetAttribute()setAttribute：根据名称和值修改元素的特性，用法如下。 element.setAttribute(name, value); 其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。如果元素本身包含指定的特性名为属性，则可以世界访问属性进行赋值，比如下面两条代码是等价的：element.setAttribute(\"id\",\"test\");element.id = \"test\"; getAttribute()getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。用法如下： var value = element.getAttribute(&quot;id&quot;); removeAttribute()element.removeAttribute(attrName) removeAttribute用于彻底删除元素的特性，并不常用 元素样式型APIwindow.getComputedStyle()window.getComputedStyle是用来获取应用到元素后的样式，假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle，用法如下： var style = window.getComputedStyle(element[, pseudoElt]); element是要获取的元素，pseudoElt指定一个伪元素进行匹配。返回的style是一个CSSStyleDeclaration对象。通过style可以访问到元素计算后的样式 element.getBoundingClientRect()getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下： var clientRect = element.getBoundingClientRect(); clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据，具体可查看链接Element.getBoundingClientRect() 参考文章： Javascript操作DOM常用API总结 《Javascript高级程序设计》","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"Javascript几种跨域方式总结","date":"2017-02-26T15:00:00.000Z","path":"articles/javascript/JavaScript跨域方式总结.html","text":"在客户端编程语言中如javascript，同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。只有当两个域具有相同的协议，相同的主机，相同的端口时，我们就认定他们是相同的域。可是在实际开发中我们经常需要获取其他域的资源，这个时候各种不同的跨域资源方式就各显神通了，今天主要来总结一下工作中常用的几种跨域方式，以备查询。 1.window.namewindow 对象的name属性是一个很特别的属性，当在 frame 中加载新页面时，name 的属性值依旧保持不变。那么我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，此时 name 属性值可被获取到，以访问 Web 服务发送的信息。但 name 属性仅对相同域名的 frame 可访问。这意味着为了访问 name 属性，当远程 Web 服务页面被加载后，必须导航 frame 回到原始域。即页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。一旦 name 属性获得，销毁 frame 。这个方式非常适合单向的数据请求，而且协议简单、安全。 页面B(www.jesse.com/data.html)代码如下：&lt;script type=\"text/javascript\"&gt;window.name = 'I was there!';// 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右// 数据格式可以自定义，如json、字符串&lt;/script&gt; 页面A(www.jack.com/index.html)代码如下：&lt;script type=\"text/javascript\"&gt;var state = 0, iframe = document.createElement('iframe'), loadfn = function() &#123; if (state === 1) &#123; var data = iframe.contentWindow.name; // 读取数据 console.log(data); //弹出'I wasthere!' (function()&#123; //获取数据以后销毁这个iframe。 iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;)(); &#125; else if (state === 0) &#123; state = 1; // 设置的代理页面使其回原始域 iframe.contentWindow.location = \"http://www.jack.com/proxy.html\"; &#125; &#125;;iframe.src = 'http://www.jesse.com/data.html';if (iframe.attachEvent) &#123; iframe.attachEvent('onload', loadfn);&#125; else &#123; iframe.onload = loadfn;&#125;document.body.appendChild(iframe);&lt;/script&gt; 2.具备src的标签虽然浏览器默认禁止了跨域访问，但并不禁止在页面中用标签的src属性引用其他域的文件。根据这一点，可以方便地通过创建具有src属性的节点方法来实现完全跨域的通信。使用这种原理的跨域方式有以下几种： 动态创建script例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。 pageA(www.jack.com/index.html)代码如下：function getData(data)&#123; //这里是对获取的数据的相关操作 console.log(data); //数据获取到后移除创建的script标签 document.body.removeChild(originData);&#125;var originData = document.createElement('script');originData.src = 'http://www.jesse.com/data.js';originData.setAttribute(\"type\", \"text/javascript\");document.body.appendChild(originData); pageB(www.jesse.com/data.js)代码如下：getData('这里是远程跨域获取的数据');//数据格式可以自定义，如json、字符串 jsonp在用$.ajax()获取远程数据时，如果是跨域资源则可以使用jsonp方法，以前一直以为jsonp是ajax的一种，后来才明白他们根本就不是一回事。ajax是以xhr方式请求数据的，而jsonp是以script方式请求数据的，这个就是和上面的动态创建script方式一样。pageA(www.jack.com/index.html)代码如下：$.ajax(&#123; //JSONP不支持POST方式 type:\"GET\", url:\"http://www.jesse.com/data.php\", dataType:\"jsonp\", //自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据 jsonpCallback:\"getData\", success: function(data)&#123; console.log(data); &#125;, error: function()&#123; console.log('fail'); &#125;&#125;) pageB(www.jesse.com/data.js)代码如下：&lt;?php $callback = $_GET['callback'];//得到回调函数名,这里是getData $data = array('a','b','c');//要返回的数据 echo $callback.'('.json_encode($data).')';//输出?&gt; 3.document.domain对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。 具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上 document.domain = “a.com”；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以 “交互”了。当然这种办法只能解决主域相同而二级域名不同的情况www.a.com上的a.htmldocument.domain = 'a.com';var ifr = document.createElement('iframe');ifr.src = 'http://script.a.com/b.html';ifr.style.display = 'none';document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(\"h1\")[0].childNodes[0].nodeValue);&#125;; script.a.com上的b.htmldocument.domain = 'a.com'; 4.跨域资源共享（CORS）原理:跨源资源共享(CORS)定义一种跨域访问的机制，可以让AJAX实现跨域访问。CORS允许一个域上的网络应用向另一个域提交跨域AJAX请求。实现此功能非常简单，只需由服务器发送一个响应标头即可。它是通过客户端+服务端协作声明的方式来确保请求安全的。服务端会在HTTP请求头中增加一系列HTTP请求参数(例如Access-Control-Allow-Origin等)，来限制哪些域的请求和哪些请求类型可以接受，而客户端在发起请求时必须声明自己的源(Orgin)，否则服务器将不予处理，如果客户端不作声明，请求甚至会被浏览器直接拦截都到不了服务端。服务端收到HTTP请求后会进行域的比较，只有同域的请求才会处理。 pageA(www.jack.com/index.html)代码如下：var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; console.log(xhr.responseText); &#125;&#125;;xhr.open(\"get\",\"http://www.jesse.com/data.php\");xhr.send(null); pageB(www.jesse.com/data.php)代码如下：&lt;?php header(\"Access-Control-Allow-Origin: http://www.jack.com\");//与简单的请求相同 header(\"Access-Control-Allow-Methods: GET, POST\");//允许请求的方法 header(\"Access-Control-Max-Age: 3628800\"); //将这个请求缓存多长时间 $data = array('a','b','c');//要返回的数据 echo json_encode($data);//输出?&gt; 5.window.postMesage 不常用window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。pageA(www.jack.com/index.html)代码如下：&lt;iframe id=\"proxy\" src=\"http://www.jesse.com/index.html\" onload=\"postMsg()\" style=\"display: none\"&gt;&lt;/iframe&gt;&lt;script type=\"text/javascript\"&gt;var obj = &#123; msg: 'hello world'&#125;function postMsg() &#123; var iframe = document.getElementById('proxy'); var win = iframe.contentWindow; win.postMessage(obj, 'http://www.jesse.com');&#125;&lt;/script&gt; pageB(www.jesse.com/data.php)代码如下：&lt;script type=\"text/javascript\"&gt;window.onmessage = function(e) &#123; console.log(e.data.msg + \" from \" + e.origin);&#125;&lt;/script&gt; 6. location.hash 不常用pageA(www.jack.com/index.html)代码如下：function startRequest() &#123; var ifr = document.createElement('iframe'); ifr.style.display = 'none'; ifr.src = 'http://www.jesse.com/b.html#sayHi'; //传递的location.hash document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : ''; if (console.log) &#123; console.log('Now the data is ' + data); &#125; &#125; catch (e) &#123;&#125;;&#125;setInterval(checkHash, 5000);window.onload = startRequest; pageA(www.jack.com/proxy.html)代码如下：parent.parent.location.hash = self.location.hash.substring(1); pageB(www.jesse.com/b.html)代码如下：function checkHash() &#123; var data = ''; //模拟一个简单的参数处理操作 switch (location.hash) &#123; case '#sayHello': data = 'HelloWorld'; break; case '#sayHi': data = 'HiWorld'; break; default: break; &#125; data &amp;&amp; callBack('#' + data);&#125;function callBack(hash) &#123; // ie、chrome的安全机制无法修改parent.location.hash，所以要利用一个中间的www.a.com域下的代理iframe var proxy = document.createElement('iframe'); proxy.style.display = 'none'; proxy.src = 'http://www.jack/c.html' + hash; // 注意该文件在\"www.jack.com\"域下 document.body.appendChild(proxy);&#125;window.onload = checkHash; 参考文章： 使用 window.name 解决跨域问题 跨域方法总结","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"从输入网址到页面呈现这个过程中都发生了什么？","date":"2016-12-22T16:00:00.000Z","path":"articles/web/从输入网址到页面呈现这个过程中都发生了什么.html","text":"在前端开发中我们常常需要考虑首屏加载时间，为了尽可能减少首屏加载时间我们需要弄清楚从输入网址到页面最终呈现的过程中都发生了哪些事情，然后才能具体问题具体分析，最终达到提升网页性能的目的。从输入网址到页面呈现过程中都发生了什么？据说这是一个非常经典的面试题，考察的问题面也很广，今天我就从一个前端开发工程师的角度来解答一下这个问题，文中难免有些知识点介绍的不够深，还望见谅！从输入网址到页面呈现这个过程大致可分为以下这几个部分： 网络通信 页面渲染 网络通信输入网址当我们在浏览器的地址栏输入网址例如(http://www.baidu.com)，http://代表使用超文本传输协议，www.baidu.com代表服务器地址，baidu.com代表域名。一个完整的URL包括协议、服务器地址(主机)、端口、路径 负责域名查询与解析的DNS服务用户通常使用主机名或域名来访问某网站，而不是直接通过IP来访问，因为字母数字配合的表示形式更符合人类的记忆习惯，可计算机却不理解这些名称，因此DNS服务应运而生，DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。DNS查询过程如下： 操作系统会先检查本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(baidu.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找baidu.com域服务器，重复上面的动作，进行查询，直至找到www.baidu.com主机。 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。 应用层 客户端发送HTTP请求报文HTTP报文包括： 报文首部 （请求行+各种首部字段+其他） 空行 报文主体 （应被发送的数据）通常并不一定要有报文主体 下面对百度首页请求报文首部进行分析：请求行请求方法GET 请求URI / HTTP协议版本 1.1GET / HTTP/1.1 首部字段请求资源所在服务器Host: www.baidu.com连接方式：持久连接 HTTP/1.1之前版本默认非持久连接Connection: keep-alive报文指令：要求所有中间服务器不返回缓存资源Pragma: no-cache控制缓存的行为：缓存前必须先确认其有效性，防止从缓存中返回过期的资源Cache-Control: no-cache用户代理可处理的媒体类型Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 q表示权重从而区分优先级http客户端浏览器信息User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36可接受的内容编码类型Accept-Encoding: gzip, deflate, sdch可接受的语言Accept-Language: zh-CN,zh;q=0.8相关信息或标记Cookie: BAIDUID=3C67AA3EF6B3347D3AA986CE489268C4:FG=1; BIDUPSID=3C67AA3EF6B3347D3AA986CE489268C4; 传输层 确保传输报文可靠性的TCP协议位于传输层的TCP协议为传输报文提供可靠的字节流服务。为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。“三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。详细过程如下图 网络层 负责传输的IP协议IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。具体过程如下图： 链路层 传输数据的硬件部分在网络层找到对方的MAC地址后，就将数据发送到数据链路层传输。至此请求报文已发出，客户端发送请求的阶段结束 服务器接收报文接收端服务器在链路层接收到数据后，删除该层的首部信息并向网络层传递，网络层将接收的数据向传输层传递，在传输层会将传输的数据按序号从组请求报文并传送给应用层。当数据传输到应用层才能算真正接收到由客户端发送过来的HTTP请求 应用层 服务器发送HTTP响应报文下面对百度首页响应报文首部进行分析：状态行协议版本 状态码 状态码原因短语HTTP/1.1 200 OK 首部字段当前服务器上安装的HTTP服务器程序信息bfe:Baidu Front End。百度人自己写的反向代理及防攻击接入层Server: bfe/1.0.8.18响应日期时间Date: Thu, 08 Dec 2016 14:48:19 GMT说明报文实体的媒体类型Content-Type: text/html; charset=utf-8传输编码方式：分块编码Transfer-Encoding: chunked链接方式：持久链接 http/1.1之后这个已经没必要了Connection: keep-alive只接受对持相同自然语言的请求返回缓存Vary: Accept-Encoding缓存控制：仅向特定用户返回响应Cache-Control: privateCxy_all: baidu+43a6e396a3ed26dc7d1de13c6af79e49缓存过期时间Expires: Thu, 08 Dec 2016 14:47:38 GMTX-Powered-By: HPHPX-UA-Compatible: IE=Edge,chrome=1Strict-Transport-Security: max-age=172800BDPAGETYPE: 1BDQID: 0xc9d964a600018bb8BDUSERID: 0设置cookieSet-Cookie: H_PS_PSSID=1451_21116_17001_21408_21417_21554_20929; path=/; 响应报文的传输方式与请求报文相同，简单点说就是原路返回在响应报文中我们通过Chrome DevTool的Network面板可以看到输入的www.baidu.com会被重定向到https://www.baidu.com/,点击重定向后的www.baidu.com,在右边的Response面板中可以看到客户端接收到的报文实体即返回的HTML页面代码 网络通信流程图 在网络通信阶段对前端优化建议： 减少HTTP请求数 合并资源，如合并 JavaScript 文件、CSS 文件，利用 CSS Sprite 合并图片等 内联图片,data url节省了HTTP请求,但是如果这个图像在网页多个地方显示会加大网页的内容，延长下载时间。 域名提前解析，在页面中不同域名的链接需指定预取域名：&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://this-is-a.com&quot;&gt;，IE9+支持 避免重定向（重定向会增加http请求的次数） cookie优化，cookie越多会导致请求头越大 启用GZIP压缩（Accept-Encoding：g-zip） 使用 CDN加速，减小服务器压力 合理利用HTTP缓存，通过设置Expires 页面渲染客户端在接收到html代码之后，接下来的流程如下： 解析html以构建DOM树解析一个文档即将其转换为具有一定意义的结构(编码可以理解和使用的东西)。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为与上下文无关的语法。解析的过程可以分成两个子过程：词法分析和语法分析。 词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。 语法分析是应用语言的语法规则的过程。 解析器通常将解析工作分给以下两个组件来处理： 词法分析器（有时也称为标记生成器），负责将输入内容分解成一个个有效标记； 而解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。 由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。此解析算法由两个阶段组成：标记化和树构建。具体的解析过程可参考浏览器的工作原理中的标记化算法和构建树算法 解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。解析树的根节点是“Document”对象。 当解析到link标签时会请求相应的CSS文件，并将其CSS规则解析为StyleSheet对象，CSS文件中的其他外链资源如背景图片等只有等到其规则与DOM树某节点相匹配时才会加载当解析遇到img标签时会根据路径向服务器相应的资源文件夹中请求图片资源，但并不会等待图片资源下载完再去解析接下来的html，而是并发执行即图片资源仍在下载，html解析也在进行。如果没有定义图片的height和width属性，那么浏览器为了能够显示每一个加载的图像，它需要先下载图像，然后解析出图像的高度和宽度，并在显示窗口留出相应的屏幕空间，这样就会导致浏览器不断地重新计算/调整页面的布局，这可能会延迟文档的显示，并导致页面重绘。当解析遇到script标签时，将启动 JavaScript 引擎，这时将阻塞 DOM 树的构建。因为 JavaScript 执行过程中， JavaScript 很可能会对 DOM 树进行读写操作。直到 JavaScript 执行完毕（此时执行的是全局对象初始创建和全局上下文中代码的执行），DOM树才会恢复构建。 构建render树为了更好地用户体验效果，浏览器会在构建DOM树的同时，也在构建render树。呈现树的每一个节点即为与其相对应的DOM节点的CSS框，框的类型与DOM节点的display属性有关，block元素生成block框，inline元素生成inline框。每一个呈现树节点都有与之相对应的DOM节点，但DOM节点不一定有与之相对应的呈现树节点，比如display属性为none的DOM节点，而且呈现树节点在呈现树中的位置与他们在DOM树中的位置不一定相同，比如float与绝对定位元素。在构建render树的时候需要为DOM树匹配CSS规则，在这个阶段因为匹配规则是从右往左匹配的，所以css的编写规则很重要。不好的CSS选择器写法会影响到页面渲染的效率，具体是如何编写高效的CSS规则的可参考这篇文章CSS选择器性能分析 布局render树在创建render树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。布局是一个递归的过程，它从根元素开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。布局通常具有以下模式： 父呈现器确定自己的宽度。 父呈现器依次处理子呈现器，并且： 放置子呈现器（设置 x,y 坐标）。 如果有必要，调用子呈现器的布局，这会计算子呈现器的高度。 父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。 将其 dirty 位设置为 false 绘制render树在绘制阶段，系统会遍历render树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。绘制顺序: 背景颜色 背景图片 边框 子代 轮廓 页面变化造成的影响在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。 在页面渲染阶段对前端优化建议： 建议将 CSS 文件放在页首，以便构建 DOM 树；而将 JavaScript 文件尽量放在页面下方，防止阻塞构建 DOM 树；而 JavaScript 的 onload 事件里，不要写太多影响首屏渲染的、操作 DOM 树的 JavaScript 代码。 精简 JavaScript 和 CSS 代码，并进行代码压缩，使得css和js资源更快的下载 编写高效的CSS代码 重要的图片或者想让用户优先看到的图片使用img标签，次要的图片使用background引入 参考文献： 《图解HTTP》 浏览器的工作原理 《高性能网站建设指南》 由于个人水平有限，不够详细或有误的地方还望指出，共同进步才是最好的结果","tags":[{"name":"WEB","slug":"web","permalink":"https://jesse121.github.io/tags/web/"}]},{"title":"Javascript执行流总结","date":"2016-12-05T15:00:00.000Z","path":"articles/javascript/javascript执行流总结.html","text":"面对各种各样的JavaScript代码，我们有时候难免会犯错。可当自己仔细研究一下，哦原来是这么回事。有时候怎么会想为什么Javascript程序会是这样执行的呢？为什么没有得到自己预期的答案呢？自己到底是哪一步想错了呢？这时候就想如果我是JS执行流我会怎么执行？仔细想想这些问题，原来这其中还包含着很多自己不熟悉的知识点，今天就来总结下，同时也好加深印象。首先我们来熟悉几个名称： 执行上下文栈(Execution Context Stack) 每一种代码的执行都需要依赖自身的上下文。函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。一个执行上下文可以激活另一个上下文，就好比一个函数调用了另一个函数(或者全局的上下文调用了一个全局函数)，然后一层一层调用下去。逻辑上来说，这种实现方式是栈，我们可以称之为上下文堆栈。 激活其它上下文的某个上下文被称为 调用者(caller) 。被激活的上下文被称为被调用者(callee) 。当一个caller激活了一个callee，那么这个caller就会暂停它自身的执行，然后将控制权交给这个callee. 于是这个callee被放入堆栈，称为进行中的上下文[running/active execution context]. 当这个callee的上下文结束之后，会把控制权再次交给它的caller，然后caller会在刚才暂停的地方继续执行。在这个caller结束之后，会继续触发其他的上下文。一个callee可以用返回（return）或者抛出异常（exception）来结束自身的上下文。 当一段程序开始时，会先进入全局执行上下文环境[global execution context], 这个也是堆栈中最底部的元素。此全局程序会开始初始化，初始化生成必要的对象[objects]和函数[functions]. 在此全局上下文执行的过程中，它可能会激活一些方法（当然是已经初始化过的），然后进入他们的上下文环境，然后将新的元素压入堆栈。在这些初始化都结束之后，这个系统会等待一些事件（例如用户的鼠标点击等），会触发一些方法，然后进入一个新的上下文环境。ECMAScript运行时系统就是这样管理代码的执行。 执行上下文(Execution Context) 一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性(变量对象(variable object)，this指针(this value)，作用域链(scope chain) ) 变量对象(variable object) 变量对象是与执行上下文相关的 数据作用域(scope of data) 。它是与上下文关联的特殊对象，用于存储被定义在上下文中的变量(variables)和函数声明(function declarations) 。 活动对象(activation object) 在一个函数上下文中，变量对象被表示为活动对象。它包含变量(variables)和函数声明(function declarations) 普通参数(形参) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。 知道了这几个名称后我们拿几个实例来分一下Javascript到底是如何执行的？if (!(\"a\" in window)) &#123; var a = 1;&#125;alert(a); 这里如果不加思考，想当然的认为如果window不包含属性a，就声明一个变量a，然后赋值为1。所以答案为1。可是正确答案是undefined，再仔细想想为什么？如果你就是JS程序你会如何运行？详细分析：当一段程序开始时，会先进入全局执行上下文环境并初始化生成必要的对象，在全局执行上下文环境中申明了变量a，根据变量声明提升，此时该上下文环境中的变量对象VO = {a:undefined}(全局上下文中VO还包括其他对象如Math,Date等对此题不构成影响，暂不考虑)。全局上下文环境初始化好后开始执行代码，首先判断变量a是否属于window对象，我们知道变量a已经在window对象中，所以，if条件语句不会被执行，直接执行alert，该题可简化为：var a;if (!(\"a\" in window)) &#123; a = 1;&#125;alert(a); //undefined 第二题function a(x) &#123; return x * 2;&#125;var a;alert(a); 我们知道变量对象中及包括函数声明也包括变量申明，在此题中有同名的函数和变量，此时函数声明会覆盖变量声明。但不会覆盖已经赋值的同名变量声明。所以此题中最后结果是函数第三题function b(x, y, a) &#123; arguments[2] = 10; alert(a);&#125;b(1, 2, 3); 在此题中，b函数被激活会开辟一个新的内存栈并添加到执行上下文栈中，执行流进入b函数上下文，此时变量对象表示为活动对象AO = { x : 1, y : 2, a : 3, arguments:{0:1,1:2,2:3}}Arguments对象是活动对象的一个属性，它包括如下属性： callee — 指向当前函数的引用 length — 真正传递的参数个数 properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes的值和实际传递进来的参数之间是共享的。这个共享其实不是真正的共享一个内存地址，而是2个不同的内存地址，使用JavaScript引擎来保证2个值是随时一样的. 所以当代码执行到arguments[2] = 10;时a也会变为10。 参考文献： 深入理解JavaScript系列–汤姆大叔的博客","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"CSS选择器性能分析","date":"2016-12-04T16:00:00.000Z","path":"articles/html-css/performance-of-css-selectors.html","text":"尽管css选择器效率问题已经不是什么新鲜问题，但是我觉得还是有必要拿出来认真分析一下。之前只是看到别人这么写我也跟着这么写，并没有想清楚问什么要这样写？这样写真的能提高页面渲染效率吗？尽管自己技术不怎么样，但还是需要拿出一种打破砂锅问到底的决心来深究一下css选择器效率问题，通过自己写个demo亲自实践来加深一下对这个问题的理解。事情的经过是这样子的，在之前的博文CSS选择器总结中介绍了各种不同的css选择器，顿时觉得css的世界很精彩，可以有很多种不同的写法，想怎么写就怎么写，于是就有了这种代码.wrapper ul li a&#123;color:red;……&#125;.wrapper .list p.name&#123;margin:10px 0;……&#125;* &#123;margin:0;padding:0&#125;…… 写完这样样式后，自我感觉还不错，至少页面能呈现出来。可是直到有一天突然发现 CSS选择器从右向左的匹配规则 我的世界瞬间崩塌了，因为根据阅读习惯在编写CSS的时候也会自然而然是从左向右逐渐细化。顿时很想搞清楚浏览器在将DOM tree变成render tree的时候css规则是如何匹配的？于是查了这么些资料： Why do browsers match CSS selectors from right to left? Writing Efficient CSS: Understand Your Selectors 编写高效的 CSS 看了这么多我的理解是从右往左匹配会首先过滤掉一大批不符合规则的样式，从而使得效率更高。举个例子.wrapper .list a .demo&#123;……&#125; 如果从左往右匹配会先找到.wrapper,然后再找到里面很多的.list,在往里找直到找到那个.demo，查找的越深，过滤掉的也就越多，在这个查找的过程中会有很多没用的样式也被遍历过，这里就导致匹配的效率很低。如果从右向左匹配会首先过滤掉不是.demo的元素，在依次往上查找，越往上过滤掉的也就越少，这样效率明显比从左往右匹配要高很多弄明白了从右向左匹配的规则那么我们要如何写才能让浏览器更快的匹配到呢？浏览器在面对众多的CSS样式代码时并不是毫无规则的一个一个匹配，而是先将样式规则分为四个主要类别： ID 规则 这第一个类别包含了那些将 ID 选择器作为关键选择器的规则。 Class 规则 如果一个规则将一个 class 明确作为它的关键选择器，那么它就属于该类别。 标签规则 如果一条规则将一个标签作为它的关键选择器，那么这条规则就属于该类别。 通用规则 不属于上面那些类别的规则都属于这个类别。 并引入关键选择器的概念(选择器最后的那部分).wrapper ul li a&#123;color:red;……&#125; /* 关键选择器为a */.wrapper .list p.name&#123;margin:10px 0;……&#125; /* 关键选择器为.name */ 根据关键选择器属于哪类再在这一类中查找，从而达到更快匹配的目的。那么问题来了，怎样写才能达到高效呢？CSS选择器效率从高到低的排序如下： ID选择器 比如#header 类选择器 比如.promo 元素选择器 比如 div 兄弟选择器 比如 h2 + p 子选择器 比如 li &gt; ul 后代选择器 比如 ul a 7. 通用选择器 比如 * 属性选择器 比如 type = “text” 伪类/伪元素选择器 比如 a:hover 以上引用自Steve Souders的Even Faster网站在实际使用中我们尽量选择高效一点的选择器，但是有一点很难避免那就是组合选择器的使用，一般都会用到。在使用组合选择器时我们需要注意一下几点： 如果规则拥有ID选择器作为其关键选择器，则不在需要添加其他规则了，因为ID是唯一的。 差 .wrapper button#backButton {…} 好 #backButton {…} 不要用标签名限定 class 规则，这会有损灵活性 差 .wrapper p.name{…} 好 .wrapper .name{…} 避免使用过度限制选择器(最好不要超过3层) 差 body .wrapper .content .list {} 好 .content .list{} 避免后代选择器,后代选择器是 CSS 中性能耗用最大的选择器。 差 ul li a{} 好 .list .list-content{} 依赖继承 本来想写几个demo展示出不同选择器的效率的，但是不好演示，大家可以看看CSS selector performance这篇文章中介绍了20中不同的选择器的执行效率问题。 结合自己的实践经历，在编写CSS规则时需注意以下几点： 嵌套层级最好不要超过3层 避免使用标签选择器，尽可能使用具体的类名 不要给关键选择器添加多余的规则 CSS选择器在性能提升上尽管相对于js等提升空间不大，但在大型项目中高效率的css选择器的性能优势就能得到展现","tags":[{"name":"CSS","slug":"css","permalink":"https://jesse121.github.io/tags/css/"}]},{"title":"《jQuery内核详解与实践》--读书笔记","date":"2016-11-25T16:00:00.000Z","path":"articles/notes/jQuery内核详解与实践.html","text":"第二章 jQuery技术解密2.2 jQuery原型技术分解2.2.1 起源–原型继承var $ = jQuery = function()&#123; // 函数体&#125;jQuery.fn = jQuery.prototype = &#123; jquery: \"1.3.2\", size: function()&#123; return this.length; &#125;&#125; 2.2.2 生命–返回实例var $ = jQuery = function()&#123; return jQuery.fn.init();&#125;jQuery.fn = jQuery.prototype = &#123; init:function()&#123; return this; //this指向jQuery.prototype &#125;, jquery:\"1.3.2\", size: function()&#123; return this.length; &#125;&#125;alert($().jquery); //\"1.3.2\" 2.2.3 学步–分隔作用域var $ =jQuery = function()&#123; //jQuery框架精彩之处 //将jQuery.fn.init作为构造函数，此处返回init的实例，达到分离作用域的作用，方便调用 return new jQuery.fn.init();&#125;jQuery.fn = jQuery.prototype = &#123; init : function()&#123; this.length = 0; this.test = function()&#123; return this.length; &#125; return this; &#125;, jquery: \"1.3.2\", length: 1, size: function() &#123; return this.length; &#125;&#125;//无法访问jQuery.fn对象的属性或方法alert( $().jquery ); //返回undefined alert( $().test() ); //返回0alert( $().size() ); //抛出异常 2.2.4 生长–跨域访问var $ =jQuery = function()&#123; return new jQuery.fn.init();&#125;jQuery.fn = jQuery.prototype = &#123; init : function()&#123; this.length = 0; this.test = function()&#123; return this.length; &#125; return this; &#125;, jquery: \"1.3.2\", length: 1, size: function() &#123; return this.length; &#125;&#125;//jQuery框架精彩之处//使用jquery的原型对象覆盖init的原型对象，//这样通过init创建出来的实例对象就能访问到jQuery的原型方法及属性jQuery.fn.init.prototype = jQuery.fn; alert( $().jquery ); //返回\"1.3.2\"alert( $().test() ); //返回0alert( $().size() ); //返回0 2.2.5 成熟–选择器&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;var $ =jQuery = function(selector, context )&#123; //定义类 return new jQuery.fn.init(selector, context ); //返回选择器的实例&#125;jQuery.fn = jQuery.prototype = &#123; //jQuery类的原型对象 init : function(selector, context)&#123; //定义选择器构造器 selector = selector || document; //设置默认值为document context = context || document; //设置默认值为document if ( selector.nodeType ) &#123; //如果选择符为节点对象 this[0] = selector; //把参数节点传递给实例对象的数组 this.length = 1; //并设置实例对象的length属性，定义包含元素个数 this.context = selector; //设置实例的属性，返回选择范围 return this; //返回当前实例 &#125; if ( typeof selector === \"string\" ) &#123; //如果选择符是字符串 var e = context.getElementsByTagName(selector); //获取指定名称的元素 for(var i = 0;i&lt;e.length;i++)&#123; //遍历元素集合，并把所有元素填入到当前实例数组中 this[i] = e[i]; &#125; this.length = e.length; //设置实例的length属性，即定义包含元素的个数 this.context = context; //设置实例的属性，返回选择范围 return this; //返回当前实例 &#125; else&#123; this.length = 0; //否则，设置实例的length属性值为0 this.context = context; //设置实例的属性，返回选择范围 return this; //返回当前实例 &#125; &#125;, jquery: \"1.3.2\", size: function() &#123; return this.length; &#125;&#125;jQuery.fn.init.prototype = jQuery.fn;alert( $(\"div\").size() ); //返回3&lt;/script&gt; 2.6 延续–迭代器&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;var $ = jQuery = function(selector, context) &#123; return new jQuery.fn.init(selector, context);&#125;jQuery.fn = jQuery.prototype = &#123; init: function(selector, context) &#123; //参阅上节示例 &#125;, html: function(val) &#123; jQuery.each(this, function(val) &#123; this.innerHTML = val; &#125;, val); &#125;&#125;jQuery.fn.init.prototype = jQuery.fn;jQuery.each = function(object, callback, args) &#123; for (var i = 0; i &lt; object.length; i++) &#123; callback.call(object[i], args); &#125; return object;&#125;$(\"div\").html(\"测试代码\");&lt;/script&gt; 2.2.7 延续–功能扩展var $ = jQuery = function(selector, context) &#123; return new jQuery.fn.init(selector, context);&#125;jQuery.fn = jQuery.prototype = &#123; init: function(selector, context) &#123;&#125;, html: function(val) &#123;&#125;&#125;jQuery.fn.init.prototype = jQuery.fn;jQuery.extend = jQuery.fn.extend = function(obj) &#123; for (var prop in obj) &#123; //jquery精彩之处 //把指定对象的方法赋值给jQuery或jQuery.fn,使得jquery可以不断扩充 this[prop] = obj[prop]; &#125; return this;&#125;jQuery.each = function(object, callback, args) &#123;&#125;jQuery.fn.extend(&#123; test: function() &#123; alert(\"测试扩展功能\"); &#125;&#125;) 2.2.8 延续–参数处理var $ = jQuery = function(selector, context) &#123; return new jQuery.fn.init(selector, context);&#125;jQuery.fn = jQuery.prototype = &#123; init: function(selector, context) &#123;&#125;, html: function(val) &#123;&#125;, setOptions: function(options) &#123; this.options = &#123; StartColor: \"#000\", EndColor: \"#DDC\", Background: false, Step: 20, Speed: 10 &#125;; jQuery.extend(this.options, options || &#123;&#125;); &#125;&#125;jQuery.fn.init.prototype = jQuery.fn;jQuery.extend = jQuery.fn.extend = function(destination, source) &#123; for (var property in source) &#123; destination[property] = source[property]; &#125; return destination;&#125; 2.2.9 涅槃–名字空间(function()&#123; var window = this,undefined,_jQuery = window.jQuery,_$ = window.$, jQuery = window.jQuery = window.$ = function(selector, context) &#123; return new jQuery.fn.init(selector, context); &#125;; jQuery.fn = jQuery.prototype = &#123;&#125;&#125;)() 2.3 破解jQuery选择器接口jQuery实例对象其实就是jQuery.fn.init构造器创建的对象，通过jQuery.fn.init.prototype = jQuery.fn使得jQuery实例对象继承了jQuery对象的方法。 第三章 高效选择的技巧与原理3.2 简单选择器3.2.1 选择指定ID元素javascript实现方法document.getElementById(&quot;id&quot;)javascript实现方法document.querySelector(&quot;#id&quot;)jqury实现方法$(&#39;#id&#39;)执行效率比较分析window.onload = function()&#123; for(var i=0;i&lt;1000;i++)&#123; var span = document.createElement(\"span\"); span.setAttribute(\"id\",\"span\" + i); document.getElementsByTagName(\"body\")[0].appendChild(span); &#125; var a = []; console.time(\"time\"); for(var j=0;j&lt;1000;j++)&#123; var b = document.getElementById(\"span\"+j); //time: 1.201ms // var b = document.querySelector(\"#span\"+j); //time: 5.045ms //var b = $(\"#span\"+j); //time: 5.092ms a.push(b); &#125; console.timeEnd(\"time\");&#125; 由于jQuery需要对参数字符串进行分析，并匹配出所传递的参数值是ID值，然后才能调用getElementById()方法获取该ID元素，所以花费时间会更多 3.2.3 选择指定类元素javascript实现方法document.getElementsByClassName = function(className) &#123; var el = [], _el = document.getElementsByTagName('*'); for (var i=0; i&lt;_el.length; i++ ) &#123; if (_el[i].className == className ) &#123; el[el.length] = _el[i]; &#125; &#125; return el;&#125; javascript实现方法document.querySelector(&quot;.className&quot;)jquery实现方法$(.className)执行效率比较分析document.getElementsByClassName = function(className) &#123; var el = [], _el = document.getElementsByTagName('*'); for (var i=0; i&lt;_el.length; i++ ) &#123; if (_el[i].className == className ) &#123; el[el.length] = _el[i]; &#125; &#125; return el;&#125;window.onload = function() &#123; for (var i = 0; i &lt; 500; i++) &#123; var span = document.createElement(\"span\"); span.setAttribute(\"class\", \"red\"); document.getElementsByTagName(\"body\")[0].appendChild(span); &#125; var a = []; console.time(\"time\"); for (var j = 0; j &lt; 500; j++) &#123; //var b = document.getElementsByClassName(\"red\");//time: 132.483ms var b = document.querySelector(\".red\"); //time: 0.867ms //var b = $(\".red\"); //time: 140.824ms a.push(b); &#125; console.timeEnd(\"time\"); &#125; 在类的查询中document.querySelector方法最快，IE8+都能兼容，所以实际使用中选择速度最快的那个了 第八章 高效开发和使用插件8.1创建jQuery插件8.1.2解析jQuery插件机制jQuery.extend()能够创建全局函数或选择器在实际开发中，常使用jQuery.extend()方法作为插件方法传递系列选项结构的参数var options = jQuery.extend(&#123;&#125;,&#123; name1 : value1; name2 : value2; name3 : value3; &#125;,options); jQuery.fn.extend()能够创建jQuery对象方法 8.1.3 创建jQuery全局函数建议把属于自己的插件都封装在一个对象中jQuery.css8 = &#123; minValue : function(a, b)&#123; return a &lt; b ? a : b; &#125;, maxValue : function(a, b)&#123; return a &lt; b ? b : a; &#125;&#125; 8.1.4 使用jQuery.fn对象创建jQuery对象方法jQuery.fn.test = function()&#123; return this.each(function()&#123; alert(this.nodeName); &#125;);&#125; 8.1.5 使用extend()方法创建jQuery对象方法jQuery.fn.extend(&#123; test : function()&#123; return this.each(function()&#123; alert(this.nodeName); &#125;); &#125;;&#125;) 8.1.6 创建自定义选择器jQuery选择器会使用一组正则表达式来分析选择符，然后针对所解析出来的每一个选择符执行一个函数，这个函数被称为选择器函数，最后根据这个选择器函数的返回值是否为true决定是否保留当前元素，这样就可以找到所要匹配的元素节点。其正则表达式直接量如下：match&#123; POS:/(nth|eq|qt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/ ???&#125; 自定义:ge(大于等于)和:le(小于等于)选择器jQuery.extend(jQuery.expr[\":\"],&#123; le:function(elem, i, match)&#123; return i &lt; match[3] - 0 || i == match[3] - 0; //match[3] - 0强制转换为数值类型 &#125;, ge:function(elem, i, match)&#123; return i &gt; amtch[3] - 0 || i == match[3] - 0; &#125;&#125;) 8.1.14 创建jQuery插件应注意的问题 命名规则 jquery.pluginName.js 基本思想 所有新方法都附加到jQuery.fn对象上，所有新功能都附加到jQuery对象上 方法内的this关键字 this关键字用于引用jQuery对象，在this.each()方法体内，this是引用当前匹配的DOM元素对象 迭代匹配元素 使用this.each()迭代匹配元素 方法的返回值 所有方法都必须放回jQuery对象 方便压缩 所有方法或函数，末尾必须加分号(;) 建议框架 (function($, window, document, undefined)&#123;&#125;)(jQuery, window, document);","tags":[{"name":"jQuery","slug":"jquery","permalink":"https://jesse121.github.io/tags/jquery/"}]},{"title":"前端切图技巧","date":"2016-11-12T15:00:00.000Z","path":"articles/photoshop/the-front-end-cutting-technique.html","text":"前端开发免不了要切图，面对复杂的页面，仅切图工作就会花费大量的时间。对于追求高效率的我来说这是不可忍受的，并且规划好页面后，切图工作并不需要消耗多少脑细胞，都是很机械化的东西。所以在网上搜了搜一下几种高效的前端切图方法，分析其各自的特点及使用场景并总结归纳出自己常用的切图方法。 photoshop cc下载我这里使用的是photoshop cc 2017下载地址可使用我的网盘中地址https://pan.baidu.com/s/1c2nmfJy 密码：7u04，文件夹中包括 安装文件set-up.exe; 破解文件amtemu破解方法; 前端切图插件cutterman. 个人初始化设置首选项设置编辑-&gt;首选项-&gt;单位与标尺 单位改为像素 移动工具设置工具栏 自动选择-&gt;图层 视图设置打开标尺和智能参考线 窗口设置打开图层 信息 cutterman 历史记录 其他的面板可关闭信息右侧设置-&gt;面板选项 -&gt; 颜色模式RGB 单位像素 勾上文档尺寸和文档大小窗口-&gt; 工作区-&gt;新建工作区-&gt;前端切图-&gt;存储 传统切图方法切片切图用切片工具先将需要切的图定好大小，然后存储为web所用格式，点击保存在生成文件中可看到需要切出的图片 智能对象切图将需要切出的图层保存为智能对象，双击改智能对象，ctrl+i+r,基于透明像素裁剪，裁剪完后另存为web所用格式 高效切图方法启用生成器 在首选项-&gt;增效工具-&gt;生成器 面板中勾选启用生成器 将所需要切图的图层添加.png或.jpg后缀,例如图层1改为图层1.png 在原PSD文件同级目录中为自动生成assets文件夹，这里面包含了自动切好的图片 cutterman扩展在官网中下载并安装扩展,注意ps的版本要求 设置好相关参数，保存目录，图片格式品质等; 选中要切出的图层; 点击导出选中图层,即可在保存目录中看到需要切的图 以上的这些方法我都使用过，目前使用的最多的是使用cutterman切图，如果大家有更好的切图方法，还希望评论告知，一起交流^_^","tags":[{"name":"Photoshop","slug":"photoshop","permalink":"https://jesse121.github.io/tags/photoshop/"}]},{"title":"《Javascript权威指南》第六版--读书笔记","date":"2016-10-22T15:00:00.000Z","path":"articles/notes/javascript-the-definitive-guide-6th-edition.html","text":"第3章 类型、值和变量3.1 数字3.1.3 javascript中算术运算符isNaN()参数是NaN或一个非数字值返回trueisFinite() 参数是NaN,Infinity,-Infinity的时候返回falseisNaN(NaN); //trueisFinite(NaN); //false 3.2 文本3.2.1 字符串直接量在ECMAScript5中字符串可以拆分成数行，中间每行必须以反斜线结束var result = \"one \\two \\three\";console.log(result); //one two three 建议：在javascript中使用单引号表示字符串，在HTML中使用双引号表示字符串; 3.2.2 转义字符\\n 换行符\\r 回车符 3.3 布尔值undefined、null、0、-0、NaN、false、”” 会转化为false,其他值转化为true 3.6 包装对象字符串通过new String()构造函数创建一个临时对象，这个对象继承了字符串的方法，并被用来处理属性的引用，一旦引用结束，这个对象自动销毁。数字和布尔值也具有各自的方法，通过Number()和Boolean()构造函数创建一个临时对象，方法均来自这个临时对象null和undefined没有包装对象 3.10 变量作用域在函数体内，局部变量的优先级高于同名的全局变量 3.10.1 函数作用域和声明提前javascript函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，函数声明和变量声明都会被提升 3.10.2 作为属性的变量当使用var声明一个变量时，创建的这个属性是不可配置的，这个属性无法通过delete语运算符删除 第4章 表达式和运算符4.7 运算符优先级参考MDN运算符优先级下面的表将所有运算符按照优先级的不同从高到低排列。 优先级 运算类型 关联性 运算符 20 圆括号 n/a ( … ) 19 成员访问 从左到右 … . … 需计算的成员访问 从左到右 … [ … ] new(带参数列表) n/a new … ( … ) 函数调用 从左到右 … ( … ) 18 new (无参数列表) 从右到左 new … 17 后置递增(运算符在后) n/a … ++ 后置递减(运算符在后) n/a … – 16 逻辑非 从右到左 ! … 按位非 从右到左 ~ … 一元加法 从右到左 + … 一元减法 从右到左 - … 前置递增 从右到左 ++ … 前置递减 从右到左 – … typeof 从右到左 typeof … void 从右到左 void … delete 从右到左 delete … 15 幂 从右到左 … ** … 14 乘法 从左到右 … * … 除法 从左到右 … / … 取模 从左到右 … % … 13 加法 从左到右 … + … 减法 从左到右 … - … 12 按位左移 从左到右 … &lt;&lt; … 按位右移 从左到右 … &gt;&gt; … 无符号右移 从左到右 … &gt;&gt;&gt; … 11 小于 从左到右 … &lt; … 小于等于 从左到右 … &lt;= … 大于 从左到右 … &gt; … 大于等于 从左到右 … &gt;= … in 从左到右 … in … instanceof 从左到右 … instanceof … 10 等号 从左到右 … == … 非等号 从左到右 … != … 全等号 从左到右 … === … 非全等号 从左到右 … !== … 9 按位与 从左到右 … &amp; … 8 按位异或 从左到右 … ^ … 7 按位或 从左到右 … … 6 逻辑与 从左到右 … &amp;&amp; … 5 逻辑或 从左到右 … … 4 条件运算符 从右到左 … ? … : … 3 赋值 从右到左 … = … … += … … -= … … *= … … /= … … %= … … &lt;&lt;= … … &gt;&gt;= … … &gt;&gt;&gt;= … … &amp;= … … ^= … … = … 2 yield 从右到左 yield … yield* 从右到左 yield* … 1 展开运算符 n/a … … 0 逗号 从左到右 … , … 4.9.4 instanceof 运算符为了计算表达式 o instanceof f,javascript首先计算f.prototype,然后在o的原型链中查找f.prototype,如果找到则表达式返回true，否则返回false 4.13.3 delete 运算符并不是所有的属性都可以删除内置核心和客户端属性是不能删除用户通过var语句声明的变量不能删除function语句定义的函数和函数参数也是不能删除 第5章 语句5.2 复合语句和空语句语句块的结尾不需要分号，块中原始语句必须以分号结束 5.7.3 “use strict”严格模式和非严格模式之间的区别： 严格模式中禁止使用with语句 严格模式中所有变量要先声明，否则将会抛出一个引用错误异常 严格模式用调用的函数中的一个this值是undefined，在非严格模式中，this值总是全局变量。这可以用来判断是否支持严格模式var hasStrictMode = (fuction(){&quot;use strict&quot;;return this === undefined}()) 严格模式中，当通过call()或apply()来调用函数时，其中的this就是call()或apply()传入的第一个参数 严格模式中，给只读属性和给不可扩展的对象创建新成员都将抛出一个类型错误 严格模式中，传入eval()的代码不能再调用程序所在的上下文中声明变量或定义函数 严格模式中，函数里的arguments对象拥有传入函数值的静态副本，在非严格模式中，arguments里的数组元素和函数参数都指向同一个值的引用 严格模式中试图删除一个不可配置的属性将抛出一个类型错误 严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误 严格模式中，函数声明中存在两个或多个同名参数将产生一个语法错误 严格模式中，不允许使用八进制直接量 严格模式中，arguments,caller和arguments.callee都将抛出一个类型错误。 第6章 对象6.1 创建对象可通过对象直接量、关键字New、Object.create()来创建对象 6.1.3 原型Object.prototype没有原型对象，它不继承任何属性，所有内置构造函数都继承自它 6.1.4 Object.create()使用Object.create()创建一个新对象，其中第一个参数是这个对象的原型，第二个参数是可选的属性描述符var o = Object.create(null); //o是一个没有原型的对象以下是IE8兼容方法if (typeof Object.create != 'function') &#123; Object.create = (function() &#123; function Temp() &#123;&#125; var hasOwn = Object.prototype.hasOwnProperty; return function (O) &#123; if (typeof O != 'object') &#123; throw TypeError('Object prototype may only be an Object or null'); &#125; Temp.prototype = O; var obj = new Temp(); Temp.prototype = null; if (arguments.length &gt; 1) &#123; var Properties = Object(arguments[1]); for (var prop in Properties) &#123; if (hasOwn.call(Properties, prop)) &#123; obj[prop] = Properties[prop]; &#125; &#125; &#125; return obj; &#125;; &#125;)();&#125; 6.2 属性的查询和设置当使用方括号([])运算符来获取属性的值时，方括号内的表达式必须返回字符串，或者是一个可以返回字符串的值 6.3 删除属性delete只是断开属性和宿主对象的联系，而不去操作属性中的属性var a =&#123;p:&#123;x:1&#125;&#125;;var b = a.p;delete a.p;console.log(b.x); delete运算符只能删除自有属性，不能删除继承属性。delete表达式删除成功后，返回true 6.4 检测属性判断某个属性是否存在于某个对象中，可以通过in运算符、 hasOwnProperty()、propertyIsEnumerable()方法来判断propertyIsEnumerable()只有检测到是自有属性，且这个属性的可枚举性为true时才返回truevar o = Object.create(&#123;y:2&#125;);o.x = 1;o.propertyIsEnumerable(\"x\"); //true;o.propertyIsEnumerable(\"y\"); //false; 6.5 枚举属性对象继承的内置方法不可枚举，但在代码中给对象添加的属性都是可枚举的（除非将他们转换为不可枚举的）ECMAScript5定义了两个用以枚举属性名称的函数： Object.keys(),返回一个由对象中可枚举的自有属性的名称组成的数组 Object.getOwnPropertyNames(),只返回对象的所有自有属性的名称var arr = [\"a\", \"b\", \"c\"];Object.keys(arr); //[\"0\", \"1\", \"2\"]Object.getOwnPropertyNames(arr); // [\"0\", \"1\", \"2\", \"length\"] 6.8 对象的三个属性6.8.1 原型属性 proto通过对象直接量创建的对象使用Object.prototype作为他们的原型通过new创建的对象使用构造函数的prototype属性作为他们的原型通过Object.create()创建的对象使用第一个参数作为他们的原型将对象作为参数传入Object.getPrototypeOf()可以查询它的原型var a =&#123;x:1&#125;;var b = Object.create(a);Object.getPrototypeOf(b) === a; //true 想要检测一个对象是否是另一个对象的原型可以使用isPrototypeOf()方法var a =&#123;x:1&#125;;var b = Object.create(a);a.isPrototypeOf(b); //true 6.8.2 类属性 [object class]对象的类属性是一个字符串，用以表示对象的类型信息var a =&#123;&#125;;Object.prototype.toString.call(a).slice(8,-1); //Object 6.8.3 可扩展性Object.preventExtensions() 将对象转为不可扩展的Object.seal() 将对象转为不可扩展的,且将对象的所有自有属性设置为不可配置Object.freeze() 将对象转为不可扩展的,且将对象的所有自有属性设置为不可配置,将自有的所有数据属性设置为只读 第7章 数组7.5 数组元素的添加和删除用delete删除数组元素与为其赋undefined值是类似的，注意：使用delete删除数组元素的时候不会修改数组的length属性，也不会将元素从高索引处移下来填充已删除属性留下来的空白 7.8 数组方法7.8.3 sort()为了按照其他方式而非字符顺序进行数组排序，必须给sort()方法传递一个比较函数，该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数在前，比较函数应该返回一个小于0的数，第一个参数在后，比较函数返回一个大于0的数 7.8.5 slice()该方法返回数组的一个片段或子数组当参数中出现负数，-1指定了最后一个元素 7.8.7 push() pop() shift() unshift()pop() 返回数组尾部删除的值unshift() 返回数组头部删除的值 7.9 ECMAScript5中定义的数组方法 forEach()该方法遍历数组，为每个元素调用指定的函数 map()该方法调用数组的每个元素传递给指定的函数，并返回一个数组。 var a = [1,2,3];var b = a.map(function(x)&#123; return x*x&#125;); //b = [1,4,9] filter()该方法返回的数组元素是调用的数组的一个子集，传递的函数是用来逻辑判定的 var a = [1,2,3,4,5];samllValue = a.filter(function(x)&#123; return x &lt; 3&#125;); //[1,2] every()和some()every()当且仅当针对数组中所有元素调用判定函数都返回true，它才返回true。some()当针对数组中所有元素调用判定函数都返回false，它才返回false var a = [1,2,3,4,5];a.every(function(x)&#123; return x &lt; 0 &#125;) //truea.every(function(x)&#123; return x % 2 === 0&#125;) //falsea.some(function(x)&#123; return x % 2 === 0 &#125;) //truea.some(isNaN) //false 一旦every()和some()确认返回什么值他们就会停止遍历数组元素 reduce()和reduceRight()使用指定的函数将数组元素进行组合，生成单个值var a = [1,2,3,4,5];var sum = a.reduce(function(x,y)&#123;return x + y &#125;,0); //15var max = a.reduce(function(x,y)&#123; return (x&gt;y) ? x : y;&#125;) //5 reduce()第一个参数执行化简操作的函数，该函数的x参数是数组的元素，y参数是上一次操作的结果值，第二个参数是一个传递给函数的初始值，当没有初始值时默认为数组第一个元素reduceRight()按照数组的索引从高到低处理数组 7.11 类数组对象javascript数组的一些特性是其他对象所没有的： 当有新的元素添加到列表时，自动更新length属性 设置length属性为一个较小值时将截断数组 从Array.prototype中继承一些有用的方法 其类属性为Array 第8章 函数8.2 函数调用8.2.1 函数调用根据ECMAscript3和非严格的ECMAscript5对函数调用规定，调用上下文(this)是全局对象，在非严格模式下，调用上下文是window对象 8.2.2 方法调用如果函数表达式是一个属性访问表达式，即该函数是一个对象的属性或数组中的一个元素，那么它就是一个方法调用表达式属性访问表达式由两部分组成，一个对象和一个属性名称，这个对象成为调用上下文，函数体可以使用this引用该对象 8.2.3 构造函数调用构造函数调用会创建一个新的对象，这个对象继承自构造函数的prototype属性，构造函数试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数可以使用this来引用这个新创建的对象 8.2.4 间接调用call()和apply()可以用来间接的调用函数，两个方法都允许显示指定调用所需的this的值，也就是说任何函数可以作为任何对象的方法来调用 8.3 函数的实参和形参8.3.2 可变长的实参列表：实参对象在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象function f(x)&#123; console.log(x); arguments[0] = null; //修改实参数组的元素同样会修改x的值 console.log(x); //null &#125; 在ECMAScript5中移除了arguments属性 8.4 自定义函数属性当函数需要一个静态变量在调用时保持某个值不变，最方便的就是给函数定义属性，而不是定义全局变量 8.6 闭包JavaScript采用词法作用域，这个作用域是在函数定义时决定的。var scope = \"globlescope\";function checkscope()&#123; var scope = \"localscope\"; function f()&#123;return scope;&#125; return f;&#125;checkscope()(); //localscope 8.7 函数的属性方法和构造函数8.7.3 call()和apply()要想以对象o的方法来调用f函数，可以这样使用：f.call(o)f.apply(o) call()和apply()的第一个实参是要调用函数的母对象，它是调用上下文，在函数内通过this来获得它的引用两者区别：对call()来说，第二个参数是要传入待调用函数的值，所传入参数一一列出apply()第二个参数可以以参数数组(既可以是类数组也可以是真实数组)的形式传入 8.7.4 bind()当在函数f()上调用bind()方法并传入一个对象o作为参数，这个方法将返回一个新函数。新函数将会把原始函数f()当做o的方法来调用，传入新函数的任何实参都将传入原始函数function f(y)&#123; return this.x + y; &#125;var o = &#123; x : 1&#125;;var g = f.bind(o);g(2) //3 ECMAScript5中bind()方法不仅仅是将函数绑定至一个对象，传入bind()的实参也会绑定至this。这种编程技术被称为“柯里化”var sum = function(x,y)&#123;return x + y&#125;;//创建一个类似sum的新函数，但this的值绑定到null//并且第一个参数绑定1，这个新函数期望只传入一个实参var succ = sum.bind(null,1);succ(2) //3 8.7.6 Function()构造函数Function()构造函数所创建的函数并不使用词法作用域，函数体代码的编译总会在顶层函数执行，相当于全函数中的eval()var scope = \"global\";function constructFunction()&#123; var scope = \"local\"; return new Function(\"return scope\");&#125;constructFunction()(); //global 第9章 类和模块9.2 类和构造函数9.2.1 构造函数和类的标识符a instanceof b 本质是检测a对象是否继承自b.prototypea.__proto__ === b.prototype; // true 9.5 类和类型几种用以检测对象的类的技术： 9.5.1 instanceof 运算符function Range(from, to) &#123; this.from = from; this.to = to;&#125;Range.prototype = &#123; constructor:Range, includes: function(x) &#123; return this.from &lt;= x &amp;&amp; x &lt;= this.to; &#125;, foreach: function(f) &#123; for(var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x); &#125;, toString: function() &#123; return \"(\" + this.from + \"...\" + this.to + \")\"; &#125;&#125;;var r = new Range(1,3); r instanceof Range; //trueRange.prototype.isPrototypeOf(r); //true 9.5.2 constructor属性r.constructor == Range; 9.5.3 构造函数的名称9.5.4 鸭式辩型思想function quacks(o /*, ... */) &#123; for(var i = 1; i &lt; arguments.length; i++) &#123; // for each argument after o var arg = arguments[i]; switch(typeof arg) &#123; // If arg is a: case 'string': // string: check for a method with that name if (typeof o[arg] !== \"function\") return false; continue; case 'function': // function: use the prototype object instead // If the argument is a function, we use its prototype object arg = arg.prototype; // fall through to the next case case 'object': // object: check for matching methods for(var m in arg) &#123; // For each property of the object if (typeof arg[m] !== \"function\") continue; // skip non-methods if (typeof o[m] !== \"function\") return false; &#125; &#125; &#125; // If we're still here, then o implements everything return true;&#125; 9.8 ES5中的类9.8.1 让属性不可枚举Object.definedProperty(Object.prototype,\"objectId\",&#123; get:idGetter, enumerable:false, configurable:false &#125;) 9.8.4 防止类的扩展Object.preventExtensions()将对象设置为不可扩展Object.seal()阻止用户给对象添加新属性Object.freeze()将所有属性设置为只读和不可配置 第10章 正则表达式的模式匹配10.1 正则表达式的定义ECMAScript5规定一个正则表达式直接量会在执行到它时转化为一个正则对象，同一段代码每次运算都返回新对象 10.1.1 直接量字符^ $ . * + ? = ! : | \\ / () [] &#123;&#125; 在正则表达式中使用这些字符的直接量进行匹配，则必须使用前缀\\ 10.1.2 字符类将直接量字符单独放进方括号内就组成了字符类，一个字符类可以匹配它所包含的任意字符/[abc]/ 匹配a,b,c中任意一个/[^abc]/ 匹配abc之外的所有字符/[a-zA-Z0-9]/ 匹配拉丁字母表中任何字母和数字/[...]/ 匹配方括号内任意字符/[^...]/ 匹配不在方括号内任意字符/./ 匹配除换行符和其他Unicode行终止符之外的任意字符/\\w/ 匹配包括下划线在内的任何ASCII字符组成的单词 类似但不等价于/[a-zA-Z0-9_]//\\W/ 匹配任何不是ASCII字符组成的单词 等价于/[^a-zA-Z0-9_]//\\d/ 匹配任何ASCII数字 等价于/[0-9]//\\D/ 匹配除ASCII数字之外的任何字符 等价于/[^0-9]//\\s/ 匹配任何Unicode空白符/\\S/ 匹配任何非Unicode空白符 10.3 重复正则表达式的重复字符语法&#123;n,m&#125; 匹配前一项至少n次，但不能超过m次&#123;n,&#125; 匹配前一项n次或者更多&#123;n&#125; 匹配前一项n次? 匹配前一项0次或1次 等价于&#123;0,1&#125;+ 匹配前一项1次或多次 等价于&#123;1,&#125;* 匹配前一项0次或多次 等价于&#123;0,&#125; 使用?,*时要注意，由于这些字符串可能匹配0个字符，因此他们允许什么都不匹配非贪婪的重复非贪婪的重复即尽可能少的匹配，只须在待匹配的字符后跟随一个问号即可/a+?/ 10.1.4 选择分组和引用字符”|”用于分隔供选择的字符/\\d{3}|[a-z]{4}/匹配的是三位数字或者四个小写字母注意选择项的匹配次序是从左到右，直到发现匹配项，如果左边的选择项匹配，就忽略右边的匹配项正则表达式圆括号的多种用途： 把单独的项组成子表达式，以便通过”*+？|”进行修饰 /java(script)?/ 允许在同一正则表达式的后部引用前面的子表达式 \\1引用的是第一个带圆括号的子表达式 | 匹配的是该表达式左边或右边的子表达式(...) 将几个项组合为一个单元，这个单元可通过“*”，“+”，“？”和“|”等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后的引用使用(?...) 只组合，把项组合带一个单元，但不记忆与该组相匹配的字符\\n 和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式 10.1.5 指定匹配位置^ 匹配字符串的开头，在多行检索中匹配一行的开头$ 匹配字符串的结尾，在多行检索中匹配一行的结尾\\b 匹配一个单词的边界，简言之就是位于字符\\w和\\W之间的位置，或位于字符\\W和字符串的开头或者结尾之间的位置\\B 匹配非单词边界的位置(?=p) 零宽正向先行断言，要求接下来的字符都与p匹配，但不包括匹配p的那些字符(?=p) 零宽负向先行断言，要求接下来的字符都不与p匹配 10.1.6 修饰符 i 执行不区分大小写的匹配 g 执行一个全局匹配 m 多行匹配模式 10.2 用于模式匹配的String方法search() 返回第一个与之匹配的子串的起始位置，如果找不到匹配则返回-1。该方法不支持全局检索\"javascript\".search(/script/i); //4 replace() 用于检索与替换操作第一个参数是一个正则表达式，第二个参数是要进行替换的字符串。如正则表达式不带修饰符g，则只替换所匹配的第一个子串var text = \"javascript is a good language\";text.replace(/javascript/gi,\"JavaScript\"); //\"JavaScript is a good language\"var quote = /\"([^\"]*)\"/g;text.replace(quote,'“$1”'); match(正则表达式) 返回的是一个由匹配结果组成的数组\"1 plus 2 euqals 3\".match(/\\d+/g); //[\"1\", \"2\", \"3\"] split() 这个方法用以将调用它的字符串拆分为一个子串组成的数组\"1, 2, 3, 4\".split(/\\s*,\\s*/); //[\"1\",\"2\",\"3\",\"4\"] 10.3 RexExp对象10.3.2 RexExp的方法exec()方法对一个字符串执行检索匹配，没找到任何匹配返回null，找到就返回一个数组var text = \"JavaScript is more fun than Java!\";var pattern = ;/Java/g.exec(text); //[\"Java\", index: 0, input: \"JavaScript is more fun than Java!\"] test()对某个字符串检测，如果包含正则表达的一个匹配结果，则返回true/java/i.test(\"javascript\"); //true 第11章 javascript的子集和扩展这部分扩展可参考《ECMAscript6标准入门》第二版 第12章 服务器端javascriptprocess.version //node版本计信系process.argv //node命令行数组参数process.env // 环境变量对象process.cwd() //返回当前工作目录process.chdir() //改变目录process.exitr() //退出 第13章 web浏览器中的javascript13.3 javascript程序的执行web页面嵌入一个iframe窗体，文档中的js代码和被嵌入文档（iframe窗体）中js代码会有不同的全局对象javascript程序的执行有两个阶段，第一阶段载入文档内容并执行script元素中的代码（包括内敛脚本和外部脚本）。所有脚本执行完后进入第二阶段，这个阶段是异步的，由时间驱动，web浏览器调用时事件处理程序来响应异步发生的事件 客户端javascript时间线 web浏览器创建document对象，并且开始解析web页面，在这个阶段document.readystate属性的值是loading 当html解析器遇到没有async和defer属性的script时，他把这些元素添加到脚本中然后执行外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停，这样脚本可以用document.write()把文本插入到文档中 当解析器遇到设置了async和defer属性的script时,他开始下载脚本，并继续解析文档，脚本会在它下载完成后尽快执行，这里异步脚本禁止使用document.write()方法 当文档完成解析。document.readyState属性变为interactive.浏览器在domcument对象上触发DOMContentLoaded事件，这标志着程序执行从同步执行阶段转到了异步事件驱动阶段 当文档所有内容完成载入时，document.readyState属性变为complete，浏览器触发onload事件 第14章 window对象14.8 多窗口和窗体14.8.1 打开和关闭窗口window.open()载入指定的URL到新的或已存在的窗口中，并返回代表那个窗口的window对象 14.8.2 窗体之间的关系窗体可以用parent属性引用包含它的窗口或窗体的window对象top属性是一个通用的快捷方式，无论一个窗体被嵌套了几层，它的top属性引用的都是指向包含它的顶级窗口iframe元素具有contentWindow属性，引用该窗体的window对象每个window对象都有一个frames属性，他引用自身包含的窗口或窗体的子窗体，window.iframes[0]指向窗口的第一个子窗体frames[]数组里的元素是window对象 14.8.3 交互窗口中的javasctiptiframe A中有var i = 3； iframe B可以读取A中jsconsole.log(parent.A.i) //3 第15章 脚本化文档15.3 文档和结构的遍历15.3.1 作为节点树的文档parentNode childNodes firstChild lastChild nextSibling previoursSibling nodeType nodeValue nodeName 15.3.2 作为元素树的文档firstElementChild lastElementChild nextElementSibling previousElementSibling childElementCount 15.5.2 作为纯文本的元素内容标准的方法是用Node的textContent属性来实现，在IE章可以用innerText属性来代替 15.8.2 查询元素的几何尺寸断定一个元素的尺寸和位置的最简单的方法是调用它的getBoundingClientRect()方法，返回一个left,right，top,bottom属性的对象，都是相对视口坐标的位置 15.8.4 滚动window.scrollTo()接受一个点的x，y坐标（文档坐标）。滚动到某点window.scrollBy()接受一个点的x，y坐标（文档坐标）。相对滚动多少 第16章 脚本化CSS16.4 查询计算出的样式getComputedStyle()方法来获得一个元素的计算样式，返回值是一个cssStyleDeclaration对象,代表了应用在指定元素上的所有样式var title = documnet.getElementById(\"sectiontitle\");var titlestyles = window.getComputedStyle(element,null); 在IE8中可以通过元素的currentStyle属性来兼容 16.6.2 查询、插入与删除样式表规则document.styleSheets[]数组的元素是cssStyleSheets对象，cssStyleSheets对象有一个cssRules[]数组，它包含样式表的所有规则var firstRule = document.styleSheets[0].cssRules[0]; IE使用不同的属性名rules代替cssRules,rules数组只包含样式表中实际存在的样式规则 第17章 事件处理17.4 文档加载事件当文档加载解析完毕且所有延迟脚本(deferred)都执行完毕时会触发DOMContentLoaded事件，此时图片和异步脚本(async)可能依旧在加载 第18章 脚本化HTTP18.1.3 编码请求主体在表单用POST方法提交请求时，必须设置Content-Typexhr.setResquestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); 18.1.6 跨域HTTP请求测试withCredentials的存在性是测试浏览器是否支持CORS的一种方法 第19章 jquery类库19.5.3 动画得到取消延迟和队列stop()方法第一个参数默认为false，如果为true则会清楚该选中元素上的动画队列，还会取消任何等待执行的动画。第二个参数用来黄子行正在连续变化的css属性是否保留当前值，true变化到最终值，false保留当前值 第20章 客户端存储20.1 localStorage和sessionStorage这俩者的主要区别在于存储的有效期和作用域的不同，数据可以存储多长时间以及谁拥有数据的访问权限 20.1.1 存储有效期和作用域localStorage存储的数据是永久的，除非web应用删除存储数据或者用户通过设置浏览器配置删除数据，否则数据将一直保存在用户的电脑中，永不过期localStorage的作用域是限制在文档源级别的，不同的协议，主机名，端口拥有不同的文档源，同源的文档间共享localStorage。localStorage的作用域也受浏览器供应商限制 第21章 多媒体和图形编程21.3 可伸缩的矢量图形&lt;svg width=\"100\" height=\"100\"&gt; &lt;rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" fill=\"red\" /&gt;&lt;/svg&gt; SVG适用场景SVG功能更完善，适合静态图片展示，高保真文档查看和打印的应用场景兼容性IE9+ 21.4 canvas中的图形&lt;canvas id=\"drawing\" width=\"100\" height=\"100\"&gt;a drawing of something.&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var drawing = document.getElementById('drawing'); if(drawing.getContext)&#123; var context = srawing.getContext(\"2d\"); context.fillRect(10,10,50,50); context.fillStyle = \"#f00\"; &#125;&lt;/script&gt; a drawing of something. var drawing = document.getElementById('drawing'); if(drawing.getContext){ var context = drawing.getContext(\"2d\"); context.fillStyle = \"#f00\"; context.fillRect(0,0,100,100); } Canvas适用场景Canvas提供的功能更原始，适合像素处理，动态渲染和大数据量绘制兼容性IE9+ 第22章 html5 API22.3 跨域消息传递 postMessage()方法接收俩参数，第一个参数是要传递的消息，第二个参数是一个字符串，指定目标窗口的源&lt;!-- http://127.0.0.1/a.html --&gt;&lt;div id=\"test\"&gt;123&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onmessage = function(e) &#123; var text = document.getElementById('test').innerHTML; //window.parent.postMessage()返回想要的数据 window.parent.postMessage(text, \"http://localhost/test/index.html\"); &#125;&lt;/script&gt;&lt;!-- http:localhost/test/index.html --&gt;&lt;iframe id=\"iframe\" src=\"http://127.0.0.1/test/a.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var iframe = document.getElementById(\"iframe\"); iframe.contentWindow.postMessage(\"null\", \"http://127.0.0.1/test/a.html\"); &#125; window.onmessage = function(e) &#123; document.write(e.data); //123 这里获取到了a页面的dom内容 &#125;&lt;/script&gt;","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"Bootstrap源码分析系列之核心CSS","date":"2016-10-21T16:00:00.000Z","path":"articles/bootstrap/Bootstrap源码分析系列之核心CSS.html","text":"本节主要介绍核心CSS，从整体架构中的7个Less文件对应的源码分别进行分析 scaffolding.less这个文件编译后的css文件(886~989行)其作用就像定义全局样式。//调整css盒模型为border-box,这样修改使得添加padding不至于元素宽度超出边界 * &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125;*:before,*:after &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125;//由此可知IE8+都支持box-sizing: border-box;//对body input a 等一些元素进行初始化，还包括对图片，缩略图的处理html &#123; font-size: 10px; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); &#125;//个人觉得这里的font-size: 10px;根本没起作用，会被body中定义的字体大小覆盖//-webkit-tap-highlight-color: rgba(0, 0, 0, 0);适用于webkit内核浏览器中取消可点击元素的半透明灰色背景body &#123; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-size: 14px; line-height: 1.42857143; color: #333; background-color: #fff; &#125;input,button,select,textarea &#123; font-family: inherit; font-size: inherit; line-height: inherit; &#125;a &#123; color: #428bca; text-decoration: none; &#125;a:hover,a:focus &#123; color: #2a6496; text-decoration: underline; &#125;a:focus &#123; outline: thin dotted; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; &#125;//这里定义a连接获得焦点的状态，除了outline: thin dotted;后面几个浏览器不全支持figure &#123; margin: 0; &#125;img &#123; vertical-align: middle; &#125;.img-responsive,.thumbnail &gt; img,.thumbnail a &gt; img,.carousel-inner &gt; .item &gt; img,.carousel-inner &gt; .item &gt; a &gt; img &#123; display: block; max-width: 100%; height: auto; &#125;.img-rounded &#123; border-radius: 6px; &#125;.img-thumbnail &#123; display: inline-block; max-width: 100%; height: auto; padding: 4px; line-height: 1.42857143; background-color: #fff; border: 1px solid #ddd; border-radius: 4px; -webkit-transition: all .2s ease-in-out; -o-transition: all .2s ease-in-out; transition: all .2s ease-in-out; &#125;.img-circle &#123; border-radius: 50%; &#125;hr &#123; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid #eee; &#125;//定义在阅读屏幕中的样式.sr-only &#123; position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; &#125;.sr-only-focusable:active,.sr-only-focusable:focus &#123; position: static; width: auto; height: auto; margin: 0; overflow: visible; clip: auto; &#125; type.less排版样式，编译后对应源码为990~1335行h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6 &#123; font-family: inherit; font-weight: 500; line-height: 1.1; color: inherit; &#125;h1 small,h2 small,h3 small,h4 small,h5 small,h6 small,.h1 small,.h2 small,.h3 small,.h4 small,.h5 small,.h6 small,h1 .small,h2 .small,h3 .small,h4 .small,h5 .small,h6 .small,.h1 .small,.h2 .small,.h3 .small,.h4 .small,.h5 .small,.h6 .small &#123; font-weight: normal; line-height: 1; color: #777; &#125;h1,.h1,h2,.h2,h3,.h3 &#123; margin-top: 20px; margin-bottom: 10px; &#125;h1 small,.h1 small,h2 small,.h2 small,h3 small,.h3 small,h1 .small,.h1 .small,h2 .small,.h2 .small,h3 .small,.h3 .small &#123; font-size: 65%; &#125;h4,.h4,h5,.h5,h6,.h6 &#123; margin-top: 10px; margin-bottom: 10px; &#125;h4 small,.h4 small,h5 small,.h5 small,h6 small,.h6 small,h4 .small,.h4 .small,h5 .small,.h5 .small,h6 .small,.h6 .small &#123; font-size: 75%; &#125;h1,.h1 &#123; font-size: 36px; &#125;h2,.h2 &#123; font-size: 30px; &#125;h3,.h3 &#123; font-size: 24px; &#125;h4,.h4 &#123; font-size: 18px; &#125;h5,.h5 &#123; font-size: 14px; &#125;h6,.h6 &#123; font-size: 12px; &#125;//对标题h1~h6样式定义，并定义了副标题smallp &#123; margin: 0 0 10px; &#125;.lead &#123; margin-bottom: 20px; font-size: 16px; font-weight: 300; line-height: 1.4; &#125;@media (min-width: 768px) &#123;.lead &#123;font-size: 21px;&#125;&#125;//添加 .lead 类可以让段落突出显示small,.small &#123; font-size: 85%; &#125;mark,.mark &#123; padding: .2em; background-color: #fcf8e3; &#125;.text-left &#123; text-align: left; &#125;.text-right &#123; text-align: right; &#125;.text-center &#123; text-align: center; &#125;.text-justify &#123; text-align: justify; &#125;//文字对其样式.text-nowrap &#123; white-space: nowrap; &#125;.text-lowercase &#123; text-transform: lowercase; &#125;.text-uppercase &#123; text-transform: uppercase; &#125;.text-capitalize &#123; text-transform: capitalize; &#125;.text-muted &#123; color: #777; &#125;.text-primary &#123; color: #428bca; &#125;a.text-primary:hover &#123; color: #3071a9; &#125;.text-success &#123; color: #3c763d; &#125;a.text-success:hover &#123; color: #2b542c; &#125;.text-info &#123; color: #31708f; &#125;a.text-info:hover &#123; color: #245269; &#125;.text-warning &#123; color: #8a6d3b; &#125;a.text-warning:hover &#123; color: #66512c; &#125;.text-danger &#123; color: #a94442; &#125;a.text-danger:hover &#123; color: #843534; &#125;.bg-primary &#123; color: #fff; background-color: #428bca; &#125;a.bg-primary:hover &#123; background-color: #3071a9; &#125;.bg-success &#123; background-color: #dff0d8; &#125;a.bg-success:hover &#123; background-color: #c1e2b3; &#125;.bg-info &#123; background-color: #d9edf7; &#125;a.bg-info:hover &#123; background-color: #afd9ee; &#125;.bg-warning &#123; background-color: #fcf8e3; &#125;a.bg-warning:hover &#123; background-color: #f7ecb5; &#125;.bg-danger &#123; background-color: #f2dede; &#125;a.bg-danger:hover &#123; background-color: #e4b9b9; &#125;.page-header &#123; padding-bottom: 9px; margin: 40px 0 20px; border-bottom: 1px solid #eee; &#125;ul,ol &#123; margin-top: 0; margin-bottom: 10px; &#125;ul ul,ol ul,ul ol,ol ol &#123; margin-bottom: 0; &#125;.list-unstyled &#123; padding-left: 0; list-style: none; &#125;.list-inline &#123; padding-left: 0; margin-left: -5px; list-style: none; &#125;.list-inline &gt; li &#123; display: inline-block; padding-right: 5px; padding-left: 5px; &#125;dl &#123; margin-top: 0; margin-bottom: 20px; &#125;dt,dd &#123; line-height: 1.42857143; &#125;dt &#123; font-weight: bold; &#125;dd &#123; margin-left: 0; &#125;@media (min-width: 768px) &#123; .dl-horizontal dt &#123; float: left; width: 160px; overflow: hidden; clear: left; text-align: right; text-overflow: ellipsis; white-space: nowrap; &#125;le] &#123; cursor: help; border-bottom: 1px dotted #777; &#125;//列表样式.initialism &#123; font-size: 90%; text-transform: uppercase; &#125;blockquote &#123; padding: 10px 20px; margin: 0 0 20px; font-size: 17.5px; border-left: 5px solid #eee; &#125;blockquote p:last-child,blockquote ul:last-child,blockquote ol:last-child &#123; margin-bottom: 0; &#125;blockquote footer,blockquote small,blockquote .small &#123; display: block; font-size: 80%; line-height: 1.42857143; color: #777; &#125;blockquote footer:before,blockquote small:before,blockquote .small:before &#123; content: '\\2014 \\00A0'; &#125;.blockquote-reverse,blockquote.pull-right &#123; padding-right: 15px; padding-left: 0; text-align: right; border-right: 5px solid #eee; border-left: 0; &#125;.blockquote-reverse footer:before,blockquote.pull-right footer:before,.blockquote-reverse small:before,blockquote.pull-right small:before,.blockquote-reverse .small:before,blockquote.pull-right .small:before &#123; content: ''; &#125;.blockquote-reverse footer:after,blockquote.pull-right footer:after,.blockquote-reverse small:after,blockquote.pull-right small:after,.blockquote-reverse .small:after,blockquote.pull-right .small:after &#123; content: '\\00A0 \\2014'; &#125;//引用样式address &#123; margin-bottom: 20px; font-style: normal; line-height: 1.42857143; &#125;//地址或联系方式样式 code.less代码样式，编译后对应源码为1336~1389行code,kbd,pre,samp &#123; font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace; &#125;code &#123; padding: 2px 4px; font-size: 90%; color: #c7254e; background-color: #f9f2f4; border-radius: 4px; &#125;kbd &#123; padding: 2px 4px; font-size: 90%; color: #fff; background-color: #333; border-radius: 3px; -webkit-box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .25); box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .25); &#125;kbd kbd &#123; padding: 0; font-size: 100%; font-weight: bold; -webkit-box-shadow: none; box-shadow: none; &#125;pre &#123; display: block; padding: 9.5px; margin: 0 0 10px; font-size: 13px; line-height: 1.42857143; color: #333; word-break: break-all; word-wrap: break-word; background-color: #f5f5f5; border: 1px solid #ccc; border-radius: 4px; &#125;pre code &#123; padding: 0; font-size: inherit; color: inherit; white-space: pre-wrap; background-color: transparent; border-radius: 0; &#125;.pre-scrollable &#123; max-height: 340px; overflow-y: scroll; &#125; grid.less栅格系统，编译后对应源码为1390~2056行关于栅格系统，新手会觉得它很难理解。其实你只要记住的总是把一个容器分成12列(colspan)，根据屏幕的大小(通过媒体查询@media)分为超小屏幕xs(x-small),小屏幕sm(small),中等屏幕md(middle)，大屏幕lg(large)在响应式布局中可以针对不同的屏幕大小给某一列添加多个类&lt;div class=\"row\"&gt; &lt;div class=\"col-xs-12 col-sm-6 col-md-8\"&gt;.col-xs-12 .col-sm-6 .col-md-8&lt;/div&gt; &lt;div class=\"col-xs-6 col-md-4\"&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt; 每一列单元格可以嵌套，就像单元格的拆分一样，但是被嵌套的行（row）所包含的列（column）的个数不能超过12&lt;div class=\"row\"&gt; &lt;div class=\"col-sm-9\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-8 col-sm-6\"&gt;Level 2: .col-xs-8 .col-sm-6&lt;/div&gt; &lt;div class=\"col-xs-4 col-sm-6\"&gt;Level 2: .col-xs-4 .col-sm-6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用offset可以将列向右侧偏移，向右侧偏移的列数和这行剩下的列数总和为12&lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-4 col-md-offset-4\"&gt;.col-md-4 .col-md-offset-4&lt;/div&gt;&lt;/div&gt; 通过使用push可以实现将列向右移，使用pull可以实现将列向右移&lt;div class=\"row\"&gt; &lt;div class=\"col-md-9 col-md-push-3\"&gt;.col-md-9 .col-md-push-3&lt;/div&gt; &lt;div class=\"col-md-3 col-md-pull-9\"&gt;.col-md-3 .col-md-pull-9&lt;/div&gt;&lt;/div&gt; tables.less表格样式，编译后对应源码为2057~2296行table样式非常适合从框架中分离出来单独使用table &#123; background-color: transparent; &#125;caption &#123; padding-top: 8px; padding-bottom: 8px; color: #777; text-align: left; &#125;th &#123; text-align: left; &#125;.table &#123; width: 100%; max-width: 100%; margin-bottom: 20px; &#125;.table &gt; thead &gt; tr &gt; th,.table &gt; tbody &gt; tr &gt; th,.table &gt; tfoot &gt; tr &gt; th,.table &gt; thead &gt; tr &gt; td,.table &gt; tbody &gt; tr &gt; td,.table &gt; tfoot &gt; tr &gt; td &#123; padding: 8px; line-height: 1.42857143; vertical-align: top; border-top: 1px solid #ddd; &#125;.table &gt; thead &gt; tr &gt; th &#123; vertical-align: bottom; border-bottom: 2px solid #ddd; &#125;.table &gt; caption + thead &gt; tr:first-child &gt; th,.table &gt; colgroup + thead &gt; tr:first-child &gt; th,.table &gt; thead:first-child &gt; tr:first-child &gt; th,.table &gt; caption + thead &gt; tr:first-child &gt; td,.table &gt; colgroup + thead &gt; tr:first-child &gt; td,.table &gt; thead:first-child &gt; tr:first-child &gt; td &#123; border-top: 0; &#125;.table &gt; tbody + tbody &#123; border-top: 2px solid #ddd; &#125;.table .table &#123; background-color: #fff; &#125;//table基本样式.table-condensed &gt; thead &gt; tr &gt; th,.table-condensed &gt; tbody &gt; tr &gt; th,.table-condensed &gt; tfoot &gt; tr &gt; th,.table-condensed &gt; thead &gt; tr &gt; td,.table-condensed &gt; tbody &gt; tr &gt; td,.table-condensed &gt; tfoot &gt; tr &gt; td &#123; padding: 5px; &#125;//紧缩表格，通过设置单元格padding来实现.table-bordered &#123; border: 1px solid #ddd; &#125;.table-bordered &gt; thead &gt; tr &gt; th,.table-bordered &gt; tbody &gt; tr &gt; th,.table-bordered &gt; tfoot &gt; tr &gt; th,.table-bordered &gt; thead &gt; tr &gt; td,.table-bordered &gt; tbody &gt; tr &gt; td,.table-bordered &gt; tfoot &gt; tr &gt; td &#123; border: 1px solid #ddd; &#125;.table-bordered &gt; thead &gt; tr &gt; th,.table-bordered &gt; thead &gt; tr &gt; td &#123; border-bottom-width: 2px; &#125;//带边框的表格，通过设置border来实现边框.table-striped &gt; tbody &gt; tr:nth-child(odd) &#123; background-color: #f9f9f9; &#125;//条纹状表格，通过更改奇数行的背景颜色来实现.table-hover &gt; tbody &gt; tr:hover &#123; background-color: #f5f5f5; &#125;table col[class*=\"col-\"] &#123; position: static; display: table-column; float: none; &#125;table td[class*=\"col-\"],table th[class*=\"col-\"] &#123; position: static; display: table-cell; float: none; &#125;.table &gt; thead &gt; tr &gt; td.active,.table &gt; tbody &gt; tr &gt; td.active,.table &gt; tfoot &gt; tr &gt; td.active,.table &gt; thead &gt; tr &gt; th.active,.table &gt; tbody &gt; tr &gt; th.active,.table &gt; tfoot &gt; tr &gt; th.active,.table &gt; thead &gt; tr.active &gt; td,.table &gt; tbody &gt; tr.active &gt; td,.table &gt; tfoot &gt; tr.active &gt; td,.table &gt; thead &gt; tr.active &gt; th,.table &gt; tbody &gt; tr.active &gt; th,.table &gt; tfoot &gt; tr.active &gt; th &#123; background-color: #f5f5f5; &#125;//鼠标悬停在行或单元格上时所设置背景颜色.table-hover &gt; tbody &gt; tr &gt; td.active:hover,.table-hover &gt; tbody &gt; tr &gt; th.active:hover,.table-hover &gt; tbody &gt; tr.active:hover &gt; td,.table-hover &gt; tbody &gt; tr:hover &gt; .active,.table-hover &gt; tbody &gt; tr.active:hover &gt; th &#123; background-color: #e8e8e8; &#125;//鼠标悬停背景颜色变化表格.table &gt; thead &gt; tr &gt; td.success,.table &gt; tbody &gt; tr &gt; td.success,.table &gt; tfoot &gt; tr &gt; td.success,.table &gt; thead &gt; tr &gt; th.success,.table &gt; tbody &gt; tr &gt; th.success,.table &gt; tfoot &gt; tr &gt; th.success,.table &gt; thead &gt; tr.success &gt; td,.table &gt; tbody &gt; tr.success &gt; td,.table &gt; tfoot &gt; tr.success &gt; td,.table &gt; thead &gt; tr.success &gt; th,.table &gt; tbody &gt; tr.success &gt; th,.table &gt; tfoot &gt; tr.success &gt; th &#123; background-color: #dff0d8; &#125;.table-hover &gt; tbody &gt; tr &gt; td.success:hover,.table-hover &gt; tbody &gt; tr &gt; th.success:hover,.table-hover &gt; tbody &gt; tr.success:hover &gt; td,.table-hover &gt; tbody &gt; tr:hover &gt; .success,.table-hover &gt; tbody &gt; tr.success:hover &gt; th &#123; background-color: #d0e9c6; &#125;//标识成功或积极的动作.table &gt; thead &gt; tr &gt; td.info,.table &gt; tbody &gt; tr &gt; td.info,.table &gt; tfoot &gt; tr &gt; td.info,.table &gt; thead &gt; tr &gt; th.info,.table &gt; tbody &gt; tr &gt; th.info,.table &gt; tfoot &gt; tr &gt; th.info,.table &gt; thead &gt; tr.info &gt; td,.table &gt; tbody &gt; tr.info &gt; td,.table &gt; tfoot &gt; tr.info &gt; td,.table &gt; thead &gt; tr.info &gt; th,.table &gt; tbody &gt; tr.info &gt; th,.table &gt; tfoot &gt; tr.info &gt; th &#123; background-color: #d9edf7; &#125;.table-hover &gt; tbody &gt; tr &gt; td.info:hover,.table-hover &gt; tbody &gt; tr &gt; th.info:hover,.table-hover &gt; tbody &gt; tr.info:hover &gt; td,.table-hover &gt; tbody &gt; tr:hover &gt; .info,.table-hover &gt; tbody &gt; tr.info:hover &gt; th &#123; background-color: #c4e3f3; &#125;//标识普通的提示信息或动作.table &gt; thead &gt; tr &gt; td.warning,.table &gt; tbody &gt; tr &gt; td.warning,.table &gt; tfoot &gt; tr &gt; td.warning,.table &gt; thead &gt; tr &gt; th.warning,.table &gt; tbody &gt; tr &gt; th.warning,.table &gt; tfoot &gt; tr &gt; th.warning,.table &gt; thead &gt; tr.warning &gt; td,.table &gt; tbody &gt; tr.warning &gt; td,.table &gt; tfoot &gt; tr.warning &gt; td,.table &gt; thead &gt; tr.warning &gt; th,.table &gt; tbody &gt; tr.warning &gt; th,.table &gt; tfoot &gt; tr.warning &gt; th &#123; background-color: #fcf8e3; &#125;.table-hover &gt; tbody &gt; tr &gt; td.warning:hover,.table-hover &gt; tbody &gt; tr &gt; th.warning:hover,.table-hover &gt; tbody &gt; tr.warning:hover &gt; td,.table-hover &gt; tbody &gt; tr:hover &gt; .warning,.table-hover &gt; tbody &gt; tr.warning:hover &gt; th &#123; background-color: #faf2cc; &#125;//标识警告或需要用户注意.table &gt; thead &gt; tr &gt; td.danger,.table &gt; tbody &gt; tr &gt; td.danger,.table &gt; tfoot &gt; tr &gt; td.danger,.table &gt; thead &gt; tr &gt; th.danger,.table &gt; tbody &gt; tr &gt; th.danger,.table &gt; tfoot &gt; tr &gt; th.danger,.table &gt; thead &gt; tr.danger &gt; td,.table &gt; tbody &gt; tr.danger &gt; td,.table &gt; tfoot &gt; tr.danger &gt; td,.table &gt; thead &gt; tr.danger &gt; th,.table &gt; tbody &gt; tr.danger &gt; th,.table &gt; tfoot &gt; tr.danger &gt; th &#123; background-color: #f2dede; &#125;.table-hover &gt; tbody &gt; tr &gt; td.danger:hover,.table-hover &gt; tbody &gt; tr &gt; th.danger:hover,.table-hover &gt; tbody &gt; tr.danger:hover &gt; td,.table-hover &gt; tbody &gt; tr:hover &gt; .danger,.table-hover &gt; tbody &gt; tr.danger:hover &gt; th &#123; background-color: #ebcccc; &#125;//标识危险或潜在的带来负面影响的动作.table-responsive &#123; min-height: .01%; overflow-x: auto; &#125;//min-height: .01%;消除IE9的BUG@media screen and (max-width: 767px) &#123; .table-responsive &#123; width: 100%; margin-bottom: 15px; overflow-y: hidden; -ms-overflow-style: -ms-autohiding-scrollbar; border: 1px solid #ddd; &#125; .table-responsive &gt; .table &#123; margin-bottom: 0; &#125; .table-responsive &gt; .table &gt; thead &gt; tr &gt; th, .table-responsive &gt; .table &gt; tbody &gt; tr &gt; th, .table-responsive &gt; .table &gt; tfoot &gt; tr &gt; th, .table-responsive &gt; .table &gt; thead &gt; tr &gt; td, .table-responsive &gt; .table &gt; tbody &gt; tr &gt; td, .table-responsive &gt; .table &gt; tfoot &gt; tr &gt; td &#123; white-space: nowrap; &#125; .table-responsive &gt; .table-bordered &#123; border: 0; &#125; .table-responsive &gt; .table-bordered &gt; thead &gt; tr &gt; th:first-child, .table-responsive &gt; .table-bordered &gt; tbody &gt; tr &gt; th:first-child, .table-responsive &gt; .table-bordered &gt; tfoot &gt; tr &gt; th:first-child, .table-responsive &gt; .table-bordered &gt; thead &gt; tr &gt; td:first-child, .table-responsive &gt; .table-bordered &gt; tbody &gt; tr &gt; td:first-child, .table-responsive &gt; .table-bordered &gt; tfoot &gt; tr &gt; td:first-child &#123; border-left: 0; &#125; .table-responsive &gt; .table-bordered &gt; thead &gt; tr &gt; th:last-child, .table-responsive &gt; .table-bordered &gt; tbody &gt; tr &gt; th:last-child, .table-responsive &gt; .table-bordered &gt; tfoot &gt; tr &gt; th:last-child, .table-responsive &gt; .table-bordered &gt; thead &gt; tr &gt; td:last-child, .table-responsive &gt; .table-bordered &gt; tbody &gt; tr &gt; td:last-child, .table-responsive &gt; .table-bordered &gt; tfoot &gt; tr &gt; td:last-child &#123; border-right: 0; &#125; .table-responsive &gt; .table-bordered &gt; tbody &gt; tr:last-child &gt; th, .table-responsive &gt; .table-bordered &gt; tfoot &gt; tr:last-child &gt; th, .table-responsive &gt; .table-bordered &gt; tbody &gt; tr:last-child &gt; td, .table-responsive &gt; .table-bordered &gt; tfoot &gt; tr:last-child &gt; td &#123; border-bottom: 0; &#125;&#125;//响应式中的表格 forms.less表单样式，编译后对应源码为2297~2781行fieldset &#123; min-width: 0; padding: 0; margin: 0; border: 0; &#125;//min-width: 0;是的更像一个块状元素legend &#123; display: block; width: 100%; padding: 0; margin-bottom: 20px; font-size: 21px; line-height: inherit; color: #333; border: 0; border-bottom: 1px solid #e5e5e5; &#125;label &#123; display: inline-block; max-width: 100%; margin-bottom: 5px; font-weight: bold; &#125;input[type=\"search\"] &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125;input[type=\"radio\"],input[type=\"checkbox\"] &#123; margin: 4px 0 0; margin-top: 1px \\9; line-height: normal; &#125;//margin-top: 1px\\9;IE hackinput[type=\"file\"] &#123; display: block; &#125;input[type=\"range\"] &#123; display: block; width: 100%; &#125;select[multiple],select[size] &#123; height: auto; &#125;input[type=\"file\"]:focus, input[type=\"radio\"]:focus,input[type=\"checkbox\"]:focus &#123; outline: thin dotted; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; &#125;output &#123; display: block; padding-top: 7px; font-size: 14px; line-height: 1.42857143; color: #555; &#125;//output不同类型的输出，比如脚本的输出。IE不支持.form-control &#123; display: block; width: 100%; height: 34px; padding: 6px 12px; font-size: 14px; line-height: 1.42857143; color: #555; background-color: #fff; background-image: none; border: 1px solid #ccc; border-radius: 4px; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); -webkit-transition: border-color ease-in-out .15s, -webkit-box-shadow ease-in-out .15s; -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s; transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s; &#125;.form-control:focus &#123; border-color: #66afe9; outline: 0; -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6); box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6); &#125;.form-control::-moz-placeholder &#123; color: #999; opacity: 1; &#125;.form-control:-ms-input-placeholder &#123; color: #999; &#125;.form-control::-webkit-input-placeholder &#123; color: #999; &#125;//表单控件样式.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control &#123; cursor: not-allowed; background-color: #eee; opacity: 1; &#125;textarea.form-control &#123; height: auto; &#125;//文本域input[type=\"search\"] &#123; -webkit-appearance: none; &#125;input[type=\"date\"],input[type=\"time\"],input[type=\"datetime-local\"],input[type=\"month\"] &#123; line-height: 34px; line-height: 1.42857143 \\0; &#125;input[type=\"date\"].input-sm,input[type=\"time\"].input-sm,input[type=\"datetime-local\"].input-sm,input[type=\"month\"].input-sm &#123; line-height: 30px; line-height: 1.5 \\0; &#125;input[type=\"date\"].input-lg,input[type=\"time\"].input-lg,input[type=\"datetime-local\"].input-lg,input[type=\"month\"].input-lg &#123; line-height: 46px; line-height: 1.33 \\0; &#125;_:-ms-fullscreen,:root input[type=\"date\"],_:-ms-fullscreen,:root input[type=\"time\"],_:-ms-fullscreen,:root input[type=\"datetime-local\"],_:-ms-fullscreen,:root input[type=\"month\"] &#123; line-height: 1.42857143; &#125;_:-ms-fullscreen.input-sm,:root input[type=\"date\"].input-sm,_:-ms-fullscreen.input-sm,:root input[type=\"time\"].input-sm,_:-ms-fullscreen.input-sm,:root input[type=\"datetime-local\"].input-sm,_:-ms-fullscreen.input-sm,:root input[type=\"month\"].input-sm &#123; line-height: 1.5; &#125;_:-ms-fullscreen.input-lg,:root input[type=\"date\"].input-lg,_:-ms-fullscreen.input-lg,:root input[type=\"time\"].input-lg,_:-ms-fullscreen.input-lg,:root input[type=\"datetime-local\"].input-lg,_:-ms-fullscreen.input-lg,:root input[type=\"month\"].input-lg &#123; line-height: 1.33; &#125;//日期控件//_:-ms-fullscreen IE 11黑客逆向iOS破解时间输入。//:root根目录，IE8不支持.form-group &#123; margin-bottom: 15px; &#125;.radio,.checkbox &#123; position: relative; display: block; margin-top: 10px; margin-bottom: 10px; &#125;.radio label,.checkbox label &#123; min-height: 20px; padding-left: 20px; margin-bottom: 0; font-weight: normal; cursor: pointer; &#125;.radio input[type=\"radio\"],.radio-inline input[type=\"radio\"],.checkbox input[type=\"checkbox\"],.checkbox-inline input[type=\"checkbox\"] &#123; position: absolute; margin-top: 4px \\9; margin-left: -20px; &#125;.radio + .radio,.checkbox + .checkbox &#123; margin-top: -5px; &#125;.radio-inline,.checkbox-inline &#123; display: inline-block; padding-left: 20px; margin-bottom: 0; font-weight: normal; vertical-align: middle; cursor: pointer; &#125;.radio-inline + .radio-inline,.checkbox-inline + .checkbox-inline &#123; margin-top: 0; margin-left: 10px; &#125;input[type=\"radio\"][disabled],input[type=\"checkbox\"][disabled],input[type=\"radio\"].disabled,input[type=\"checkbox\"].disabled,fieldset[disabled] input[type=\"radio\"],fieldset[disabled] input[type=\"checkbox\"] &#123; cursor: not-allowed; &#125;.radio-inline.disabled,.checkbox-inline.disabled,fieldset[disabled] .radio-inline,fieldset[disabled] .checkbox-inline &#123; cursor: not-allowed; &#125;.radio.disabled label,.checkbox.disabled label,fieldset[disabled] .radio label,fieldset[disabled] .checkbox label &#123; cursor: not-allowed; &#125;//单选和多选控件.form-control-static &#123; padding-top: 7px; padding-bottom: 7px; margin-bottom: 0; &#125;.form-control-static.input-lg,.form-control-static.input-sm &#123; padding-right: 0; padding-left: 0; &#125;.input-sm,.form-group-sm .form-control &#123; height: 30px; padding: 5px 10px; font-size: 12px; line-height: 1.5; border-radius: 3px; &#125;select.input-sm,select.form-group-sm .form-control &#123; height: 30px; line-height: 30px; &#125;textarea.input-sm,textarea.form-group-sm .form-control,select[multiple].input-sm,select[multiple].form-group-sm .form-control &#123; height: auto; &#125;.input-lg,.form-group-lg .form-control &#123; height: 46px; padding: 10px 16px; font-size: 18px; line-height: 1.33; border-radius: 6px; &#125;select.input-lg,select.form-group-lg .form-control &#123; height: 46px; line-height: 46px; &#125;textarea.input-lg,textarea.form-group-lg .form-control,select[multiple].input-lg,select[multiple].form-group-lg .form-control &#123; height: auto; &#125;//下拉列表.has-feedback &#123; position: relative; &#125;.has-feedback .form-control &#123; padding-right: 42.5px; &#125;.form-control-feedback &#123; position: absolute; top: 0; right: 0; z-index: 2; display: block; width: 34px; height: 34px; line-height: 34px; text-align: center; pointer-events: none; &#125;.input-lg + .form-control-feedback &#123; width: 46px; height: 46px; line-height: 46px; &#125;.input-sm + .form-control-feedback &#123; width: 30px; height: 30px; line-height: 30px; &#125;.has-success .help-block,.has-success .control-label,.has-success .radio,.has-success .checkbox,.has-success .radio-inline,.has-success .checkbox-inline,.has-success.radio label,.has-success.checkbox label,.has-success.radio-inline label,.has-success.checkbox-inline label &#123; color: #3c763d; &#125;.has-success .form-control &#123; border-color: #3c763d; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); &#125;.has-success .form-control:focus &#123; border-color: #2b542c; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #67b168; box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #67b168; &#125;.has-success .input-group-addon &#123; color: #3c763d; background-color: #dff0d8; border-color: #3c763d; &#125;.has-success .form-control-feedback &#123; color: #3c763d; &#125;.has-warning .help-block,.has-warning .control-label,.has-warning .radio,.has-warning .checkbox,.has-warning .radio-inline,.has-warning .checkbox-inline,.has-warning.radio label,.has-warning.checkbox label,.has-warning.radio-inline label,.has-warning.checkbox-inline label &#123; color: #8a6d3b; &#125;.has-warning .form-control &#123; border-color: #8a6d3b; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); &#125;.has-warning .form-control:focus &#123; border-color: #66512c; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #c0a16b; box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #c0a16b; &#125;.has-warning .input-group-addon &#123; color: #8a6d3b; background-color: #fcf8e3; border-color: #8a6d3b; &#125;.has-warning .form-control-feedback &#123; color: #8a6d3b; &#125;.has-error .help-block,.has-error .control-label,.has-error .radio,.has-error .checkbox,.has-error .radio-inline,.has-error .checkbox-inline,.has-error.radio label,.has-error.checkbox label,.has-error.radio-inline label,.has-error.checkbox-inline label &#123; color: #a94442; &#125;.has-error .form-control &#123; border-color: #a94442; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); &#125;.has-error .form-control:focus &#123; border-color: #843534; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #ce8483; box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #ce8483; &#125;.has-error .input-group-addon &#123; color: #a94442; background-color: #f2dede; border-color: #a94442; &#125;.has-error .form-control-feedback &#123; color: #a94442; &#125;.has-feedback label ~ .form-control-feedback &#123; top: 25px; &#125;.has-feedback label.sr-only ~ .form-control-feedback &#123; top: 0; &#125;.help-block &#123; display: block; margin-top: 5px; margin-bottom: 10px; color: #737373; &#125;//校验状态@media (min-width: 768px) &#123; .form-inline .form-group &#123; display: inline-block; margin-bottom: 0; vertical-align: middle; &#125;eckbox-inline &#123; padding-top: 7px; margin-top: 0; margin-bottom: 0; &#125;.form-horizontal .radio,.form-horizontal .checkbox &#123; min-height: 27px; &#125;.form-horizontal .form-group &#123; margin-right: -15px; margin-left: -15px; &#125;@media (min-width: 768px) &#123; .form-horizontal .control-label &#123; padding-top: 7px; margin-bottom: 0; text-align: right; &#125;&#125;.form-horizontal .has-feedback .form-control-feedback &#123; right: 15px;&#125;@media (min-width: 768px) &#123; .form-horizontal .form-group-lg .control-label &#123; padding-top: 14.3px; &#125;&#125;@media (min-width: 768px) &#123; .form-horizontal .form-group-sm .control-label &#123; padding-top: 6px; &#125;&#125; buttons.less按钮样式，编译后对应源码为2782~3171行.btn &#123; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: normal; line-height: 1.42857143; text-align: center; white-space: nowrap; vertical-align: middle; -ms-touch-action: manipulation; touch-action: manipulation; cursor: pointer; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; background-image: none; border: 1px solid transparent; border-radius: 4px; &#125;.btn:focus,.btn:active:focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn.active.focus &#123; outline: thin dotted; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; &#125;.btn:hover,.btn:focus,.btn.focus &#123; color: #333; text-decoration: none; &#125;.btn:active,.btn.active &#123; background-image: none; outline: 0; -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125); &#125;.btn.disabled,.btn[disabled],fieldset[disabled] .btn &#123; pointer-events: none; cursor: not-allowed; filter: alpha(opacity=65); -webkit-box-shadow: none; box-shadow: none; opacity: .65; &#125;//按钮基本样式.btn-default &#123; color: #333; background-color: #fff; border-color: #ccc; &#125;.btn-default:hover,.btn-default:focus,.btn-default.focus,.btn-default:active,.btn-default.active,.open &gt; .dropdown-toggle.btn-default &#123; color: #333; background-color: #e6e6e6; border-color: #adadad; &#125;.btn-default:active,.btn-default.active,.open &gt; .dropdown-toggle.btn-default &#123; background-image: none; &#125;.btn-default.disabled,.btn-default[disabled],fieldset[disabled] .btn-default,.btn-default.disabled:hover,.btn-default[disabled]:hover,fieldset[disabled] .btn-default:hover,.btn-default.disabled:focus,.btn-default[disabled]:focus,fieldset[disabled] .btn-default:focus,.btn-default.disabled.focus,.btn-default[disabled].focus,fieldset[disabled] .btn-default.focus,.btn-default.disabled:active,.btn-default[disabled]:active,fieldset[disabled] .btn-default:active,.btn-default.disabled.active,.btn-default[disabled].active,fieldset[disabled] .btn-default.active &#123; background-color: #fff; border-color: #ccc; &#125;.btn-default .badge &#123; color: #fff; background-color: #333; &#125;//默认按钮.btn-primary &#123; color: #fff; background-color: #428bca; border-color: #357ebd; &#125;.btn-primary:hover,.btn-primary:focus,.btn-primary.focus,.btn-primary:active,.btn-primary.active,.open &gt; .dropdown-toggle.btn-primary &#123; color: #fff; background-color: #3071a9; border-color: #285e8e; &#125;.btn-primary:active,.btn-primary.active,.open &gt; .dropdown-toggle.btn-primary &#123; background-image: none; &#125;.btn-primary.disabled,.btn-primary[disabled],fieldset[disabled] .btn-primary,.btn-primary.disabled:hover,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary:hover,.btn-primary.disabled:focus,.btn-primary[disabled]:focus,fieldset[disabled] .btn-primary:focus,.btn-primary.disabled.focus,.btn-primary[disabled].focus,fieldset[disabled] .btn-primary.focus,.btn-primary.disabled:active,.btn-primary[disabled]:active,fieldset[disabled] .btn-primary:active,.btn-primary.disabled.active,.btn-primary[disabled].active,fieldset[disabled] .btn-primary.active &#123; background-color: #428bca; border-color: #357ebd; &#125;.btn-primary .badge &#123; color: #428bca; background-color: #fff; &#125;//原始按钮.btn-success &#123; color: #fff; background-color: #5cb85c; border-color: #4cae4c; &#125;.btn-success:hover,.btn-success:focus,.btn-success.focus,.btn-success:active,.btn-success.active,.open &gt; .dropdown-toggle.btn-success &#123; color: #fff; background-color: #449d44; border-color: #398439; &#125;.btn-success:active,.btn-success.active,.open &gt; .dropdown-toggle.btn-success &#123; background-image: none; &#125;.btn-success.disabled,.btn-success[disabled],fieldset[disabled] .btn-success,.btn-success.disabled:hover,.btn-success[disabled]:hover,fieldset[disabled] .btn-success:hover,.btn-success.disabled:focus,.btn-success[disabled]:focus,fieldset[disabled] .btn-success:focus,.btn-success.disabled.focus,.btn-success[disabled].focus,fieldset[disabled] .btn-success.focus,.btn-success.disabled:active,.btn-success[disabled]:active,fieldset[disabled] .btn-success:active,.btn-success.disabled.active,.btn-success[disabled].active,fieldset[disabled] .btn-success.active &#123; background-color: #5cb85c; border-color: #4cae4c; &#125;.btn-success .badge &#123; color: #5cb85c; background-color: #fff; &#125;//表示成功的按钮.btn-info &#123; color: #fff; background-color: #5bc0de; border-color: #46b8da; &#125;.btn-info:hover,.btn-info:focus,.btn-info.focus,.btn-info:active,.btn-info.active,.open &gt; .dropdown-toggle.btn-info &#123; color: #fff; background-color: #31b0d5; border-color: #269abc; &#125;.btn-info:active,.btn-info.active,.open &gt; .dropdown-toggle.btn-info &#123; background-image: none; &#125;.btn-info.disabled,.btn-info[disabled],fieldset[disabled] .btn-info,.btn-info.disabled:hover,.btn-info[disabled]:hover,fieldset[disabled] .btn-info:hover,.btn-info.disabled:focus,.btn-info[disabled]:focus,fieldset[disabled] .btn-info:focus,.btn-info.disabled.focus,.btn-info[disabled].focus,fieldset[disabled] .btn-info.focus,.btn-info.disabled:active,.btn-info[disabled]:active,fieldset[disabled] .btn-info:active,.btn-info.disabled.active,.btn-info[disabled].active,fieldset[disabled] .btn-info.active &#123; background-color: #5bc0de; border-color: #46b8da; &#125;.btn-info .badge &#123; color: #5bc0de; background-color: #fff; &#125;//提示信息的按钮.btn-warning &#123; color: #fff; background-color: #f0ad4e; border-color: #eea236; &#125;.btn-warning:hover,.btn-warning:focus,.btn-warning.focus,.btn-warning:active,.btn-warning.active,.open &gt; .dropdown-toggle.btn-warning &#123; color: #fff; background-color: #ec971f; border-color: #d58512; &#125;.btn-warning:active,.btn-warning.active,.open &gt; .dropdown-toggle.btn-warning &#123; background-image: none; &#125;.btn-warning.disabled,.btn-warning[disabled],fieldset[disabled] .btn-warning,.btn-warning.disabled:hover,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning:hover,.btn-warning.disabled:focus,.btn-warning[disabled]:focus,fieldset[disabled] .btn-warning:focus,.btn-warning.disabled.focus,.btn-warning[disabled].focus,fieldset[disabled] .btn-warning.focus,.btn-warning.disabled:active,.btn-warning[disabled]:active,fieldset[disabled] .btn-warning:active,.btn-warning.disabled.active,.btn-warning[disabled].active,fieldset[disabled] .btn-warning.active &#123; background-color: #f0ad4e; border-color: #eea236; &#125;.btn-warning .badge &#123; color: #f0ad4e; background-color: #fff; &#125;//表示警告按钮.btn-danger &#123; color: #fff; background-color: #d9534f; border-color: #d43f3a; &#125;.btn-danger:hover,.btn-danger:focus,.btn-danger.focus,.btn-danger:active,.btn-danger.active,.open &gt; .dropdown-toggle.btn-danger &#123; color: #fff; background-color: #c9302c; border-color: #ac2925; &#125;.btn-danger:active,.btn-danger.active,.open &gt; .dropdown-toggle.btn-danger &#123; background-image: none; &#125;.btn-danger.disabled,.btn-danger[disabled],fieldset[disabled] .btn-danger,.btn-danger.disabled:hover,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger:hover,.btn-danger.disabled:focus,.btn-danger[disabled]:focus,fieldset[disabled] .btn-danger:focus,.btn-danger.disabled.focus,.btn-danger[disabled].focus,fieldset[disabled] .btn-danger.focus,.btn-danger.disabled:active,.btn-danger[disabled]:active,fieldset[disabled] .btn-danger:active,.btn-danger.disabled.active,.btn-danger[disabled].active,fieldset[disabled] .btn-danger.active &#123; background-color: #d9534f; border-color: #d43f3a; &#125;.btn-danger .badge &#123; color: #d9534f; background-color: #fff; &#125;//表示危险按钮.btn-link &#123; font-weight: normal; color: #428bca; border-radius: 0; &#125;.btn-link,.btn-link:active,.btn-link.active,.btn-link[disabled],fieldset[disabled] .btn-link &#123; background-color: transparent; -webkit-box-shadow: none; box-shadow: none; &#125;.btn-link,.btn-link:hover,.btn-link:focus,.btn-link:active &#123; border-color: transparent; &#125;.btn-link:hover,.btn-link:focus &#123; color: #2a6496; text-decoration: underline; background-color: transparent; &#125;.btn-link[disabled]:hover,fieldset[disabled] .btn-link:hover,.btn-link[disabled]:focus,fieldset[disabled] .btn-link:focus &#123; color: #777; text-decoration: none; &#125;//链接按钮.btn-lg,.btn-group-lg &gt; .btn &#123; padding: 10px 16px; font-size: 18px; line-height: 1.33; border-radius: 6px; &#125;.btn-sm,.btn-group-sm &gt; .btn &#123; padding: 5px 10px; font-size: 12px; line-height: 1.5; border-radius: 3px; &#125;.btn-xs,.btn-group-xs &gt; .btn &#123; padding: 1px 5px; font-size: 12px; line-height: 1.5; border-radius: 3px; &#125;//按钮尺寸.btn-block &#123; display: block; width: 100%; &#125;.btn-block + .btn-block &#123; margin-top: 5px; &#125;input[type=\"submit\"].btn-block,input[type=\"reset\"].btn-block,input[type=\"button\"].btn-block &#123; width: 100%; &#125;","tags":[{"name":"Bootstrap","slug":"bootstrap","permalink":"https://jesse121.github.io/tags/bootstrap/"}]},{"title":"Bootstrap源码分析系列之初始化和依赖项","date":"2016-10-17T16:00:00.000Z","path":"articles/bootstrap/Bootstrap源码分析系列之初始化和依赖项.html","text":"在上一节中我们介绍了Bootstrap整体架构，本节我们将介绍Bootstrap框架第二部分初始化及依赖项，这部分内容位于源码的第8~885行，打开源码这部分内容似乎也不是很难理解。但是请站在一个开发者的角度来面对这段源码。为什么要这样写？如果没有Bootstrap框架我能写出类似这样的框架吗？我们先来分析normalize.less编译后的源码,我们知道normalize.css是一个专门将不同浏览器的默认css特性设置为统一效果的css库,它和reset.css还是有区别的，normalize.css并不是简单的重置了所有的样式，而是有针对的修改，同时也保留了标签的语义化。html &#123; font-family: sans-serif; -webkit-text-size-adjust: 100%; //防止IOS系统方向改变(特别是手持设备)后字体大小的调整，不禁用用户缩放。 -ms-text-size-adjust: 100%;&#125;body &#123; margin: 0;&#125;article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary &#123; display: block; //修正IE中未定义的html5块状元素&#125;audio,canvas,progress,video &#123; display: inline-block; vertical-align: baseline;&#125;audio:not([controls]) &#123;//否定伪类,匹配所有没有controls属性的audio display: none; //防止现代浏览器显示没有控制条的音频。 height: 0; //在iOS5设备中去除多余的高度。&#125;[hidden],template &#123;//template标签主要用于声明是“模板元素”。 display: none; //template标签和有hidden属性的元素不显示&#125;a &#123; background-color: transparent;&#125;a:active,a:hover &#123; outline: 0;&#125;abbr[title] &#123; border-bottom: 1px dotted;//这是缩写形式，border-bottom-color:initial;&#125;b,strong &#123; font-weight: bold;&#125;dfn &#123; //用来定义一个定义项目。 font-style: italic;&#125;h1 &#123; margin: .67em 0; font-size: 2em;&#125;mark &#123; //部分文本高亮显示,请在需要突出显示文本时使用 color: #000; background: #ff0;&#125;small &#123; font-size: 80%;&#125;sub,sup &#123; //防止sub sup影响行高 position: relative; font-size: 75%; line-height: 0; vertical-align: baseline;&#125;sup &#123; top: -.5em;&#125;sub &#123; bottom: -.25em;&#125;img &#123; border: 0;&#125;svg:not(:root) &#123;//非根目录的svg标签 overflow: hidden;&#125;figure &#123; //标记文档中的一个图像 margin: 1em 40px;&#125;hr &#123; height: 0; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box;&#125;pre &#123; overflow: auto;&#125;code,kbd,pre,samp &#123; font-family: monospace, monospace; font-size: 1em;&#125;button,input,optgroup,select,textarea &#123; margin: 0; font: inherit; color: inherit;&#125;button &#123; overflow: visible;&#125;button,select &#123; text-transform: none;&#125;button,html input[type=\"button\"],input[type=\"reset\"],input[type=\"submit\"] &#123; -webkit-appearance: button; cursor: pointer;&#125;button[disabled],html input[disabled] &#123; cursor: default;&#125;button::-moz-focus-inner,input::-moz-focus-inner &#123; //删除在火狐浏览器4及以上中的按钮的内部填充和边框 padding: 0; border: 0;&#125;input &#123; line-height: normal;&#125;input[type=\"checkbox\"],input[type=\"radio\"] &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; padding: 0;&#125;input[type=\"number\"]::-webkit-inner-spin-button,input[type=\"number\"]::-webkit-outer-spin-button &#123; height: auto;&#125;input[type=\"search\"] &#123; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; -webkit-appearance: textfield;&#125;input[type=\"search\"]::-webkit-search-cancel-button,input[type=\"search\"]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;fieldset &#123;//将表单内的相关元素分组。 padding: .35em .625em .75em; margin: 0 2px; border: 1px solid #c0c0c0;&#125;legend &#123; padding: 0; border: 0;&#125;textarea &#123; overflow: auto;&#125;optgroup &#123;//用于把相关的选项组合在一起。 font-weight: bold;&#125;table &#123; border-spacing: 0; border-collapse: collapse;&#125;td,th &#123; padding: 0;&#125; print.less主要是网页的打印样式，在此就不做分析了glyphicons.less是Bootstrap引入的字体图标样式，个人觉得提供的字体图标样式太少，而且不太适合国内的网页特点，所以在定制自己的Bootstrap框架时完全可以将其去掉，或者用其他的字体替换。我个人喜欢使用淘宝的iconfont字体，其使用方式与Bootstrap相同，都是在需要使用图标的地方加上相应的类名即可。来分析下部分glyphicons源码.glyphicon &#123; position: relative; top: 1px; display: inline-block; font-family: 'Glyphicons Halflings'; font-style: normal; font-weight: normal; line-height: 1; -webkit-font-smoothing: antialiased; //字体灰度平滑 -moz-osx-font-smoothing: grayscale;// 灰阶渲染&#125;.glyphicon-asterisk:before &#123; content: \"\\2a\"; //与引入的字体文件中图标对应&#125; 这些字体图标的本质是使用before伪类，其content后面的数字码则是与那个图标一一对应。","tags":[{"name":"Bootstrap","slug":"bootstrap","permalink":"https://jesse121.github.io/tags/bootstrap/"}]},{"title":"Bootstrap源码分析系列之整体架构","date":"2016-10-15T16:00:00.000Z","path":"articles/bootstrap/Bootstrap源码分析系列之整体架构.html","text":"作为一名合格的前端工程师，你肯定听说过Bootstarp框架。确实可以说Bootstrap框架是最流行的前端框架之一。可是也有人说Bootstrap是给后端和前端小白用的，我认为只要学习它能给我们前端技能带来提升，那么我们就有必要研究一下它。Bootstrap框架虽然也提供了javascript插件，但总感觉不够用。Bootrtrap更多的则是被用作css框架。之前我也用过几次Bootstrap，感觉确实很快，很方便，用的次数多了就越想弄清楚它到底是怎么回事？它好在哪里？ 这篇博文不适合Bootstrap新手 在Bootstrap官网点击下载我们可以看到有用于生产环境中的Bootstrap和Bootstrap源码以及Sass，我们知道Bootstrap 的源码是基于最流行的 CSS 预处理脚本 - Less 和 Sass 开发的。今天我们就来学习一下以Less开发的Bootstrap。如果不熟悉Less语法的朋友可以先在Less官网学习下，在下载的bootstrap-3.3.0\\less文件夹中打开bootstrap.less，我们可以看到源码的整体架构// Core variables and mixins//定义变量，方便后面调用@import \"variables.less\"; //定义混合 这类似定义函数或者宏，在mixins文件夹中可看到所定义的函数@import \"mixins.less\"; // Reset and dependencies 初始化和依赖项//标准化css，这是一个专门将不同浏览器的默认css特性设置为统一效果的css库，编译后对应源码为8~190行@import \"normalize.less\"; //打印样式，编译后对应源码为192~266行@import \"print.less\"; //图标样式，编译后对应源码为267~885行@import \"glyphicons.less\"; // Core CSS 核心CSS//脚手架，相当于全局样式，编译后对应源码为886~989行@import \"scaffolding.less\"; //排版样式，编译后对应源码为990~1335行@import \"type.less\"; //代码样式，编译后对应源码为1336~1389行@import \"code.less\"; //栅格系统，编译后对应源码为1390~2056行@import \"grid.less\"; //表格样式，编译后对应源码为2057~2296行@import \"tables.less\"; //表单样式，编译后对应源码为2297~2781行@import \"forms.less\"; //按钮样式，编译后对应源码为2782~3171行@import \"buttons.less\"; // Components 组件//组件中折叠和隐藏动画，编译后对应源码为2782~3171行@import \"component-animations.less\"; //下拉菜单及下三角符号，编译后对应源码为3209~3348行@import \"dropdowns.less\"; //按钮组，编译后对应源码为3349~3520行@import \"button-groups.less\"; //输入框组，编译后对应源码为3521~3674行@import \"input-groups.less\"; //导航，编译后对应源码为3675~3868行@import \"navs.less\"; //导航条，编译后对应源码为3869~4393行@import \"navbar.less\"; //面包屑，编译后对应源码为4394~4411行@import \"breadcrumbs.less\"; //默认分页，编译后对应源码为4412~4504行@import \"pagination.less\"; //翻页，编译后对应源码为4505~4542行@import \"pager.less\"; //标签，编译后对应源码为4543~4609行@import \"labels.less\"; //徽章，编译后对应源码为4610~4648行@import \"badges.less\"; //巨幕，编译后对应源码为4649~4686行@import \"jumbotron.less\"; //缩略图，编译后对应源码为4687~4712行@import \"thumbnails.less\"; //警告框，编译后对应源码为4713~4787行@import \"alerts.less\"; //进度条，编译后对应源码为4788~4881行@import \"progress-bars.less\"; //媒体对象，编译后对应源码为4882~4915行@import \"media.less\"; //列表组，编译后对应源码为4916~5091行@import \"list-group.less\"; //面板，编译后对应源码为5092~5426行@import \"panels.less\"; //具有响应式特性的嵌入内容，编译后对应源码为5427~5452行@import \"responsive-embed.less\"; //well效果，编译后对应源码为5453~5474行@import \"wells.less\"; //关闭按钮图标，编译后对应源码为5475~5499行@import \"close.less\"; // Components w/ JavaScript//模态框，编译后对应源码为5500~5622行@import \"modals.less\"; //工具提示，编译后对应源码为5623~5720行@import \"tooltip.less\"; //弹出框，编译后对应源码为5721~5841行@import \"popovers.less\"; //轮播，编译后对应源码为5842~6063行@import \"carousel.less\"; // Utility classes 工具类//实用工具类，编译后对应源码为6064~6147行@import \"utilities.less\"; //响应式工具类，编译后对应源码为6148~6357行@import \"responsive-utilities.less\"; 这些Less文件进过编译后形成了完整的Bootstrap框架。在Bootstrap官网最后我们可以定制自己的Bootstrap，可根据项目的需要自行选择不同的Less文件。在《深入理解Bootstrap》一书中以图表的形式概括了Bootstrap整体架构，图片如下：在接下来的文章中，将对Bootstrap框架中一些常用的样式及组件进行分析，经过自己梳理使得对Bootstrap更加了解了。整个Bootstrap源码可分为4个部分：第一部分是定义的变量及混合，方便后面的css属性使用，这也使得后期的修改和维护将更加的容易。第二部分是css初始化和依赖项，这部分也是为后面的css做准备，这部分包括normalize标准化css样式库和打印样式及字体。第三部分是核心CSS，这里包括许多常用的表格、表单及按钮等样式，最重要的是引入了栅格系统，这正是Bootstrap支持响应式的根本。第四部分是常用的CSS组件，这里将介绍网页中常用的各种样式组件，如果还有其他组件这里还可以继续扩充，这使得Bootstrap能都不断完善。第五部分是javascript组件库所需的样式。第六部分是常用的工具类，包括响应式工具类和打印类在Bootstrap框架的实际使用中，我们不仅要知道各种样式的成因，还需要熟练使用他们的类名与HTML的完美配合才能体现书Bootstrap框架的魅力。","tags":[{"name":"Bootstrap","slug":"bootstrap","permalink":"https://jesse121.github.io/tags/bootstrap/"}]},{"title":"CSS模糊效果及其兼容方法","date":"2016-09-25T16:00:00.000Z","path":"articles/html-css/css-blur-effect-and-its-compatibility-method.html","text":"今天在整理IE滤镜时网站访问这里，居然找到模糊滤镜blur(),感觉太不可思议了，想不到IE居然会有这么多种滤镜效果，这基本上是模仿PS的。今天的重点是模糊滤镜 CSS模糊效果及其兼容方法实例 兼容方法 chrome:-webkit-filter:blur(3px); IE8及以下：需要注意的是IE下模糊程度较浅一点，可以将PixelRadius的值适当调大一些filter: progid:DXImageTransform.Microsoft.Blur(PixelRadius='5'); FireFox:filter:url(blur.svg#blur);需要引入blur.svg文件，其文件内容是：&lt;svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;filter id=\"blur\"&gt;&lt;feGaussianBlur stdDeviation=\"3\" /&gt;&lt;/filter&gt;&lt;/svg&gt; 可以拷贝下来另存为blur.svg;","tags":[{"name":"CSS","slug":"css","permalink":"https://jesse121.github.io/tags/css/"}]},{"title":"《Javascript语言精粹》修订版--读书笔记","date":"2016-09-19T16:00:00.000Z","path":"articles/notes/javascript-the-good-parts.html","text":"第二章、语法语句下面列出的值被当做false，其他为true： false(boolean) 0和NaN(number) 空字符串(string) null(null) undefined(undefined) 表达式运算符优先级 运算符 作用 . [] () 提取属性与调用函数 delete new typeof + - ! 一元运算符 * / % 乘除取余 + - 加法/连接、 减法 &gt;= &lt;= &gt; &lt; 不等式运算 === !== 等式运算 &amp;&amp; 逻辑与 ll 逻辑或 ?: 三元运算 第四章、函数调用参数this的值取决于调用模式：方法调用模式当一个函数被保存为对象的一个属性时，我们称它为一个方法。方法被调用时,this被绑定到该对象。通过this可取得所属对象的公有方法var myObject = &#123; value:0, increment:function(inc)&#123; this.value += typeof inc === 'number' ? inc : 1; console.log(this); //&#123;value:1,increment:function()&#123;&#125;&#125; &#125;&#125; 函数调用模式当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的，以此模式调用函数时，this被绑定到全局对象。var myObject = &#123; value : 0, increment : function(inc)&#123; this.value += typeof inc === 'number' ? inc : 1; console.log(this); //&#123;value:1,increment:function()&#123;&#125;&#125; &#125;, double : function()&#123; var helper = function()&#123; console.log(this); //window &#125;; helper(); &#125;&#125; 构造器调用模式如果一个函数前面带上new来调用，那么背地里将会创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到那个新对象上。function Quo(string)&#123; this.status = string;&#125;Quo.prototype.getStatus = function()&#123; return this;&#125;var myQuo = new Quo(\"confused\");console.log(myQuo.getStatus()); //Quo &#123;status: \"confused\"&#125; Apply调用模式apply方法允许我们构建一个函数数组传递给调用函数，也允许选择this的值var statusObject = &#123; status: \"ok\"&#125;;function Quo(string)&#123; this.status = string;&#125;Quo.prototype.getStatus = function()&#123; return console.log(this); //&#123;status: \"ok\"&#125;&#125;Quo.prototype.getStatus.apply(statusObject); 第七章 正则表达式\\ / [ ] ( ) { } ? + * | . ^ $ 这些特殊字符都需要\\来进行转义 第八章 方法Arrayarray.sort()如果这两个参数相等则返回0，如果第1个参数应该排在前面，则返回一个负数，如果第2个参数应该排在前面，则返回一个正数。","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"韩顺平PHP从入门到精通视频教程笔记","date":"2016-09-06T16:00:00.000Z","path":"articles/php/韩顺平PHP从入门到精通视频教程笔记.html","text":"37 整型细节说明$a;echo $a; var_dump($a) //NULL 一个数总是要占用内存空间(字节)，在php中一个整数一般占用四个字节(与平台相关)，一个字节占用8bitphp的整数的二进制的最高位表示符号 0 表示正数 1 表示负数通过PHP_INT_SIZE可以显示我们自己的电脑上一个整数用几个字节表示echo PHP_INT_SIZE; //4 我的电脑中一个整数是4个字节 32bitecho PHP_INT_MAX; //整型最大的数为2147483647 最大负数为-2147483647//2147483647 = 2^31 - 1 二进制表示01111111 11111111 11111111 11111111 如果给定一个数超出了int范围，将会解释为float 38 布尔数细节 浮点数细节 字符串字节布尔数细节以下值被当做false: 布尔值false 整型值0 浮点值0.0 空字符串以及字符串“0” 不包括任何元素的数组 不包括任何成员的对象 特殊类型NULL(包括未设定的变量) 浮点数细节浮点数的字长和平台相关，通常最大值是1.8e308并具有14位十进制数字的精度浮点数精度是14位(从左边开始第一个非零的数就是精度的第一位)$a = 0.1234567890222298;echo $a; //0.12345678902223 字符串细节$a = “hello” //$a 占用5个字节“”中的变量将被解析，‘’中的变量直接输出其字符本身 39 算术运算符 比较运算符 逻辑运算符$a=10;$b=7;if($a++&gt;10 &amp;&amp; $b++&gt;7)&#123; //注意后++和前++的运算顺序 echo 'ok' //不输出&#125;echo $a; //11echo $b; //7$f = false or true;echo $f; //false or的优先级比=还低 and &amp;&amp; 都表示逻辑与 区别在于&amp;&amp;的优先级比and高or || 都表示逻辑或 区别在于||的优先级比or高 44 布置练习$_REQUEST()接受的参数要和提交数据的页面给出的html元素名字一致，否则接受的数据是null或”” 45 break continue 常量break/continue语句可以接受一个可选的数字参数来决定跳出几重循环geto语句常用来跳出循环或switch，可替代多层break 47 函数使用include与require区别： 当include包含的文件出错时，提出警告，程序继续往下执行 当require包含的文件出错时，致命性错误，终止程序 include_once与require_once 当需包含的文件已经包含时，则不执行项目中经常使用require_once,放在页面头部 48 函数调用深入理解含糊调用时会开辟一个新栈，各栈中变量是相互独立的，参数是以值形式传递函数名不区分大小写在PHP中错误有3种形式： Notice：注意 Warning：警告 Error：错误 51 位运算 二进制的最高位是符号位：0 表示正数，1表示负数 原码：用二进制来表示的代码 正数的原码 反码 补码 都一样 负数的反码：原码符号位不变，其他位取反(0-&gt;1 1-&gt;0) 负数的的补码：反码+1 0的反码补码都是0 php无符号数 在计算机运算的时候都是以补码来运算的 按位与&amp;： 两个全为1，结果为1 按位或|： 两个中有一个为1，结果为1 按位异或^：两个一个为0,一个为1，结果为1 按位取反~：0=&gt;1 1-&gt;0 算术左移&lt;&lt;：符号位不变，低位补0 (左移1位相当于乘以1个2) 算术右移&gt;&gt;: 低位溢出，符号位不变，并用符号位补溢出的高位 55 数组使用细节unset()可以删除数组中的某个值，该索引不会重新自动建立。也可销毁某个变量，$a + $b 数组的联合操作$a = array( \"a\" =&gt; \"apple\" , \"b\" =&gt; \"banana\" ); $b = array( \"a\" =&gt; \"pear\" , \"b\" =&gt; \"strawberry\" , \"c\" =&gt; \"cherry\" ); $c = $a + $b ; // Union of $a and $b echo \"Union of \\$a and \\$b: \\n\" ; var_dump ( $c ); //array( \"a\" =&gt; \"apple\" , \"b\" =&gt; \"banana\" ,\"c\" =&gt; \"cherry\") $c = $b + $a ; // Union of $b and $a echo \"Union of \\$b and \\$a: \\n\" ; var_dump ( $c ); //array( \"a\" =&gt; \"pear\" , \"b\" =&gt; \"strawberry\" , \"c\" =&gt; \"cherry\" ) 提交给当前页面时，阻止Notice报错的方法： 将php.ini文件中的error_reporting改为：error_reporting = E_ALL &amp; ~E_NOTICE 在当前页面添加error_reporting(E_ALL ^E_NOTICE); 添加一个隐藏的input&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;submitted&quot;&gt;在php文件中if(isset($_POST[&#39;action&#39;]) &amp;&amp; $_POST[&#39;action&#39;] == &quot;submitted&quot;){} 56 排序方法常用排序方法： 内部排序法 交换式排序法 冒泡排序法 基本思想：每走一次外层循环就排好一个数，里层循环的循环次数也就少了一个 快速排序法 选择式排序法 选择排序法 基本思想：第一次外层循环选出数组中最小的数与原数组第一个数交换，第二次循环从剩余的数(不包括第一项)中选出最小的数与原数组第二个数交换…… 堆排序法 插入式排序法 插入排序法 基本思想：把n个待排序的数分为一个有序表(含一个元素)和一个无序表(含n-1个元素)，排序过程中依次从无序表中取出一个数与有序表中的元素进行排序并插入适当位置。 谢尔排序法 二叉树排序法 外部排序法 冒泡排序法function bubbleSort(&amp;$array)&#123; //数组默认传递的是值 $temp = 0; for($i = 0;$i &lt; count($array) -1;$i++)&#123; for($j = 0;$j &lt; count($array) - 1 -$i;$j++)&#123; if($array[$j] &gt; $array[$j+1])&#123; //从小到大排列 $temp = $array[$j]; $array[$j] = $array[$j+1]; $array[$j+1] = $temp; &#125; &#125; &#125;&#125; 选择排序法 效率比选择排序法稍高，不是每一次都需要交换function selectSort(&amp;$array)&#123; $temp = 0; for($i = 0;$i &lt; count($array) - 1;$i++)&#123; $minVal = $array[$i]; //假设$i就是最小值 $minValIndex = $i; for($j = $i+1;$j &lt; count($array);$j++)&#123; if($minVal &gt; $array[$j])&#123; //从小到达排列 $minVal = $array[$j]; //找最小值 $minValIndex = $j; &#125; &#125; $temp = $array[$i]; $array[$i] = $array[$minValIndex]; $array[$minValIndex] = $temp; &#125;&#125; 插入排序法function insertSort(&amp;$array)&#123; //从小到大排列 //先默认$array[0]，已经有序，是有序表 for($i = 1;$i &lt; count($array);$i++)&#123; $insertVal = $array[$i]; //$insertVal是准备插入的数 $insertIndex = $i - 1; //有序表中准备比较的数的下标 while($insertIndex &gt;= 0 &amp;&amp; $insertVal &lt; $array[$insertIndex])&#123; $array[$insertIndex + 1] = $array[$insertIndex]; //将数组往后挪 $insertIndex--; //将下标往前挪，准备与前一个进行比较 &#125; if($insertIndex + 1 !== $i)&#123; $array[$insertIndex + 1] = $insertVal; &#125; &#125;&#125; 快速排序法function quickSort($array)&#123; if(!isset($array[1])) return $array; $mid = $array[0]; //获取一个用于分割的关键字，一般是首个元素 $leftArray = array(); $rightArray = array(); foreach($array as $v) &#123; if($v &gt; $mid) $rightArray[] = $v; //把比$mid大的数放到一个数组里 if($v &lt; $mid) $leftArray[] = $v; //把比$mid小的数放到另一个数组里 &#125; $leftArray = quickSort($leftArray); //把比较小的数组再一次进行分割 $leftArray[] = $mid; //把分割的元素加到小的数组后面，不能忘了它哦 $rightArray = quickSort($rightArray); //把比较大的数组再一次进行分割 return array_merge($leftArray,$rightArray); //组合两个结果&#125; 58 顺序查找 二分法查找顺序查找function search(&amp;$array,$findVal)&#123; $flag = false; for($i = 0;$i &lt; count($array);$i++)&#123; if($findVal == $array[$i])&#123; echo \"find it,it's index is $i\"; $flag = true; break; //找到第一个就停止 &#125; &#125; if(!$flag)&#123; echo 'can not find it!' &#125;&#125; 二分法查找二分法查找的前提是数组已排序好首先找到数组的中间数，与要找的数进行比较，如果要找的数大于中间数，则向后找，如果要找的数小于中间数，则向前找，如果相等则已找到。function binarySearch(&amp;$array,$findVal,$leftIndex,$rightIndex)&#123; if($leftIndex &gt; $rightIndex)&#123; echo \"找不到！\"; &#125; $middleIndex = round(($leftIndex + $rightIndex)/2);//找到中间数下标 if($findVal &gt; $array[$middleIndex])&#123; //如果要找的数大于中间数，则向后找 binarySearch($array,$findVal,$middleIndex + 1,$rightIndex); &#125;else if($findVal &lt; $array[$middleIndex])&#123; //如果要找的数小于中间数，则向前找 binarySearch($array,$findVal,$leftIndex,$middleIndex - 1); &#125;else&#123; //如果相等则已找到 echo \"find it,it's index is $middleIndex\"; &#125;&#125; 64 函数传递即本数据类型和数组的方式函数在传递基本数据类型(整型 浮点型 字符串 布尔型)是以值传递的，加上&amp;符号之后是以引用传递在传递数组时，默认也是按值传递 67 构造方法对象在创建时即使类中没有明确定义构造方法，会使用默认的构造方法，一旦定义构造方法默认的将被覆盖构造方法的默认修饰符是public构造方法中的形参个数与对象创建时的实参个数需一致 68 析构方法析构函数的作用是释放资源的操作，并不是销毁对象本身销毁的顺序是先创建的对象最后被销毁，按栈(先入后出)顺序什么时候调用？ 当程序(进程结束)退出的时候 当一个对象成为垃圾对象(没有任何引用指向它)的时候，析构方法立即调用 69 静态变量定义静态变量： [访问修饰符] static $变量名静态变量的访问： 如果在类中访问 self::$变量名 如果在类外访问 类名::$变量名 静态变量属于类的 class Person&#123; public static $a = 90; public function __construct()&#123; //代码未执行 $this -&gt; a = 45; &#125;&#125;echo Person::$a; //90 70 静态方法静态方法也叫类方法，是属于所有对象的实例[访问修饰符] static 方法名(){}常用静态方法操作静态变量，而不能操作非静态变量在类外部： 类名::类方法名 或者 对象名-&gt;类方法名在类内部： self::类方法名 或者 类名::类方法名 71 面向对象特性成员属性前必须指定访问修饰符成员方法前默认访问修饰符为public protected和public所修饰的成员属性和成员方法在被子类继承时，修饰符不变子类实例化时默认不会调用父类的构造方法，若需要调用可使用父类名::方法名或者parent::方法名来使用PHP5默认情况下不直接支持重载，但可通过魔术方法__call()来实现重载效果在方法的覆盖时，子类的访问权限不能小于父类的访问权限 75 抽象类抽象类主要用途是让子类来继承，其本身并不需要实例化，这样可以达到代码复用。用abstract来修饰一个类中只要含有抽象方法，则该类必须声明为抽象方法抽象类实质是子类的父类，它可以有抽象方法，也可以有可实例化的方法abstract class Animal&#123; public $name=\"abc\"; protected $age; abstract public function cry(); public function getName()&#123; return $this-&gt;name; &#125; public static function test()&#123; echo \"可以条调用\"; &#125;&#125;class Cat extends Animal&#123; public function cry()&#123; echo \"miaomiao\"; &#125;&#125;$cat1 = new Cat();$cat1-&gt;cry();echo $cat1-&gt;getName(); //abcAnimal::test(); //可以条调用 76 接口接口的作用主要是制定规范(定义方法或属性，供类来实现它)。interface 接口名1&#123; const A=90; //可以定义常量 public function start();&#125;interface 接口名2&#123; public function stop();&#125;class 类名 implements 接口名1，接口名2&#123; //可实现多个接口 public fucntion start()&#123; //your code &#125; public fucntion stop()&#123; //your code &#125;&#125;echo 接口名1::A; //90 接口名一般以i开头 接口不能实例化，只能由类来实现 接口里的所有方法都没有方法体，只有当某个类去实现它的时候才把写出方法体 一个类可以实现多个接口，需用逗号隔开 接口中可以有属性，但必须是常量，并且是public 接口中的方法必须是public,默认是public 接口不能继承类，但是接口可以继承多个其他接口 实现接口是对单一继承的补充 interface iUsb1&#123; public function a();&#125;interface iUsb2&#123; public function b();&#125;interface iUsb extends iUsb1,iUsb2&#123; public function c();&#125;class usb implements iUsb&#123; //必须全部实现所有接口定义的方法 public function a()&#123;&#125; public function b()&#123;&#125; public function c()&#123;&#125;&#125; 77 final const如果我们希望某个类不被其他类继承时，可以使用final修饰符如果我们希望某个方法不能被子类改写，可以使用final修饰符final不能修饰成员属性类中常量const基本用法 const 常量名=值访问： 类名::常量名 或 接口名::常量名常量名应全部大写，并且前面不能有$符，常量在定义是必须赋值，常量是属于类的 81 错误处理set_error_handle();设置自定义错误处理函数trigger_error();错误触发器error_log();向指定的文件发送个错误记录 82 异常处理当捕获到一个异常后，try块中的后续代码不被继续执行 84 HTTP协议深度剖析1 HTTP请求报文基本结构 请求行 GET http://localhost/Study/PHP/demo/84.html HTTP/1.1 首部字段 Host: localhost Proxy-Connection: keep-alive Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8 Accept-Encoding: gzip, deflate, sdch, br Accept-Language: zh-CN,zh;q=0.8 Cookie: _ga=GA1.1.1178440987.1493386332 空行 报文主体 GET请求的数据会显示在地址栏，POST请求发送的数据会在这里显示 HTTP响应报文基本结构 状态行 HTTP/1.1 200 OK 首部字段 Date: Sat, 29 Apr 2017 11:06:17 GMT Server: Apache Vary: Accept-Encoding Content-Encoding: gzip Cache-Control: max-age=0 Expires: Sat, 29 Apr 2017 11:06:17 GMT Content-Length: 275 Keep-Alive: timeout=5, max=100 Connection: Keep-Alive Content-Type: text/html; charset=UTF-8 空行 报文主体 请求的内容（一般是网页代码） get/post的区别 安全性 get请求的数据会显示在地址栏，post请求的数据放在http协议的请求体 数据大小 http协议本身并不限制请求数据大小，浏览器会限制url的长度 get请求携带参数可以更好的添加到收藏夹 利用$_SERVER[‘HTTP_REFERER’]实现防盗链if(isset($_SERVER['HTTP_REFERER']))&#123; if(strpos($_SERVER['HTTP_REFERER'],\"http://www.127.0.0.1/\") == 0 )&#123; echo \"正常访问\"; &#125;else&#123; header(\"Location：Waarning.php\"); &#125;&#125;else&#123; echo \"你是非法盗链者\";&#125; 85 HTTP协议深度剖析2 (状态码说明)302 重定向header(\"Location:84.html\"); 304 未修改，从缓存中提取echo \"hello &lt;br&gt;\";echo \"&lt;img src='1.jpg'&gt;\" chrome浏览器默认不发出304请求，直接是使用缓存（前提是允许缓存） 86 HTTP协议深度剖析3（禁用缓存）因为各个浏览器控制缓存的方式不同，一般以下三个属性都设置header(\"Expires:-1\");header(\"Cache-Control:no-cache\");header(\"Pragma:no-cache\"); 87 HTTP协议深度剖析4（文件下载 ）/** * [fileDown description] * @param [type] $file_name [文件名称] * @param [type] $file_sub_dir [下载文件子路径] * @return [type] [返回文件数据] */function fileDown($file_name,$file_sub_dir)&#123; //对文件名中的中文进行转码 $file_name = iconv(\"utf-8\",\"gb2312\",$file_name); //文件绝对路径 $file_path = $_SERVER['DOCUMENT_ROOT'].$file_sub_dir.$file_name; if(!file_exists($file_path))&#123; echo \"文件不存在！\"; return ; &#125; //文件指针 $fp = fopen($file_path, \"r\"); //文件大小 $file_size = filesize($file_path); //返回的文件类型 header(\"Content-type: application/octet-stream\"); //按照字节返回 header(\"Accept-Ranges: bytes\"); header(\"Accept-Length: $file_size\"); //浏览器弹出对话框 对应文件名 header(\"Content-Disposition: attachment;filename=\".$file_name); //向客户端回送数据 $buffer = 1024; //为了下载的安全，最好做一个文件字节读取计数器 $file_count = 0; while(!feof($fp) &amp;&amp; ($file_size - $file_count &gt; 0))&#123; $file_data = fread($fp,$buffer); //统计读了多少个字节 $file_count += $buffer; echo $file_data; &#125; //关闭文件 fclose($fp);&#125;fileDown(\"截图.jpg\",\"study/php/exercise/\") 89 PHP数据库编程-使用mysql扩展库php有三种方式来操作我们的MySQL数据库 mysql扩展库 mysqli扩展库 pdo扩展库 在php.ini文件中配置mysql扩展库，去掉extension=php_mysql.dll前面的注释符 创建数据库和test表CREATE DATABASE IF NOT EXISTS test;USE test;CREATE TABLE user1( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(32) NOT NULL, password VARCHAR(64) NOT NULL, email VARCHAR(123) NOT NULL, age TINYINT UNSIGNED NOT NULL);INSERT INTO user1(name,password,email,age) VALUES ('zs',md5('123456'),'zs@sohu.com',30),('ls',md5('123456'),'ls@sohu.com',40),('ww',md5('123456'),'ww@sohu.com',50);INSERT INTO user1(name,password,email,age) VALUES ('顺平',md5('123456'),'sp@sohu.com',60);//查看mysql客户端字符集编码方式show variables like '%char%';//若客户端出现不支持中文时，可如下设置set chatacter_set_client=gbk;set chatacter_set_result=gbk;SHOW TABLES;//查看该数据库下有哪些表DESE user1; //查看user1表 char(10)固定长度大小，varchar(32)长度可变，多余可以回收 编写php程序 //mysql扩展库操作mysql数据库步骤如下 //1. 获取连接 $conn=mysql_connect(\"127.0.0.1\",\"root\",\"131978\"); if(!$conn)&#123; die(\"连接失败\".mysql_error()); &#125; //2. 选择数据库 mysql_select_db(\"test\"); //3. 设置操作编码(建议有)!!! mysql_query(\"set names utf8\"); //保证我们的php程序是按照utf8码操作. //4. 发送指令sql (ddl 数据定义语句 , dml(数据操作语言 update insert ,delete) ,dql (select ), dtl 数据事务语句 rollback commit... ) $sql=\"select * from user1\"; //函数 //$res 表示结果集，你可以简单的理解就是 一张表. $res=mysql_query($sql,$conn); //var_dump($res); //mysql result 资源类型 //5. 接收返回的结果，并处理.(显示) // mysql_fecth_row 会依次取出$res结果集的下一行数据,赋值给$row // $row就是一个数组, 样式array(5) &#123; [0]=&gt; string(1) \"1\" [1]=&gt; string(2) \"zs\" [2]=&gt; string(32) \"e10adc3949ba59abbe56e057f20f883e\" [3]=&gt; string(11) \"zs@sohu.com\" [4]=&gt; string(2) \"30\" &#125; //mysql_fetch_assoc mysql_fetch_array while($row=mysql_fetch_row($res))&#123;//第一种取法是 同 $row[$i]//echo \"&lt;br/&gt; $row[0]--$row[1]--$row[2]\";//echo \"&lt;br/&gt;\";//var_dump($row);//第二种取法 foreach($row as $key =&gt; $val)&#123; echo \"--$val\"; &#125; echo \"&lt;br/&gt;\"; &#125; //6.释放资源 mysql_free_result($res); //关闭连接,无需写会自动关闭 mysql_close($conn); 处理mysql资源的几种方法：mysql_fetch_row()该函数将一条结果记录返回并以一个普通索引数组的形式保存mysql_fetch_assoc()该函数将一条结果记录返回并以一个普通关联数组的形式保存mysql_fetch_object()该函数将一条结果记录返回一条结果记录，各个字段需要以对象的形式访问mysql_fetch_array() 不推荐使用该函数可以将结果数据表中的每一行获取为一个关联数组或索引数组，或同时为关联数组和索引数组 对数据表的增删修改操作//增加数据操作 返回bool类型 无需释放资源$sql = “INSERT INTO user1 (name,password,email,age) VALUES (‘小明’,md5(‘123’),’xiaoming @sohu.com’,34)”;//删除数据操作 返回bool类型 无需释放资源$sql = “DELETE FROM user1 WHERE id=6”;//查询数据操作 返回资源类型$sql=”SELECT * FROM user1”;//更改数据操作 返回bool类型 无需释放资源$sql = “UPDATE user1 SET age=100 WHERE id=4”; 94 PHP数据库编程-使用mysqli扩展库mysqli是mysql扩展库的增强版在php.ini文件中启用mysqli的扩展，取掉extension=php_mysqli.dll文件前的注释 mysqli的稳定性和安全性，效率有所提高 mysqli支持面向对编程，同时也支持面向过程风格 header(\"Content-type: text/html;charset=utf-8\");//mysql操作mysql数据库(面向对象风格)//1.创建mysql 对象$mysqli=new mysqli(\"localhost\",\"root\",\"131978\",\"test\");//验证是否okif($mysql-&gt;connect_error)&#123; die(\"Connect Error\".$mysql-&gt;connect_error);&#125;//2. 操作数据库(发送sql)$sql=\"select * from user1\";//$res 是结果集.mysql result$res=$mysqli-&gt;query($sql);//var_dump($res);//3. 处理结果;while($row=$res-&gt;fetch_row())&#123; foreach($row as $key=&gt;$val)&#123; echo \"--$val\"; &#125; echo \"&lt;br/&gt;\";&#125;//4. 关闭资源,释放内存$res-&gt;free();//关闭连接$mysql-&gt;close(); 处理mysqli资源的4种方法：fetch_row()该函数将一条结果记录返回并以一个普通索引数组的形式保存fetch_assoc()该函数将一条结果记录返回并以一个普通关联数组的形式保存fetch_object() 不推荐使用该函数将一条结果记录返回一条结果记录，各个字段需要以对象的形式访问fetch_array() 不推荐使用该函数可以将结果数据表中的每一行获取为一个关联数组或索引数组，或同时为关联数组和索引数组 MYSQL语句的特别说明如果操作的字段类型为字符串型，则要求我们要使用单引号包起来如果操作的字段类型为数值型，则可以使用单引号包起来，也可以不用 101 $_POST在复选框表单提交时需注意：&lt;form action=\"test.php\" method=\"post\"&gt;&lt;input type=\"checkbox\" name=\"hobby[]\" value=\"book\"&gt; //复选框的name值需写为数组格式&lt;input type=\"checkbox\" name=\"hobby[]\" value=\"write\"&gt;&lt;/form&gt; 114 cookieIE浏览器的cookies文件位置在C:\\Users\\Jesse\\AppData\\Local\\Microsoft\\Windows\\Temporary Internet Files以*.txt文件形式保存Chrome浏览器cookies文件在C:\\Users\\Jesse\\AppData\\Local\\Google\\Chrome\\User Data\\Default但是被加密过 创建cookiebool setCookie ( string $name [, string $value [, int $expire = 0 [,string $path [,string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] )//第三个参数是表示cookiess在客户端保存多长时间按秒计算//若不写则cookies不会保存，会话结束cookies失效//只能保存字符串setCookie(\"name\",\"jesse\",time()+3600); 获取cookie$name = $_COOKIE[&#39;name&#39;];超过有效期则cookie不会写入http首部字段，不同的键值对可以指定不同的有效时间cookie也可以保存中文，中文默认采用urlencode编码 更新cookie重新设置cookiesetCookie(&quot;name&quot;,&quot;jack&quot;.time()+60); 删除cookie要删除某个键值对时，只需把过期时间改成比当前时间还小即可setCookie(&#39;name&#39;,&#39;jesse&#39;,time()-1)要删除全部cookie 遍历删除foreach($_COOKIE as $key=&gt;$value)&#123; setCookie($key,\"\",time()-1);&#125; cookie全部删除时cookie文件也将被删除 117 sessionsession是一种服务端技术，服务器在运行时可以为每个用户创建一个其独享的session文件，当用户再去访问服务器中其他web资源时，服务器将从各自的session文件中取出数据。一个会话对应一个session文件， session可以存储的数据类型有string boolean integer double array object要使用session都必须初始化session_start() 创建session//1.初始化session session_start();$_SESSION['name']=\"jesse\";$_SESSION['age']=\"25\";$arr1 = array(\"one\",\"two\",\"three\");$_SESSION['arr1']=$arr1; 获取sessionsession_start();echo \"&lt;pre&gt;\";print_r($_SESSION);echo \"&lt;br/&gt;\";//通过key获取指定的值echo $_SESSION[\"name\"];echo \"&lt;/pre&gt;\";//如果我们需要取出对象，则需要事先申明该对象的类的信息require_once(\"dog.class.php\"); 更新sessionsession_start();$_SESSION['name']=\"jack\"; 删除session数据//1.删除某一个sessionsession_start();unset($_SESSION['name']);//2.删除全部session//删除当前浏览器对应的session文件session_destroy(); session数据默认保存1440s，在php.ini中可更改session.gc_maxlifetime = 1440session文件默认把文件存在服务器的c:/window/temp，在php.ini中可更改本机session保存路径C:\\Users\\apache\\AppData\\Local\\Temp;Session和Cookie的主要区别在于： 存储的位置 Cookie是把用户的数据存入用户的浏览器 Session技术是把用户的数据写到该用户独占的$_SESSION中，存于服务器的相应路径下的文件中 安全性 session的安全性高 网络传输量 cookie通过网络在客户端和服务器传输，session无需传输 如果用户禁用cookie，服务器每次session_start()都会创建一个全新的session文件，导致多个php页面无法共享一份session文件 用户禁用cookie可以通过一下方法解决共享session 在每个超链接 action header(“Location:***”)中拼接SID常量即可 启用session.use_trans_sid，这样在链接跳转的地方会自动传输session,不推荐使用 session垃圾回收机制session.gc_probability = 1;session.gc_divisor = 1000;当某个用户操作session的时候使用到sesion_start(),该函数会调用session垃圾回收机，其发生的概率是session.gc_probability/session.gc_divisor。网站规模越大，这个值设置的越小越好","tags":[{"name":"PHP","slug":"php","permalink":"https://jesse121.github.io/tags/php/"}]},{"title":"《细说PHP》第二版--读书笔记","date":"2016-08-21T16:00:00.000Z","path":"articles/notes/细说PHP-第二版.html","text":"第五章 PHP的基本语法5.2.4 在程序中使用空白的处理 5.3 变量5.3.1 变量的声明在php中变量的声明必须是使用一个$符号，后面跟变量名来表示unset()函数释放指定变量isset()函数检测变量是否设置empty()函数检查一个变量是否为空 5.3.2 变量的命名变量命名严格区分大小写，但内置结构和关键字以及用户自定义的类名和函数名都是不区分大小写变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。 5.3.4 变量的引用赋值变量的引用赋值，意味着新的变量只是简单的引用了原始变量（并没有执行赋值操作），因而改动新的变量会影响到原始变量。使用引用赋值，简单的将&amp;符号添加到将要赋值的变量前$bar = &amp;$foo;只有有名字的变量才可以引用赋值 变量的类型5.4.1 类型的介绍PHP支持8中原始数据类型： 4种标量类型 boolean integer float string 两种复合类型 array object 两种特殊类型 resource null 如果想查看某个表达式的值和类型，可以使用函数var_dump() 5.4.3 布尔型以下值被认为是false: 布尔值false 整型值0 浮点型值0.0 空白字符串和字符串“0” 没有成员变量的数组 特殊类型null 5.4.4 整型八进制和十六进制的整型表达式的计算结果均以十进制数字输出 5.4.5 字符串字符串有单引号 双引号 定界符三种方法定义单引号中不能再包含单引号，可添加反斜线转义单引号中的变量不会被变量的值替代，而是将变量名原样输出双引号最重要的一点是其中的变量名会被变量值替代，即PHP可以解析双引号中包含的变量定界符&lt;&lt;&lt;EOT stringEOT; 5.4.6 数组使用print_r()函数查看数组中的全部内容 5.4.7 对象要初始化一个对象，用new语句将对象实例化到一个变量中 5.4.8 资源类型资源是一种特殊类型的变量，保存到外部资源的一个引用$file_handle = fopen(\"info.txt\",\"w\");var_dump($file_handle); 5.4.9 nullnull值表示一个变量没有值，不区分大小写在下列情况变量将被认为是null： 将变量直接赋值位null 声明的变量尚未被赋值 被unset()函数销毁的变量 5.4.11 数据类型转换只有相同类型的数据才能彼此操作，自动转换要遵循按数据长度增加的方向进行强制类型转换需要在转换的变量之前加上用括号括起来的目标类型，也可以使用转换函数intval()获取变量的整数值floatval() 获取变量的浮点值strval() 获取变量的字符串值以上强制类型转换都没有改变被转换变量本身的类型，而是通过转换将得到新类型数据赋值给新变量。如果需要将变量本身的类型改变成其他类型可使用setType()函数$foo = \"5bar\";settype($foo,\"integer\"); //$foo 现在是5 想得到一个易读懂的类型的表达方式用于调试可以使用gettype()函数查看某个类型用is_type()函数 5.5 常量5.5.1 常量的定义和使用在PHP中是通过使用define()函数来定义的，其命名规则与变量相似，按照惯例常量标识符总是大写，不要$符号define(string name,mixed value[,bool case_insensitive]);define(\"CON_INT\",100);echo CON_INT; 5.5.2 常量和变量常量和变量的不同点： 1.常量前没有$ 2.常量只能用define()函数定义，而不能通过赋值语句 3.常量可以再任意地方定义和使用，一旦定义就不能被重新定义或者取消定义 4.常量只能是标量 5.6 PHP中运算符5.6.1 算数运算符在做求模运算时首先会将 % 运算符两边操作数转化为整型，然后返回第一个操作数除以第二个操作数后所得到的余数。在程序开发中一般用于计算闰年和一个范围之内的随机数 5.6.6 位运算符 5.6.7 其他运算符三元运算符(expr1)?(expr2):(expr3)在expr1求值为true时执行expr2并获取其值，为false时执行expr3并获取其值执行运算符反引号（｀｀）PHP尝试将反引号中的内容作为操作系统命令来执行，并将其输出信息返回。使用反引号的效果与函数shell_exec()相同PHP中运算符优先级 第六章 PHP语言结构6.1流程控制顺序结构 语句按照出现的先后次序自上而下依次执行分支结构 先做判断再做选择 6.3.4 特殊的流程控制语句break语句结束当前for、foreach、while、do-while、switch结构循环的执行continue语句作用是跳过该次循环，继续执行下一次循环结构exit语句作用是直接退出当前脚本 6.4 PHP中的函数函数的调用 在需要使用函数的位置，使用函数名称和参数列表进行调用，执行完毕后返回调用位置继续向下执行函数的返回值是函数执行后的结果返回给调用者return语句可以向函数调用者返回函数体中任意确定的值，将程序控制权反回到调用者的作用域，即退出函数如果要返回多个值，可以将多个值添加到一个数组中，然后返回这个数组 6.4.4 PHP变量的范围局部变量 其作用域仅限于函数内部。不仅在函数中声明的变量是局部的，函数参数在函数名后面的括号内声明也是局部变量，当函数执行完毕后，函数内部的变量都被释放。如果在函数外部需要使用该变量值时，必须通过return语句全局变量 作用域从变量定义开始，到本程序文件末尾注意：在PHP函数中无法直接调用全局变量，若要使用全局变量，必须通过global关键字定义目标变量，以告诉函数此变量为全局变量。还可以在PHP中使用预定义的全局变量数组$GLOBALS局部变量可分为动态存储类型（默认）和静态存储类型（函数执行完毕后，内部变量依旧保存在内存中） 6.4.5 参数的传递PHP中参数默认是按值传递，即使在函数内部改变参数的值，他并不会改变函数外部的值按引用传递是把该数值或变量的内存储存区块相对地址导入函数之中，因此当该数值在函数中有任何变动时，会连带对父程序造成影响。可以在函数定义中在参数前预先加上&amp; 6.4.6 变量函数将函数名赋给变量，在程序中使用变量名并在后面加上圆括号时就调用那个函数执行 第七章 PHP中的数组及数组结构7.2 数组的定义7.2.1 直接赋值方式声明数组$arr[0] = 1;$arr[\"ID\"] = 1;$arr[3] = \"jesse\";$arr[\"company\"] = \"xxx\";$arr[] = \"aa\";print_r($arr); /*Array( [0] =&gt; 1 [ID] =&gt; 1 [3] =&gt; jesse [company] =&gt; xxx [4] =&gt; aa)*/ 如果没有指定索引值的元素与指定索引值的元素混在一起赋值时，没有指定索引值的元素的默认索引将紧跟索引元素中最高的索引值递增 7.2.2 使用array()构建新数组语法格式如下：$数组变量名 = array(key1=&gt;value1,key2=&gt;value2,key3=&gt;value3……keyN=&gt;valueN);如果不使用=&gt;符号指定下标，默认为索引数组，索引值从0 开始依次增加如果使用array()声明关联数组，就必须使用=&gt;运算符指定字符串下标 7.2.3 多维数组的声明$contact = array( array(1,\"jesse\",\"a\"), array(2,\"jack\",\"b\"), array(3,\"lucy\",\"c\"),);echo $contact[0][1]; //jesse 7.3 数组的遍历由于for语句的局限性，在php中很少使用 7.3.2 使用foreach语句遍历数组//第一种语法格式： foreach(array_expression as $value)&#123; //循环体&#125;//第二种语法格式：foreach(array_expression as $key =&gt; $value)&#123; //循环体&#125; 7.3.3 联合使用list() each()和while循环遍历数组each()each()函数需要传递一个数组作为参数，返回当前元素的键值对，并向后移动数组指针到下一个元素的位置。键值对被返回带有四个元素的关联和索引混合数组，键名分别为0,1,key,value。如果内部指针越过了数组的末端，则each()返回false$arr = array(\"id\"=&gt;1,\"name\"=&gt;\"jesse\");$id = each($arr);print_r($id); /*Array( [1] =&gt; 1 [value] =&gt; 1 [0] =&gt; id [key] =&gt; id)*/$name = each($arr);print_r($name);/*Array( [1] =&gt; jesse [value] =&gt; jesse [0] =&gt; name [key] =&gt; name)*/$no = each($arr);var_dump($no); //bool(false) list()list()不是真正的函数，是php语言结构，list()用一步操作给一组变量进行赋值，即把数组中的值赋值给变量$info = array('coffee','brown','caffeine');list($drink,$color,$power) = $info;echo \"$drink is $color and $power makes it special\";//coffee is brown and caffeine makes it speciallist(,,$power) = $info;echo \"i need $power!\"; //i need caffeine!$arr = array(\"id\"=&gt; 1,\"name\" =&gt; \"jesse\",\"email\" =&gt; \"xxx@163.com\");list($key,$value) = each($arr);echo \"$key =&gt; $value.\\n\"; //id =&gt; 1 while()$arr = array(\"id\"=&gt; 1,\"name\" =&gt; \"jesse\",\"email\" =&gt; \"xxx@163.com\");while(list($key,$value)=each($arr))&#123; echo \"$key =&gt; $value.\\n\"; &#125;/*id =&gt; 1name =&gt; jesseemail =&gt; xxx@163.com*/ 7.3.4 使用数组内部指针控制函数遍历数组 current():取得目前指针位置的内容资料 key():读取目前指针所指向的资料的索引值 next():将数组中内部指针移动到下一个单元 prev():将数组中的内部指针回到一位 end():将数组中的内部指针直到最后一位 reset();将数组中的内部指针重置到第一位 $arr = array(\"id\"=&gt; 1,\"name\" =&gt; \"jesse\",\"email\" =&gt; \"xxx@163.com\");echo key($arr).\"=&gt;\".current($arr).\"\\n\"; //id=&gt;1next($arr);next($arr);echo key($arr).\"=&gt;\".current($arr).\"\\n\"; //email=&gt;xxx@163.comprev($arr);echo key($arr).\"=&gt;\".current($arr); //name=&gt;jesse 7.4 预定义数组 7.5 数组的相关处理函数7.5.1 数组的键值操作函数array_values()array_values()的作用是返回数组中所有元素的值，只有一个参数，传入给定的数组$arr = array(\"id\"=&gt; 1,\"name\" =&gt; \"jesse\",\"email\" =&gt; \"xxx@163.com\");print_r(array_values($arr));/*Array( [0] =&gt; 1 [1] =&gt; jesse [2] =&gt; xxx@163.com)*/ array_keys()array_keys()的作用是返回数组中所有的键名array_keys ( array $input [, mixed $search_value = NULL [, bool $strict = false ]] ) input一个数组，包含了要返回的键。 search_value 如果指定了这个参数，只有包含这些值的键才会返回。 strict 判断在搜索的时候是否该使用严格的比较（===）。$arr = array(10,20,30,\"10\");print_r(array_keys($arr));/*Array([0] =&gt; 0 [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3)*/print_r(array_keys($arr,10));/*Array([0] =&gt; 0 [3] =&gt; 3)*/print_r(array_keys($arr,\"10\",true));/*Array([3] =&gt; 3)*/ in_array()in_array()的作用是检查数组中是否存在某个值，即在数组中搜索给定的值in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) needle待搜索的值。如果 needle 是字符串，则比较是区分大小写的。 haystack 这个数组。 strict 如果第三个参数 strict 的值为 TRUE 则 in_array() 函数还会检查 needle 的类型是否和 haystack 中的相同。 $os = array( \"Mac\" , \"NT\" , \"Irix\" , \"Linux\" );if ( in_array ( \"Irix\" , $os )) &#123; echo \"Got Irix\" ; //Got Irix&#125;if ( in_array ( \"mac\" , $os )) &#123; //区分大小写 echo \"Got mac\" ; &#125;$a = array( '1.10' , 12.4 , 1.13 );if ( in_array ( '12.4' , $a , true )) &#123; //类型不同 echo \"'12.4' found with strict check\\n\" ;&#125;if ( in_array ( 1.13 , $a , true )) &#123; echo \"1.13 found with strict check\\n\" ; //1.13 found with strict check&#125;$a = array(array( 'p' , 'h' ), array( 'p' , 'r' ), 'o' );if ( in_array (array( 'p' , 'h' ), $a )) &#123; echo \"'ph' was found\\n\" ; //'ph' was found&#125; array_search()在数组中搜索给定的值，如果成功则返回相应的键名array_search ( mixed $needle , array $haystack [, bool $strict = false ] )如果找到了 needle 则返回它的键，否则返回 FALSE 。如果 needle 在 haystack 中出现不止一次，则返回第一个匹配的键$array = array( 0 =&gt; 'blue' , 1 =&gt; 'red' , 2 =&gt; 'green' , 3 =&gt; 'red' ); $key = array_search ( 'green' , $array ); // $key = 2; $key = array_search ( 'red' , $array );// $key = 1; $key = array_search('orange',$array); //false array_key_exists()array_key_exists() 在给定的 key 存在于数组中时返回 TRUE 。key 可以是任何能作为数组索引的值。 array_key_exists() 也可用于对象。array_key_exists ( mixed $key , array $search ) key 要检查的键。 search 一个数组，包含待检查的键。 $search_array = array( 'first' =&gt; null , 'second' =&gt; 4 );array_key_exists ( 'first' , $search_array ); // returns true array_filp()array_flip ( array $trans )array_flip() 返回一个反转后的 array ，例如 trans 中的键名变成了值，而 trans 中的值成了键名。如果同一个值出现了多次，则最后一个键名将作为它的值，所有其它的都丢失了。$trans = array( \"a\" =&gt; 1 , \"b\" =&gt; 1 , \"c\" =&gt; 2 ); $trans = array_flip ( $trans ); print_r ( $trans ); //Array([1] =&gt; b [2] =&gt; c) array_reverse()array_reverse ( array $array [, bool $preserve_keys = false ] )array_reverse() 接受数组 array 作为输入并返回一个单元为相反顺序的新数组。$input = array( 4.0 ,\"php\" ,array( \"green\" , \"red\" ));$result_keyed = array_reverse ( $input);print_r($result_keyed); /*Array( [0] =&gt; Array([0] =&gt; green [1] =&gt; red) [1] =&gt; php [2] =&gt; 4)*/ 7.5.2 统计数组元素的个数和唯一性count()统计一个数组里的所有元素，或者一个对象里的东西。count ( mixed $var [, int $mode = COUNT_NORMAL ] )array_count_values()统计数组中所有的值出现的次数array_count_values ( array $input )返回一个数组，该数组用 input 数组中的值作为键名，该值在 input 数组中出现的次数作为值。$array = array( 1 , \"hello\" , 1 , \"world\" , \"hello\" ); print_r ( array_count_values ( $array ));/* Array([1] =&gt; 2 [hello] =&gt; 2 [world] =&gt; 1)*/ array_unique()移除数组中重复的值接受array作为输入并返回没有重复值的新数组。注意键名保留不变。先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名。$input = array( \"a\" =&gt; \"green\" , \"red\" , \"b\" =&gt; \"green\" , \"blue\" , \"red\" ); $result = array_unique ( $input ); print_r ( $result ); //Array( [a] =&gt; green [0] =&gt; red [1] =&gt; blue ) 7.5.3 使用回调函数处理数组的函数array_filter()用回调函数过滤数组中的单元array_filter ( array $input [, callable $callback = &quot;&quot; ] )依次将 input 数组中的每个值传递到 callback 函数。如果 callback 函数返回 TRUE ，则 input 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。如果没有提供 callback 函数， 将删除 input 中所有等值为 FALSE的条目。function odd ( $var )&#123; return( $var &amp; 1 );&#125;function even ( $var )&#123; return(!( $var &amp; 1 ));&#125; $array1 = array( \"a\" =&gt; 1 , \"b\" =&gt; 2 , \"c\" =&gt; 3 , \"d\" =&gt; 4 , \"e\" =&gt; 5 ); $array2 = array( 6 , 7 , 8 , 9 , 10 , 11 , 12 );echo \"Odd :\\n\" ; print_r ( array_filter ( $array1 , \"odd\" ));echo \"Even:\\n\" ; print_r ( array_filter ( $array2 , \"even\" ));/*Odd :Array( [a] =&gt; 1 [c] =&gt; 3 [e] =&gt; 5 )Even:Array( [0] =&gt; 6 [2] =&gt; 8 [4] =&gt; 10 [6] =&gt; 12 )*/ array_walk()使用用户自定义函数对数组中的每个元素做回调处理bool array_walk ( array &amp;$array , callable $funcname [, mixed $userdata = NULL ] )将用户自定义函数 funcname 应用到 array 数组中的每个单元。array_walk() 不会受到 array 内部数组指针的影响。 array_walk() 会遍历整个数组而不管指针的位置成功时返回 TRUE ， 或者在失败时返回 FALSE 。$fruits = array( \"d\" =&gt; \"lemon\" , \"a\" =&gt; \"orange\" , \"b\" =&gt; \"banana\" , \"c\" =&gt; \"apple\" );function test_alter (&amp; $item1 , $key , $prefix )&#123; $item1 = \" $prefix : $item1 \" ;&#125;function test_print ( $item2 , $key )&#123; echo \" $key . $item2 &lt;br /&gt;\\n\" ;&#125;echo \"Before ...:\\n\" ;array_walk ( $fruits , 'test_print' );array_walk ( $fruits , 'test_alter' , 'fruit' );echo \"... and after:\\n\" ;array_walk ( $fruits , 'test_print' ); array_map()将回调函数作用到给定数组的单元上array array_map ( callable $callback , array $arr1 [, array $... ] )返回一个数组，该数组包含了 arr1 中的所有单元经过 callback 作用过之后的单元。callback 接受的参数数目应该和传递给 array_map() 函数的数组数目一致。function cube ( $n )&#123; return( $n * $n * $n );&#125;$a = array( 1 , 2 , 3 , 4 , 5 );$b = array_map ( \"cube\" , $a );print_r ( $b );//Array( [0] =&gt; 1 [1] =&gt; 8 [2] =&gt; 27 [3] =&gt; 64 [4] =&gt; 125 ) 7.5.4 数组的排序函数 usort()使用用户自定义的比较函数对数组中的值进行排序bool usort ( array &amp;$array , callable $cmp_function )本函数将用用户自定义的比较函数对一个数组中的值进行排序。如果要排序的数组需要用一种不寻常的标准进行排序，那么应该使用此函数。function cmp ( $a , $b )&#123; if ( $a == $b ) &#123; return 0 ; &#125; return ( $a &lt; $b ) ? - 1 : 1 ;&#125; $a = array( 3 , 2 , 5 , 6 , 1 ); usort ( $a , \"cmp\" ); print_r($a);//Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 5 [4] =&gt; 6 ) array_multisort()bool array_multisort ( array &amp;$arr [, mixed $arg = SORT_ASC [, mixed $arg = SORT_REGULAR [, mixed $... ]]] )可以用来一次对多个数组进行排序，或者根据某一维或多维对多维数组进行排序。排序顺序标志： SORT_ASC - 按照上升顺序排序 SORT_DESC - 按照下降顺序排序 排序类型标志： SORT_REGULAR - 将项目按照通常方法比较 SORT_NUMERIC - 将项目按照数值比较 SORT_STRING - 将项目按照字符串比较 每个数组之后不能指定两个同类的排序标志。每个数组后指定的排序标志仅对该数组有效 - 在此之前为默认值 SORT_ASC 和 SORT_REGULAR 。 $ar1 = array( 10 , 100 , 100 , 0 ); $ar2 = array( 1 , 3 , 2 , 4 ); array_multisort ( $ar1 , $ar2 ); var_dump ( $ar1 ); var_dump ( $ar2 ); /*array(4) &#123; [0]=&gt; int(0) [1]=&gt; int(10) [2]=&gt; int(100) [3]=&gt; int(100) &#125; array(4) &#123; [0]=&gt; int(4) [1]=&gt; int(1) [2]=&gt; int(2) [3]=&gt; int(3) &#125;*/ $ar = array( array( \"10\" , 11 , 100 , 100 , \"a\" ), array( 1 , 2 , \"2\" , 3 , 1 ) ); array_multisort ( $ar [ 0 ], SORT_ASC , SORT_STRING ,$ar [ 1 ], SORT_NUMERIC , SORT_DESC ); var_dump ( $ar ); /* array(2) &#123; [0]=&gt; array(5) &#123; [0]=&gt; string(2) \"10\" [1]=&gt; int(100) [2]=&gt; int(100) [3]=&gt; int(11) [4]=&gt; string(1) \"a\" &#125; [1]=&gt; array(5) &#123; [0]=&gt; int(1) [1]=&gt; int(3) [2]=&gt; string(1) \"2\" [3]=&gt; int(2) [4]=&gt; int(1) &#125; &#125; */ 7.5.5 拆分 合并 分解 接合数组array_slice()array array_slice ( array $array , int $offset [, int $length = NULL [, bool $preserve_keys = false ]] )返回根据 offset 和 length 参数所指定的 array 数组中的一段序列。 array 输入的数组。 offset 如果 offset 非负，则序列将从 array 中的此偏移量开始。如果offset为负，则序列将从 array 中距离末端这么远的地方开始。 length 如果给出了 length 并且为正，则序列中将具有这么多的单元。如果给出了 length 并且为负，则序列将终止在距离数组末端这么远的地方。如果省略，则序列将从 offset 开始一直到 array 的末端。 preserve_keys注意 array_slice() 默认会重新排序并重置数组的数字索引。你可以通过将 preserve_keys 设为 TRUE 来改变此行为。 $input = array( \"a\" , \"b\" , \"c\" , \"d\" , \"e\" ); $output = array_slice ( $input , 2 ); // returns \"c\", \"d\", and \"e\" $output = array_slice ( $input , - 2 , 1 ); // returns \"d\" $output = array_slice ( $input , 0 , 3 ); // returns \"a\", \"b\", and \"c\"// note the differences in the array keys print_r ( array_slice ( $input , 2 , - 1 ));//Array( [0] =&gt; c [1] =&gt; d ) print_r ( array_slice ( $input , 2 , - 1 , true ));//Array( [2] =&gt; c [3] =&gt; d ) array_splice()array array_splice ( array &amp;$input , int $offset [, int $length = 0 [, mixed $replacement ]] )把 input 数组中由 offset 和 length 指定的单元去掉，如果提供了 replacement 参数，则用其中的单元取代。$input = array( \"red\" , \"green\" , \"blue\" , \"yellow\" );array_splice ( $input , - 1 , 1 , array( \"black\" , \"maroon\" ));// $input is now array(\"red\", \"green\",\"blue\", \"black\", \"maroon\") array_combine()array array_combine ( array $keys , array $values )返回一个 array ，用来自 keys 数组的值作为键名，来自 values 数组的值作为相应的值。$a = array( 'green' , 'red' , 'yellow' ); $b = array( 'avocado' , 'apple' , 'banana' ); $c = array_combine ( $a , $b ); print_r ( $c ); //Array([green] =&gt; avocado [red] =&gt; apple [yellow] =&gt; banana ) array_merge()array array_merge ( array $array1 [, array $... ] )将一个或多个数组的单元合并起来，一个数组中的值附加在前一个数组的后面。返回作为结果的数组。如果输入的数组中有相同的字符串键名，则该键名后面的值将覆盖前一个值。然而，如果数组包含数字键名，后面的值将不会覆盖原来的值，而是附加到后面。如果只给了一个数组并且该数组是数字索引的，则键名会以连续方式重新索引。$array1 = array( 0 =&gt; 'zero_a' , 2 =&gt; 'two_a' , 3 =&gt; 'three_a' ); $array2 = array( 1 =&gt; 'one_b' , 3 =&gt; 'three_b' , 4 =&gt; 'four_b' ); $result = $array1 + $array2 ; print_r( $result ); //Array( [0] =&gt; zero_a [2] =&gt; two_a [3] =&gt; three_a [1] =&gt; one_b [4] =&gt; four_b) array_intersect()array array_intersect ( array $array1 , array $array2 [, array $ ... ] ) 返回一个数组，该数组包含了所有在 array1 中也同时出现在所有其它参数数组中的值。注意键名保留不变。$array1 = array( \"a\" =&gt; \"green\" , \"red\" , \"blue\" ); $array2 = array( \"b\" =&gt; \"green\" , \"yellow\" , \"red\" ); $result = array_intersect ( $array1 , $array2 ); print_r ( $result ); //Array([a] =&gt; green [0] =&gt; red ) array_diff()array array_diff ( array $array1 , array $array2 [, array $... ] )对比返回在 array1 中但是不在 array2 及任何其它参数数组中的值。$array1 = array( \"a\" =&gt; \"green\" , \"red\" , \"blue\" , \"red\" ); $array2 = array( \"b\" =&gt; \"green\" , \"yellow\" , \"red\" ); $result = array_diff ( $array1 , $array2 ); print_r ( $result );//Array( [1] =&gt; blue ) 7.5.6 数组与数据结构array_push()array_push() 将 array 当成一个栈，并将传入的变量压入 array 的末尾。array_pop()array_pop() 弹出并返回 array 数组的最后一个单元，并将数组 array 的长度减一。如果 array 为空（或者不是数组）将返回 NULLarray_shift()array_shift() 将 array 的第一个单元移出并作为结果返回，将 array 的长度减一并将所有其它单元向前移动一位。所有的数字键名将改为从零开始计数，文字键名将不变。array_unshift()将传入的单元插入到 array 数组的开头。注意单元是作为整体被插入的，因此传入单元将保持同样的顺序。所有的数值键名将修改为从零开始重新计数，所有的文字键名保持不变。 7.5.7 其他有用的数组处理函数array_rand()从数组中取出一个或多个随机的单元，并返回随机条目的一个或多个键。如果你只取出一个， array_rand() 返回一个随机单元的键名，否则就返回一个包含随机键名的数组。这样你就可以随机从数组中取出键名和值。shuffle()本函数打乱（随机排列单元的顺序）一个数组。array_sum()array_sum() 将数组中的所有值的和以整数或浮点数的结果返回。range()建立一个包含指定范围单元的数组。 start 序列的第一个值。 limit 序列结束于 limit 的值。 step 如果给出了 step 的值，它将被作为单元之间的步进值。step应该为正值。如果未指定，step 则默认为 1。 foreach ( range ( 0 , 100 , 10 ) as $number ) &#123; echo $number ;&#125;// array(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100) 第八章 PHP面向对象的程序设计8.2.1 类的声明[修饰词]class 类名&#123; 对象的成员属性：//对类的静态描述，可以是php中标量类型和复合类型 对象的成员方法：//对类的动态描述 &#125; 类名和变量名、函数名命名规则相似在类中声明成员属性时一定要使用关键字如public private static var成员方法的声明和函数完全一样，只不过可以加一些关键字控制成员方法的权限,如public private static 8.3 通过类实例化对象$变量名 = new 类名称([参数列表]) //对象实例化格式在php中只要使用一次new关键字就会实例化出一个对象，并在堆内存中开辟一块自己的空间，每个对象之间都是相互独立的。 8.3.2 对象在内存中的分配内存结构大体上分为4断： 栈空间段 空间小但被CPU访问的速度快。存放程序中临时创建的变量具有后进先出的特点，用于存储占用空间长度不变并且占用空间小的数据类型内存段。例如 int bool 堆空间段 存放程序运行中被动态分配的内存段，用于存储数据长度可变或占用内存较大的数据，例如string array object 初始化数据段 存放程序静态分配的变量，例如已初始化的全局变量 代码段 用来存放可执行文件的操作指令 只准读取不准写入 function 8.3.3 对象中成员的访问$引用名 =new 类名称([参数列表])echo $引用名 -&gt; 成员属性; //获取属性值$引用名 -&gt; 成员属性 = 值; //对属性赋值操作$引用名 -&gt; 成员方法； //访问成员方法 8.3.4 特殊对象引用$this对象一旦被创建，在对象的每个成员方法中都会存在一个特殊的对象引用$this,专门用来完成对象内部成员之间的访问 8.3.5 构造方法与析构方法构造方法 对象创建完成后第一个被对象自动调用的方法，常用来执行一些初始化任务构造方法名称必须是(php5) __construct()同一个类只能声明一个构造方法析构方法 对象被销毁前自动调用的方法，在垃圾回收程序回收对象之前调用，例如执行关闭文件，释放结果等操作 __destruct()不能带有任何参数 8.4 封装性封装性就是把对象的成员属性和成员方法组合成一个独立的相同单位，并尽可能隐藏内部细节在声明成员属性或成员方法时，使用private关键字修饰将成员属性和方法封装成私有，封装后的成员在外部不能被访问，但在对象内部成员的方法中可以访问到被封装的成员属性和方法。在对象内部声明一些操作私有属性的公有方法，这样在对象外部就可以通过公有的方法作为访问接口，间接的访问对象内部私有成员 8.4.3 _set() _get() _isset() unset()方法 __set() 在程序运行过程中为私有的成员属性设置值，自动调用。使得看上去像没被封装一样 __get() 在程序运行时通过他可以在对象的外部获取私有成员的属性的值 __isset() 当在类外部使用isset()来测定对象里面的私有成员属性是否存在时，会自动调用_isset()来完成操作 __unset() 删除私有成员属性，用法与isset类似 8.5 继承性8.5.2 访问类型控制访问控制修饰符号的区别与联系 同类访问 子类访问 外部访问 private true protected true true public true true true 8.5.3 子类重载父类的方法在PHP中提供了在子类重载的方法中调用父类被覆盖方法的功能parent::方法名在子类中重写父类的方法时，一定要高于或等于父类被覆盖的方法的访问权限 8.6 常见的关键字和魔术方法final关键字作用： 使用final标识的类不能被继承 使用final标识的成员方法，在子类中不能被覆盖 static关键字static可以将类中成员标识为静态,这个static成员属于类的，总是唯一的，与对象实例和其他的类无关如果在类的外部访问类中的静态成员，通常使用类名来访问如果在类的内部成员方法中访问其他的静态成员，通常使用self的形式 self::$count++;const关键字将类中的成员属性使用const关键字标识为常量，const声明的常量名称前不要使用$符号，而且常量名称通常都是大写的，其访问方式与静态成员一样 8.6.3 克隆对象PHP5中使用clone关键字克隆对象，原本和副本两个对象完全独立互不干扰 8.6.4 __tostring()__tostring()是快速获取对象的字符串表示的最便捷方式，该方法中一定要有一个字符串作为返回值 8.6.5 __call()如果在类中添加一个魔术方法__call(),则调用对象中不存在的方法时就会自动调用该方法，function _call($functionName,$args)&#123; //code &#125; 8.6.6 自动加载类PHP提供了类的自动加载功能autoload(),当需要加载一个类时，PHP会自动执行autoload()function __autoload($className)&#123; include($className.\".php\");&#125;$obj = new User(); //User类不存在则自动调用__autoload()函数，将类名user作为参数传入 8.6.7 对象串行化串行化就是把整个对象转化为二进制字符串，有两种情况我们必须把对象串行化： 对象需要在网络中传输时，将对象串行化成二进制串后再网络中传输 对象需要长久保存时，将对象串行化后写入文件或是数据库中 serialize()函数用来串行化一个对象unserialize()函数用来反串行化一个对象在php5中还有两个魔术方法__sleep()和__wakeup()在调用serialize()函数将对象串行化时会自动调用对象中的__sleep()方法在调用unserialize()函数将对象反串行化时会自动调用对象中的__wakeup()方法 8.7 抽象类与接口8.7.1 抽象类抽象方法就是没有方法体的方法,在声明抽象方法时，还要使用abstract来修饰abstract function fun1() //没有花括号和方法体抽象类也要使用abstract关键字来修饰，在抽象类中可以有不是抽象的成员方法和属性，但访问权限不能使用private关键字修饰为私有抽象类的作用：使用抽象类就包含了继承关系，它是为它的子类定义公共接口，将它的操作交给子类去实现。就是将抽象类作为子类的重载的模板使用。子类必须把父类中的抽象方法全部实现，否则子类还是抽象类不能实例化 8.7.2 接口技术接口的声明使用interface关键字标识，不能再接口中声明变量，只能使用const关键字声明的常量接口和抽象类一样不能实例化对象，也需要通过子类来实现通过类继承接口时需要使用implements关键字来实现通过抽象类去实现接口的部分方法时也需要使用implements关键字 PHP是单继承的，一个类只能有一个父类，但是可以有多个接口class className extends fatherClassName implements 接口1,接口2……&#123; //实现所有接口中的抽象方法&#125; 8.8 多态性的应用在PHP中多态性指的是方法的重载，重载要求子类的方法和父类的方法名称相同，可通过成名抽象类和接口来实现 第九章 字符串的处理与正则表达式9.2 常用的字符串输出函数printf()int printf ( string $format [, mixed $args [, mixed $... ]] )依据 format 格式参数产生输出格式化字符串 。第一个参数中使用的转换格式是以%开始到转换字符结束printf('There is a difference between %s and %s', 'good', 'evil'); //There is a difference between good and evil sprintf()sprintf()用法和printf()相同，但它并不输出字符串$num = 12345;$txt = sprintf(\"%0.2f\",$num);echo $txt; 9.3 常见的字符串格式化函数 9.4 字符串比较函数strcmp(str1,str2) //区分字母大小写的比较strcasecmp(str1,str2) //忽略字母大小写的比较strnatcmp(str1,str2) //按自然排序法比较，区分大小写strcasenatcmp(str1,str2) //按自然排序法比较，不区分大小写 9.5 正则表达式在字符串处理中的应用9.5.2正则表达式的语法规则正则表达式中的元字符 9.6 正则表达式函数#####9.6.1 字符串的匹配与查找preg_match()int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) pattern 要搜索的模式，字符串类型。 subject 输入字符串。 matches 如果提供了参数matches，它将被填充为搜索结果。 $matches[0] 将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。 preg_match() 返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为 preg_match() 在第一次匹配后 将会停止搜索。preg_match_all() 不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误 preg_match() 返回 FALSE 。preg_match_all()int preg_match_all ( string $pattern , string $subject [, array &amp;$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0 ]]] )搜索subject中所有匹配pattern给定正则表达式的匹配结果并且将它们以flag指定顺序输出到matches中. PREG_PATTERN_ORDER 结果排序为 $matches[0] 保存完整模式的所有匹配, $matches[1] 保存第一个子组的所有匹配，以此类推。 PREG_SET_ORDER 结果排序为 $matches[0] 包含第一次匹配得到的所有匹配(包含子组)， $matches[1] 是包含第二次匹配到的所有匹配(包含子组)的数组，以此类推。 preg_grep()array preg_grep ( string $pattern , array $input [, int $flags = 0 ] )返回给定数组input中与模式pattern 匹配的元素组成的数组. 如果只是查找一个字符串中是否包含某个子字符串，建议使用strstr()或strpos()string strstr ( string $haystack , mixed $needle [, bool $before_needle = false ] )返回 haystack 字符串从 needle 第一次出现的位置开始到 haystack 结尾的字符串。如果想要不区分大小写，请使用 stristr() 。mixed strpos ( string $haystack , mixed $needle [, int $offset = 0 ] )返回 needle 在 haystack 中首次出现的数字位置。如果只是简单的从一个字符串中取出一段子字符串，建议使用substr() preg_replace()mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )搜索subject中匹配pattern的部分， 以replacement进行替换。limit 每个模式在每个subject上进行替换的最大次数。默认是 -1(无限)。 str_replace()mixed str_replace ( mixed $search , mixed $replace , mixed $subject [, int &amp;$count ] )该函数返回一个字符串或者数组。该字符串或数组是将 subject 中全部的 search 都被 replace 替换之后的结果。preg_split()array preg_split( string $pattern, string $subject [, int $limit = -1 [, int $flags = 0 ]] )通过一个正则表达式分隔给定字符串.返回一个使用 pattern 边界分隔 subject 后得到的子串组成的数组。explode()array explode ( string $delimiter , string $string [, int $limit ] )此函数返回由字符串组成的数组，每个元素都是 string 的一个子串，它们被字符串 delimiter 作为边界点分割出来。implode()string implode ( string $glue , array $pieces )用 glue 将一维数组的值连接为一个字符串。 第十章 PHP常用功能模块10.1 错误和异常处理不显示Notice消息的方法： 在配置文件中修改error_reporting = E_ALL &amp; ~E_NOTICE 在当前脚本中设置error_reporting(E_ALL &amp; ~E_NOTICE); 10.2 日期和时间10.2.1 UNIX时间戳time()返回自从 Unix 纪元（格林威治时间 1970 年 1 月 1 日 00:00:00）到当前时间的秒数。mktime()将日期和时间转化为UNIX时间戳int mktime ([ int $hour = date(&quot;H&quot;) [, int $minute = date(&quot;i&quot;) [, int $second = date(&quot;s&quot;) [, int $month = date(&quot;n&quot;) [, int $day = date(&quot;j&quot;) [, int $year = date(&quot;Y&quot;) [, int $is_dst = -1 ]]]]]]] )根据给出的参数返回 Unix 时间戳。时间戳是一个长整数，包含了从 Unix 纪元（January 1 1970 00:00:00 GMT）到给定时间的秒数。参数可以从右向左省略，任何省略的参数会被设置成本地日期和时间的当前值。echo date ( \"M-d-Y\" , mktime ( 0 , 0 , 0 , 12 , 32 , 1997 ));//Jan-01-1998 10.2.2 在PHP中获取日期和时间getdate()array getdate ([ int $timestamp = time() ] )返回一个根据 timestamp 得出的包含有日期信息的关联数组 array 。如果没有给出时间戳则认为是当前本地时间。print_r(getdate());/*Array( [seconds] =&gt; 20 [minutes] =&gt; 51 [hours] =&gt; 23 [mday] =&gt; 11 [wday] =&gt; 4 [mon] =&gt; 8 [year] =&gt; 2016 [yday] =&gt; 223 [weekday] =&gt; Thursday [month] =&gt; August [0] =&gt; 1470959480)*/ 10.2.3 日期和时间格式化输出date()string date ( string $format [, int $timestamp ] )返回将整数 timestamp 按照给定的格式字串而产生的字符串。如果没有给出时间戳则使用本地当前时间。换句话说，timestamp 是可选的，默认值为 time() 。print_r(date ( \"Y-m-d H:i:s\" ));//2016-08-12 07:58:15 10.2.4 修改默认时区 修改php.ini中的date.timezone = PRC 在当前php文件中设置date_default_timezone_set(‘PRC’) 10.2.5 使用微妙计算PHP时间microtime()mixed microtime ([ bool $get_as_float ] )如果调用时不带可选参数，本函数以 “msec sec” 的格式返回一个字符串，其中 sec 是自 Unix 纪元（0:00:00 January 1, 1970 GMT）起到现在的秒数，msec 是微秒部分。字符串的两部分都是以秒为单位返回的。如果给出了 get_as_float 参数并且其值等价于 TRUE ， microtime() 将返回一个浮点数。print_r(microtime()); //0.17703600 1470960354 10.3 动态图像处理10.3.2 画布管理创建画布imagecreate(int $x_size,int $y_size)imagecreatetruecolor(int $x_size,int $y_size)获取图像的大小imagesx(),imagesy();画布的引用句柄不用时，一定要将其销毁imagedestory() 10.3.3 设置颜色int imagecolorallocate ( resource $image , int $red , int $green , int $blue )$black = imagecolorallocate ( $im , 0 , 0 , 0 ); 10.3.4 生成图像 imagepng() - 以 PNG 格式将图像输出到浏览器或文件 imagewbmp() - 以 WBMP 格式将图像输出到浏览器或文件 imagejpeg() - 输出图象到浏览器或文件。 imagegif() - 以 gif 格式将图像输出到浏览器或文件 imagetypes() - 返回当前 PHP 版本所支持的图像类型 10.3.5 绘制图像图像区域填充bool imagefill ( resource $image , int $x , int $y , int $color )绘制点和线bool imagesetpixel ( resource $image , int $x , int $y , int $color )bool imageline ( resource $image , int $x1 , int $y1 , int $x2 , int $y2 , int $color )绘制矩形bool imagerectangle ( resource $image , int $x1 , int $y1 , int $x2 , int $y2 , int $col )bool imagefilledrectangle ( resource $image , int $x1 , int $y1 , int $x2 , int $y2 , int $color )画一矩形并填充 第十一章 文件系统处理11.1.1 文件类型string filetype ( string $filename )返回文件的类型。 可能的值有 fifo，char，dir，block，link，file 和 unknown。echo filetype ( '/etc/passwd' ); // fileecho filetype ( '/etc/' ); // dir 11.2 目录的基本操作basename()返回路径中的文件名部分dirname()返回去掉文件名后的目录pathinfo()返回一个关联数组，包含指定路径中的目录名基本名和扩展名，分别通过数组键dirname,basename,extension来引用 11.3 文件的基本操作fopen()打开文件或者 URLresource fopen ( string $filename , string $mode [,bool $use_include_path =false [, resource $context ]] ) mode 参数指定了所要求到该流的访问类型。fclose() 关闭一个已打开的文件指针bool fclose ( resource $handle )fwrite()写入文件（可安全用于二进制文件）int fwrite ( resource $handle , string $string [, int $length ] )int fwrite ( resource $handle , string $string [, int $length ] ) 第十二章 MySQl数据库设计12.1数据库的连接与关闭cmd mysql -h 服务器主机地址 -u 用户名 -pEnter passward:输入好后即可连接 12.1.4 创建、选择、查看数据库CREATE DATABASE [IF NOT EXISTS] bookstore; //创建bookstore数据库DROP DATABASE [IF EXISTS] bookstore; //删除bookstore数据库SHOW DATABASES; //显示所有已建立的数据库名称列表USE bookstore; //打开bookstore数据库作为当前数据库使用 21.2.3 数据字段属性UNSIGNED 只能用于设置数值类型，不允许出现负数ZEROFILL 只能用于设置数值类型，在数值之前自动用0补齐不足的位数AUTO_INCREMENT 设置字段的自动增量属性，每增加一条记录，该字段的值就加1NULL NOT NULLDEFAULT 指定默认值 12.2.4创建、修改及删除表创建数据表：CREATETABLE [IF NOT EXISTS] 表名称( 字段名1 列类型 [属性] [索引], 字段名2 列类型 [属性] [索引], 字段名3 列类型 [属性] [索引], 字段名n 列类型 [属性] [索引])[表类型] [表字符集];CREATE TABLE if not exists user( userId INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, userName VARCHAR(50) NOT NULL, userPass VARCHAR(50) NOT NULL, telNo VARCHAR(20) NOT NULL UNIQUE, sex ENUM('男','女') NOT NULL DEFAULT '男', brithday DATE NOT NULL DEFAULT '000-00-00', PRIMARY KEY(userId), INDEX username(userName,userPass))ENGINE=MyISAM DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; ALTER TABLE //修改表添加新字段ALTER TABLE 表名 ADD 字段名 &lt;建表语句&gt;[FIRST|AFTER 列名]若没指定可选的first|after，则在列尾添加一列，否则在指定列添加新列ALTER TABLE user ADD email VARCHAR(30) NOT NULL;ALTER TABLE user ADD name VARCHAR(30) NOT NULL FIRST;ALTER TABLE user ADD height DOUBLE NOT NULL DEFAULT '0.00' AFTER userPass; 修改原有字段ALTER TABLE 表名 CHANGE(MODIFY) 列表 &lt;建表语句&gt;ALTER TABLE users MODIFY telNo INT UNSIGNED DEFAULT '0'ALTER TABLE users CHANGE telNo phone INT UNSIGNED DEFAULT '0' CHANGE除了更改类型外还能更改列名desc 表名 //查看表结构DROP TABLE [IF EXISTS] 表名 //删除不再使用的数据表 12.2.7 创建索引在MYSQL中主要有四类索引： PRIMARY KEY 主键索引 UNIQUE 唯一索引 INDEX 常规索引 FULLTEXT 全文索引 12.4 SQL语言设计12.4.2 使用DML命令操作数据表中的数据使用INSERT语句向数据表中添加数据INSERT INTO 表名(字段名1，字段名2……)VALUES(值1，值2……)(……);INSERT INTO categories(pid,categoryName,categoryDesn)VALUES(0,&#39;english&#39;,&#39;about english&#39;);使用UPDATE语句更新数据表中存在的数据UPDATE 表名 SET 字段名=值[,字段名=值] WHERE 条件；UPDATE books SET price=24.00 WHERE bookId=2;使用DELETE语句删除数据表中不需要的数据记录DELETE FROM 表名 [WHERE 条件]；DELETE FROM books WHERE bookId=2; 12.4.3 使用DQL语句查询数据表中的数据SELECT 字段名 FROM 表名； 12.5 使用PHP脚本向mysql服务器发送SQLresource mysql_connect ([ string $server [, string $username [, string $password [, bool $new_link [, int $client_flags ]]]]] ) 选择已创建的数据库mysql_select_db()$lnk = mysql_connect ( 'localhost' , 'mysql_user' , 'mysql_password' ) or die ( 'Not connected : ' . mysql_error ());mysql_select_db ( 'foo' , $lnk ) or die ( 'Can\\'t use foo :'.mysql_error ()); 执行SQL语句mysql_query()$result = mysql_query ( &#39;SELECT * WHERE 1=1&#39; );mysql_query() 在执行成功时返回 TRUE ，出错时返回 FALSE 。 第十三章 PHP的mysqli扩展13.2 使用mysqli类连接MySQL服务器$mysqli=new mysqli(&quot;localhost&quot;,&quot;mysql_user&quot;,&quot;mysql_pwd&quot;,&quot;mylib&quot;);处理连接错误mysqli_connect_errno()关闭与mysql服务器连接close();执行SQL语句query();$mysqli-&gt;query(&quot;insert into 表名(列名1，列名2)values(值1，值2)&quot;)成功时返回true,错误时返回false;一次执行多条SQL语句用multi_query() 13.3 使用mysql_result类 13.4 使用mysql_stmt类 第十五章 会话控制15.2 会话跟踪的方式 使用超链接或者header()重定向，通过URL附加参数的形式 使用cookie将用户信息保存于客户端电脑之中 使用Session将用户信息保存于服务器之中 15.3 cookie的应用bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] ) setcookie()必须在其他信息被输出到浏览器之前调用setcookie(&quot;userName&quot;,&quot;jesse&quot;,time()+60*60*24*7);任何从客户端发送过来的cookie信息，都会被保存在$_cookie全局数组中print_r($_cookie)删除cookie： 仅导入第一个参数来删除指定名称的cookie资料setcookie(&quot;account&quot;) 利用setcookie()把cookie设定为已过期状态setcookie(&quot;account&quot;,time()-1) 15.4 session的应用bool session_start ( void )session_start()会创建新会话或者重用现有会话。使用该函数开启session之前不能有任何内容的输出，调用该函数会生成一个唯一的Session ID保存在客户端cookie中注册和读取session变量都需要通过访问$_SESSION超全局数组来完成session_destory()结束当前会话，并清空所有会话资源//第一步：开启Session并初使化session_start(); //第二步：删除所有Session的变量，也可用unset($_SESSION[xxx])逐个删除$_SESSION = array(); //第三步：如果使用基于Cookie的Session，使用setCooike()删除包含Session Id的Cookieif (isset($_COOKIE[session_name()])) &#123; setcookie(session_name(), '', time()-42000, '/');&#125;//第四步：最后彻底销毁Sessionsession_destroy(); session会因为下面两种状况自动消失 关闭浏览器 有效期限到期 通过cookie形式传递session ID如果客户端没有禁用cookie则在PHP脚本中通过session_start()函数进行初始化后，服务器会自动发送HTTP表头将session ID保存到客户端cookie中通过url形式传递session ID如果客户端不支持cookie，可以手动在每个超链接中添加session IDsession_start();echo '&lt;a href=\"demo.php?'.session_name().'='.session_id()'\".&gt;演示连接&lt;/a&gt;'; 第十六章 PHP的模板技术smarty16.4.1安装smarty在自己的项目中包含smarty类库，这样在移动项目时会带着smarty，不需要改变web服务器配置直接将libs文件夹复制到项目的主文件夹下在执行的PHP脚本中通过require()将libs目录中的Smarty.class.php类文件加载进来就可以了 16.5 Smarty在应用程序逻辑层的使用步骤 加载Smarty模板引擎 require(“Smarty.class.php”); 建立Smarty对象 $smarty=new Smarty(); 修改Smarty默认行为 开启缓存机制，修改模板默认存放目录； 将程序中动态获取的变量用assign()方法置入模板 用display()方法将模板输出 前三步是Smarty的核心，可放置在main.inc.php中 assign()方法在PHP脚本中调用该方法可以为Smarty模板文件中的变量赋值 指定“名称/数值”的赋值方式$smarty-&gt;assign(&quot;name&quot;,&quot;jesse&quot;); 指定包含“名称/数组”的联合数组的使用方式$smarty-&gt;assign(array(&quot;city&quot;=&gt;&quot;lincoln&quot;,&quot;state&quot;=&gt;&quot;nabraska&quot;)); display()方法smarty脚本中必须用到的方法，而且一个脚本中只能使用一次，他负责获取和显示smarty引擎引用的模板Void display(string template[,string cache_id[,string compile_id]])template 必选 需要指定一个合法的模板资源类型和路径cache_id 可选 指定一个缓存标识符的名称compile_id 可选 在维护一个页面的多个缓存时使用获取和显示$template_dir属性所指定目录下的的模板文件$smarty-&gt;display(“index.tpl”);在win平台下绝对路径必须用file:前缀，用来使用不在$template_dir模板目录下的文件$smarty-&gt;display(“C:/www/pub/templates/header/tpl”); 16.6 Smarty模板中的程序逻辑smarty引擎不仅在php逻辑层使用，在表现层也会偶尔使用（很简单） 16.6.1 模板中的注释包围在定界符{*和*}之间的内容都是注释内容，是模板的内在注释 16.6.2 模板中变量的声明smarty有几种不同类型的变量，变量的类型取决于他的前缀是什么符号。以下几个变量可以再smarty模板中直接输出&#123;$Name&#125; &#123;*常规类型变量*&#125;&#123;$Contacts[row].Phone&#125; &#123;*数组类型变量*&#125;&lt;body bgcolor=\"&#123;#bgcolor#&#125;\"&gt; &#123;*从配置文件中读取并输出的变量*&#125; 16.6.3 在模板中输出从PHP中分配的变量模板中只能输出从PHP中分配的变量，不能在模板中为这些变量重新赋值在Smarty模板中变量的预设是全域的。只要分配一次就可以，分配两次以上以最后以此为主通常在模板中通过遍历输出数组中的每个元素，通过foreach或section语句在模板中单独输出数组中的某个元素索引数组 和在PHP脚本的引用方式一样 {$contact2[1][2]}关联数组 使用”.”访问{$contact.email}索引关联混合数组 {$contact2[1].name}在PHP脚本中创建的对象类型变量也可以分配给模板，并访问对象中的每个成员，都是通过“-&gt;”运算符完成{$person-&gt;name}{$person-&gt;work()} 16.6.4 模板中变量的数学运算在模板中的变量不能重新赋值，但是可以参与数学运算&#123;$foo+1&#125; &#123;$foo*$bar&#125;&#123;$foo-&gt;bar-$bar[1]*$baz-&gt;foo-&gt;bar()-3*7&#125; &#123;*复合类型变量也可参与运算*&#125;&#123;if($foo+$bar.test%$baz*134232+10+$b+10)&#125; &#123;*可以将数学运算在程序逻辑中运用*&#125; 在Smarty模板中可以识别嵌入在””中的变量，只要此变量名称只包含字母数字下划线或[]。若有其他符号，此变量必须用两个反引号包住 16.6.5 在模板中使用{$smarty}保留变量{$smarty}保留变量是可以在模板中直接访问的数组类型变量，通常用于访问一些特殊模板变量1.在模板中访问页面请求变量&#123;$smarty.get.page&#125; &#123;* 类似在PHP脚本中访问$_GET[\"page\"] *&#125;&#123;$smarty.post.page&#125; &#123;* 类似在PHP脚本中访问$_POST['page'] *&#125;&#123;$smarty.cookies.username&#125; &#123;* 类似在PHP脚本中访问$_COOKIE['username']*&#125;&#123;$smarty.server.SERVER_NAME&#125;&#123;* 类似在PHP脚本中访问$_SERVER['SERVER_NAME']*&#125;&#123;$smarty.env.PATH&#125; &#123;* 类似在PHP脚本中访问$_EVN[\"PATH\"] *&#125;&#123;$smarty.request.username&#125; &#123;* 类似在PHP脚本中访问$_REQUEST[\"username\"]*&#125; 2.在模板中访问PHP中的常量&#123;$smarty.const._MY_CONST_VAL&#125; &#123;*在模板中输出php脚本中用户自定义的常量*&#125;&#123;$smarty.const._FILE_&#125; &#123;*在模板中通过保留变量数组直接输出系统常量*&#125; 16.6.6 变量调节器变量在模板中输出以前如果需要调解，可以在该变量后面跟一个“|”,在后面使用调解命令。可以使用多个修改器按设定好的顺序依次组合使用{$articleTitle|lower|spacify|truncate}truncate()在截取中文时需要修改 16.6.7 模板的控制结构 条件选择结构 if-elseif-else {if}{/if}必须成对出现，中间的修饰词eq等等必须和变量或常量用空格隔开 重复的区块 foreach {foreach}{/foreach}必须成对出现 |属性 | 类型 | 是否必须 | 缺省值 | 描述 | |—–|——–|———-|——–|——| |from | array | Yes | n/a | 待循环数组的名称 | |item | string | Yes | n/a | 当前处理元素的变量名称 | |key | string | No | n/a | 当前处理元素的键名 | |name | string | No | n/a | 该循环的名称，用于访问该循环 | foreachelse标记一定要与foreach一起使用，与ifelse相似 关联数组和索引数组都可以用foreach遍历 重复的区块 section 改进版的foreach |属性 | 类型 |是否必须 | 缺省值 | 描述 | |—–|—————-|———|———-|——| |name | string | Yes | n/a |该循环的名称 | |loop |[$variable_name]| Yes | n/a |决定循环次数的数组变量名称 | |start| integer | No | 0 |循环执行的初始位置 | 如果start值为负数，开始位置从数组的尾部算起. 例如：如果数组中有7个元素，指定start为-2，那么指向当前数组的索引为5. 非法值(超过了循环数组的下限)将被自动调整为最接近的合法值. step integer No 1 该值决定循环的步长. 例如指定step=2将只遍历下标为0、2、4等的元素. 如果step为负值，那么遍历数组的时候从后向前遍历. max integer No 1 设定循环最大执行次数. show boolean No true 决定是否显示该循环. section遍历的数组必须是下表从0开始的顺序索引数组 section标记也可以使用可选的sectionelse子标记，当loop属性指定的数组为空时，输出sectionelse区域中的内容，必须与section一起使用 重复区块中可供调用的变量 在section和foreach循环中都有可供调用的变量，都必须通过$smarty进行访问 {$smarty.foreach.foreachname.varname} $smarty.foreach是Smarty保留变量 foreachname在foreach标记指定的name属性值 varname在循环中被调用的特定变量名称 foreach循环区域中可调用的变量 |变量名| 描述| |—– |—–| |iteration | 用于显示当前循环的执行次数，总是从 1 开始，每执行一次增加 1| |first | 当前 foreach 循环第一次执行时 first 被设置成 true.| |last | 当前 foreach 循环执行到最后一遍时 last 被设置成 true.| |show | 是 foreach 的一个参数. 取值为布尔值 true 或 false. 如果指定为 false该循环不显示，如果循环指定了 foreachelse 子句，该子句显示与否也取决于 show 的取值.| |total | 用于显示循环执行的次数，可以在循环中或循环执行后调用.| section循环中调用可供变量的方式与foreach相似 16.6.8 在模板中包含子模板如果在多个模板中有相同的输出内容，这些相同的部分可在独立的模板中定义，在需要的模板中将其用include标记导入，但必须指定模板资源的位置。一般头部文件和尾部文件都可作为独立的模板导入&#123;include file=\"header.tpl\"&#125;&#123;include file=\"footer.tpl\"&#125; 在include标记中还有两个比较实用的特性 assign属性将导入的子模板内容不在当前模板中输出，而是赋给由assign指定的变量{include file=&quot;header.tpl&quot; assign=&quot;header&quot;}{*模板header.tpl中的全部内容以字符串的形式赋值给变量header，再通过{$header}将子模板输出*} 可以在导入子模板的同时向其传递各种属性{include file=&quot;header.tpl&quot; title=&quot;menu&quot; table_bgcolor=&quot;#ccc&quot;}以此方式传递的各种属性只能在被导入的文件中使用，不能用于模板的其他位置。如果模板中有同名变量，则会被传递的属性替代 16.7.2 加载配置文件{config_load file=&quot;foo.conf&quot; section=&quot;customer&quot;}{*加载foo.conf中第一节customer中的变量*} 16.7.3 引用配置文件中的变量配置文件中的变量需要通过两个##或者是$smarty.config来调用&#123;#pageTitle#&#125;&#123;$smarty.config.pageTitle&#125; 16.8.3 緩存is_cached() 判断指定模板的缓存是否存在clear_all_cache()清除所有缓存clear_cache()清除单个缓存 16.8.5 关闭局部缓存1、使用{insert}使模板的一部分不被缓存2、使用$smarty-&gt;register_function($params.&amp;$smarty)阻止插件从缓存中输出3、使用$smarty-&gt;register_block($params,&amp;$samrty)是整篇页面的某一块不被缓存","tags":[{"name":"PHP","slug":"php","permalink":"https://jesse121.github.io/tags/php/"}]},{"title":"PHP四种基础排序算法的运行时间比较","date":"2016-08-10T23:12:14.000Z","path":"articles/php/PHP四种基础排序算法的运行时间比较.html","text":"冒泡排序法function bubbleSort($array)&#123; $temp = 0; for($i = 0;$i &lt; count($array) -1;$i++)&#123; for($j = 0;$j &lt; count($array) - 1 -$i;$j++)&#123; if($array[$j] &gt; $array[$j+1])&#123; //从小到大排列 $temp = $array[$j]; $array[$j] = $array[$j+1]; $array[$j+1] = $temp; &#125; &#125; &#125;&#125; 选择排序法function selectSort($array)&#123; $temp = 0; for($i = 0;$i &lt; count($array) - 1;$i++)&#123; $minVal = $array[$i]; //假设$i就是最小值 $minValIndex = $i; for($j = $i+1;$j &lt; count($array);$j++)&#123; if($minVal &gt; $array[$j])&#123; //从小到大排列 $minVal = $array[$j]; //找最小值 $minValIndex = $j; &#125; &#125; $temp = $array[$i]; $array[$i] = $array[$minValIndex]; $array[$minValIndex] = $temp; &#125;&#125; 插入排序法function insertSort($array)&#123; //从小到大排列 //先默认$array[0]，已经有序，是有序表 for($i = 1;$i &lt; count($array);$i++)&#123; $insertVal = $array[$i]; //$insertVal是准备插入的数 $insertIndex = $i - 1; //有序表中准备比较的数的下标 while($insertIndex &gt;= 0 &amp;&amp; $insertVal &lt; $array[$insertIndex])&#123; $array[$insertIndex + 1] = $array[$insertIndex]; //将数组往后挪 $insertIndex--; //将下标往前挪，准备与前一个进行比较 &#125; if($insertIndex + 1 !== $i)&#123; $array[$insertIndex + 1] = $insertVal; &#125; &#125;&#125; 快速排序法function quickSort($array)&#123; if(!isset($array[1])) return $array; $mid = $array[0]; //获取一个用于分割的关键字，一般是首个元素 $leftArray = array(); $rightArray = array(); foreach($array as $v)&#123; if($v &gt; $mid) $rightArray[] = $v; //把比$mid大的数放到一个数组里 if($v &lt; $mid) $leftArray[] = $v; //把比$mid小的数放到另一个数组里 &#125; $leftArray = quickSort($leftArray); //把比较小的数组再一次进行分割 $leftArray[] = $mid; //把分割的元素加到小的数组后面，不能忘了它哦 $rightArray = quickSort($rightArray); //把比较大的数组再一次进行分割 return array_merge($leftArray,$rightArray); //组合两个结果&#125; 进行比较$a = array_rand(range(1,3000), 1600); //生成1600个元素的随机数组shuffle($a); //打乱数组的顺序$t1 = microtime(true);bubbleSort($a); //冒泡排序$t2 = microtime(true);echo \"冒泡排序用时：\".(($t2-$t1)*1000).'ms'.\"\\n\";$t3 = microtime(true);selectSort($a); //选择排序$t4 = microtime(true);echo \"选择排序用时：\".(($t4-$t3)*1000).'ms'.\"\\n\";$t5 = microtime(true);insertSort($a); //插入排序$t6 = microtime(true);echo \"插入排序用时：\".(($t6-$t5)*1000).'ms'.\"\\n\";$t7 = microtime(true);quickSort($a); //快速排序$t8 = microtime(true);echo \"快速排序用时：\".(($t8-$t7)*1000).'ms';","tags":[{"name":"PHP","slug":"php","permalink":"https://jesse121.github.io/tags/php/"}]},{"title":"Html5 Web Worker网页工人线程","date":"2016-07-30T16:00:00.000Z","path":"articles/html-css/html5-web-worker.html","text":"什么是Web Worker？web worker 是运行在后台的 JavaScript，不会影响页面的性能。 Web Worker有什么用？JavaScript语言采用的是单线程模型，也就是说，所有任务排成一个队列，一次只能做一件事。随着电脑计算能力的增强，尤其是多核CPU的出现，这一点带来很大的不便，无法充分发挥JavaScript的潜力。Web Worker的目的，就是为JavaScript创造多线程环境，允许主线程将一些任务分配给子线程。在主线程运行的同时，子线程在后台运行，两者互不干扰。等到子线程完成计算任务，再把结果返回给主线程。因此，每一个子线程就好像一个“工人”（worker），默默地完成自己的工作。这样做的好处是，一些高计算量或高延迟的工作，被worker线程负担了，所以主进程（通常是UI进程）就会很流畅，不会被阻塞或拖慢，可以提高应用的总体性能，并且提升用户体验。 Web Worker的特点Web Worker有以下几个特点： 同域限制。子线程加载的脚本文件，必须与主线程的脚本文件在同一个域。 DOM限制。子线程所在的全局对象，与主进程不一样，它无法读取网页的DOM对象，即document、window、parent这些对象，子线程都无法得到。（但是，navigator对象和location对象可以获得。） 脚本限制。子线程无法读取网页的全局变量和函数，也不能执行alert和confirm方法，不过可以执行setInterval和setTimeout，以及使用XMLHttpRequest对象发出AJAX请求。 文件限制。子线程无法读取本地文件，即子线程无法打开本机的文件系统，它所加载的脚本，必须来自网络。Web Worker的兼容性在创建 web worker 之前，请检测用户的浏览器是否支持它： if(window.Worker)&#123; Yes! Web worker support! // Some code..... &#125;else&#123; Sorry! No Web Worker support..&#125; IE10+及所有主流浏览器均支持 web worker。 Web Worker常用API1.postMessage(data)子线程与主线程之间互相通信使用方法，传递的data为任意值。2.message当有消息发送时，触发该事件。消息发送是双向的，消息内容可通过data来获取。3.terminate()主线程中终止worker，此后无法再利用其进行消息传递。注意：一旦terminate后，无法重新启用，只能另外创建。4.error出错处理。错误消息可以通过e.message来获取。 Web Worker实例//file:main.js//创建worker子线程var worker = new Worker(\"worker.js\");//主线程向子线程发送内容worker.postMessage(\"hello world!\");//主线程通过message事件监听子线程发来的内容worker.onmessage = function(e) &#123; console.log(e.data);&#125;;//主线程可以监听子线程是否发生错误。//如果发生错误，会触发主线程的error事件。worker.onerror(function(e) &#123; console.log(e);&#125;);//关闭子线程worker.terminate();//file:worker.js//子线程接收消息self.onmessage = function(e)&#123; self.postMessage('You said: ' + e.data);&#125;; worker.js执行的上下文，与主页面执行时的上下文并不相同，最顶层的对象并不是window，而是WorkerGlobalScope，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。WorkerGlobalScope作用域下的常用属性、方法如下： self 我们可以使用 WorkerGlobalScope 的 self 属性来或者这个对象本身的引用 location location 属性返回当线程被创建出来的时候与之关联的 WorkerLocation 对象，它表示用于初始化这个工作线程的脚步资源的绝对 URL，即使页面被多次重定向后，这个 URL 资源位置也不会改变。 close 关闭当前线程，与terminate作用类似 self.close() importScripts 我们可以通过importScripts()方法通过url在worker中加载库函数 XMLHttpRequest setTimeout/setInterval以及addEventListener 详见JavaScript 标准参考教程","tags":[{"name":"HTML","slug":"html","permalink":"https://jesse121.github.io/tags/html/"}]},{"title":"《高性能JavaScript》--读书笔记","date":"2016-07-28T16:00:00.000Z","path":"articles/notes/high-performance-javascript.html","text":"第一章 加载和运行延迟脚本 defer该属性表明脚本在执行期间不会影响到页面的构造，脚本会先下载但被延迟到整个页面都解析完毕后再运行.只适用于外部脚本&lt;script src=\"js/test.js\" defer&gt;&lt;/script&gt;&lt;div&gt;123&lt;/div&gt;&lt;script&gt; alert('script'); window.onload = function()&#123; alert('loaded'); &#125;&lt;/script&gt;&lt;!-- 输出顺序 123 script defer loaded --&gt; 异步脚本 async只适用于外部脚本，告诉浏览器立即下载脚本，同时不影响页面的解析，先下载完先执行，没有一定的顺序，但一定会在页面load事件前执行 总结有几种方法可以减少JavaScript 对性能的影响： 将所有&lt;script&gt;标签放置在页面的底部，紧靠&lt;/body&gt;的上方。此法可以保证页面在脚本运行之前完成解析。 将脚本成组打包。页面的&lt;script&gt;标签越少，页面的加载速度就越快，响应也更加迅速。不论外部脚本文件还是内联代码都是如此。 为&lt;script&gt;标签添加defer属性 动态创建&lt;script&gt;元素，用它下载并执行代码 用XHR 对象下载代码，并注入到页面中 The YUI 3 approach The LazyLoad library The LABjs library 第二章 数据访问在JavaScript 中有四种基本的数据访问位置： 直接量 直接量仅仅代表自己，而不存储于特定位置。JavaScript 的直接量包括：字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊意义的空值，以及未定义。 变量 开发人员使用var 关键字创建用于存储数据值 数组项 具有数字索引，存储一个JavaScript 数组对象。 对象成员 具有字符串索引，存储一个JavaScript 对象。 总的来说，直接量和局部变量的访问速度要快于数组项和对象成员的访问速度。 标识符解析过程此过程搜索运行期上下文的作用域链，查找同名的标识符。搜索工作从运行函数的激活目标之作用域链的前端开始。如果找到了，那么就使用这个具有指定标识符的变量；如果没找到，搜索工作将进入作用域链的下一个对象。此过程持续运行，直到标识符被找到，或者没有更多对象可用于搜索，这种情况下标识符将被认为是未定义的。 标识符识别性能在运行期上下文的作用域链中，一个标识符所处的位置越深，它的读写速度就越慢。所以，函数中局部变量的访问速度总是最快的，而全局变量通常是最慢的（优化的JavaScript引擎在某些情况下可以改变这种状况）。请记住，全局变量总是处于运行期上下文作用域链的最后一个位置，所以总是最远才能触及的。你可以通过这种方法减轻重复的全局变量访问对性能的影响：首先将全局变量的引用存储在一个局部变量中，然后使用这个局部变量代替全局变量。 改变作用域链with 表达式当代码流执行到一个with 表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高了。try-catch 表达式的catch 子句当try 块发生错误时，程序流程自动转入catch 块，并将异常对象推入作用域链前端的一个可变对象中。在catch块中，函数的所有局部变量现在被放在第二个作用域链对象中。 闭包，作用域，内存通常，一个函数的激活对象与运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中的闭包与非闭包函数相比，需要更多内存开销。function assignEvents()&#123; var id = \"xdi9592\"; document.getElementById(\"save-btn\").onclick = function(event)&#123; saveDocument(id); &#125;;&#125; 注意闭包中使用的两个标识符，id 和saveDocument，存在于作用域链第一个对象之后的位置上。这是闭包最主要的性能关注点：你经常访问一些范围之外的标识符，每次访问都导致一些性能损失。关于域外变量的处理建议，减轻对运行速度的影响：将常用的域外变量存入局部变量中，然后直接访问局部变量。 对象成员每深入原形链一层都会增加性能损失。记住，搜索实例成员的过程比访问直接量或者局部变量负担更重，所以增加遍历原形链的开销正好放大了这种效果。由于对象成员可能包含其它成员，例如不太常见的写法window.location.href这种模式。每遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。成员嵌套越深，访问速度越慢。一般来说，如果在同一个函数中你要多次读取同一个对象属性，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要 总结在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数组项，对象成员。它们有不同的性能考虑。 直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。 局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。 避免使用with 表达式，因为它改变了运行期上下文的作用域链。而且应当小心对待try-catch 表达式的catch子句，因为它具有同样效果。 嵌套对象成员会造成重大性能影响，尽量少用。 一个属性或方法在原形链中的位置越深，访问它的速度就越慢。 一般来说，你可以通过这种方法提高JavaScript 代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。 第三章 DOM 编程DOM 访问和修改访问或修改元素最坏的情况是使用循环执行此操作，特别是在HTML 集合中使用循环。function innerHTMLLoop() &#123; for (var count = 0; count &lt; 15000; count++) &#123; document.getElementById('here').innerHTML += 'a'; &#125;&#125; 这段代码的问题是，在每次循环单元中都对DOM 元素访问两次：一次读取innerHTML 属性内容，另一次写入它。一个更有效率的版本将使用局部变量存储更新后的内容，在循环结束时一次性写入：function innerHTMLLoop2() &#123; var content = ''; for (var count = 0; count &lt; 15000; count++) &#123; content += 'a'; &#125; document.getElementById('here').innerHTML += content;&#125; innerHTML 与DOM 方法比较它们的性能如何？答案是：性能差别不大，但是，在所有浏览器中，innerHTML 速度更快一些，除了最新的基于WebKit 的浏览器（Chrome 和Safari）。 HTML 集合HTML 集合是用于存放DOM 节点引用的类数组对象。下列函数的返回值就是一个集合： document.getElementsByName() document.getElementsByTagName() document.getElementsByClassName() document.images 页面中所有的&lt;img&gt;元素 document.links 所有的&lt;a&gt;元素 document.forms 所有表单 document.forms[0].elements 页面中第一个表单的所有字段 这些方法和属性返回HTMLCollection 对象，是一种类似数组的列表。它们不是数组（因为它们没有诸如push()或slice()之类的方法），但是提供了一个length属性，和数组一样你可以使用索引访问列表中的元素。HTML 集合实际上在查询文档，当你更新信息时，每次都要重复执行这种查询操作。例如读取集合中元素的数目（也就是集合的length），这正是低效率的来源。优化的办法很简单，只要将集合的length 属性缓存到一个变量中，然后在循环判断条件中使用这个变量function loopCacheLengthCollection() &#123; var coll = document.getElementsByTagName('div'), len = coll.length; for (var count = 0; count &lt; len; count++) &#123; //more code &#125;&#125; 一般来说，对于任何类型的DOM 访问，如果同一个DOM 属性或方法被访问一次以上，最好使用一个局部变量缓存此DOM成员。当遍历一个集合时，第一个优化是将集合引用存储于局部变量，并在循环之外缓存length 属性。然后，如果在循环体中多次访问同一个集合元素，那么使用局部变量缓存它。 DOM 漫谈querySelectorAll()IE8+此函数不返回HTML集合，所以返回的节点不呈现文档的“存在性结构”。这就避免了本章前面提到的HTML 集合所固有的性能问题（以及潜在的逻辑问题）。 查询并刷新渲染树改变 offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop, scrollLeft, scrollWidth, scrollHeight clientTop, clientLeft, clientWidth, clientHeight getComputedStyle() (currentStyle in IE) 当你查询布局信息如偏移量、滚动条位置，或风格属性时，浏览器刷新队列并执行所有修改操作，以返回最新的数值。最好是尽量减少对布局信息的查询次数，查询时将它赋给局部变量，并用局部变量参与计算。 最小化重绘和重排版重排版和重绘代价昂贵，所以，提高程序响应速度一个好策略是减少此类操作发生的机会。为减少发生次数，你应该将多个DOM 和风格改变合并到一个批次中一次性执行。当你需要对DOM 元素进行多次修改时，你可以通过以下步骤减少重绘和重排版的次数： 从文档流中摘除该元素 对其应用多重改变 将元素带回文档中 常用方法： 隐藏元素，进行修改，然后再显示它。 var ul = document.getElementById('mylist');ul.style.display = 'none';appendDataToElement(ul, data);ul.style.display = 'block'; 使用一个文档片断在已存DOM 之外创建一个子树，然后将它拷贝到文档中。 var fragment = document.createDocumentFragment();appendDataToElement(fragment, data);document.getElementById('mylist').appendChild(fragment); 将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素。 推荐尽可能使用文档片断（第二种解决方案）因为它涉及最少数量的DOM 操作和重排版 将元素提出动画流使用以下步骤可以避免对大部分页面进行重排版： 使用绝对坐标定位页面动画的元素，使它位于页面布局流之外。 启动元素动画。当它扩大时，它临时覆盖部分页面。这是一个重绘过程，但只影响页面的一小部分，避免重排版并重绘一大块页面。 当动画结束时，重新定位。 事件托管当页面中存在大量元素，而且每个元素有一个或多个事件句柄与之挂接（例如onclick）时，可能会影响性能一个简单而优雅的处理DOM 事件的技术是事件托管。它基于这样一个事实：事件逐层冒泡总能被父元素捕获。采用事件托管技术之后，你只需要在一个包装元素上挂接一个句柄，用于处理子元素发生的所有事件。 总结为减少DOM 编程中的性能损失，请牢记以下几点： 最小化DOM 访问，在JavaScript 端做尽可能多的事情。 在反复访问的地方使用局部变量存放DOM 引用. 小心地处理HTML 集合，因为他们表现出“存在性”，总是对底层文档重新查询。将集合的length 属性缓存到一个变量中，在迭代中使用这个变量。如果经常操作这个集合，可以将集合拷贝到数组中。 如果可能的话，使用速度更快的API，诸如querySelectorAll()和firstElementChild。 注意重绘和重排版；批量修改风格，离线操作DOM 树，缓存并减少对布局信息的访问。 动画中使用绝对坐标，使用拖放代理。 使用事件托管技术最小化事件句柄数量。 第四章 算法和流程控制循环性能在JavaScript 提供的四种循环类型中，只有一种循环比其他循环明显要慢：for-in 循环。由于每次迭代操作要搜索实例或原形的属性，for-in 循环每次迭代都要付出更多开销。因此推荐的做法如下：除非你需要对数目不详的对象属性进行操作，否则避免使用for-in 循环其他循环类型性能相当，难以确定哪种循环更快。选择循环类型应基于需求而不是性能。 基于函数的迭代items.forEach(function(value, index, array)&#123; process(value);&#125;); 尽管基于函数的迭代显得更加便利，它还是比基于循环的迭代要慢一些。 条件表达式if-else 与switch 比较大多数情况下switch 表达式比if-else 更快，但只有当条件体数量很大时才明显更快。两者间的主要性能区别在于：当条件体增加时，if-else 性能负担增加的程度比switch更多。因此，我们的自然倾向认为条件体较少时应使用if-else 而条件体较多时应使用switch 表达式，如果从性能方面考虑也是正确的。 优化if-else优化if-else的目标总是最小化找到正确分支之前所判断条件体的数量。最简单的优化方法是将最常见的条件体放在首位 总结 for，while，do-while 循环的性能特性相似，谁也不比谁更快或更慢。 除非你要迭代遍历一个属性未知的对象，否则不要使用for-in 循环。 一般来说，switch 总是比if-else 更快，但并不总是最好的解决方法。 当判断条件较多时，查表法比if-else 或者switch 更快。 如果你遇到一个栈溢出错误，将方法修改为一个迭代算法或者使用制表法可以避免重复工作。 第五章 字符串和正则表达式字符串连接加和加等于操作str += \"one\" + \"two\";str = str + \"one\" + \"two\"; 这就避免了使用临时字符串，因为赋值表达式开头以str为基础，一次追加一个字符串，从左至右依次连接。 Array.prototype.joinstr = [“a”,”b”,”c”].join(“”); String.prototype.concatstr = str.concat(s1, s2, s3); 正则表达式优化第六章 响应接口浏览器UI 线程浏览器限制这是一个有必要的限制，确保恶意代码编写者不能通过无尽的密集操作锁定用户浏览器或计算机。此类限制有两个：调用栈尺寸限制和长时间脚本限制。 用定时器让出时间片function processArray(items, process, callback)&#123; var todo = items.concat(); //create a clone of the original setTimeout(function()&#123; process(todo.shift()); //if there's more items to process, create another timer if(todo.length &gt; 0)&#123; setTimeout(arguments.callee, 25); &#125; else &#123; callback(items); &#125; &#125;, 25);&#125; setTimeout第二个参数指出什么时候应当将任务添加到UI 队列之中，并不是说那时代码将被执行。 分解任务如果函数运行时间太长，它可以拆分成一系列更小的步骤，把独立方法放在定时器中调用。你可以将每个函数都放入一个数组，然后使用前一节中提到的数组处理模式：function saveDocument(id)&#123; var tasks = [openDocument, writeText, closeDocument, updateUI]; setTimeout(function()&#123; //execute the next task var task = tasks.shift(); task(id); //determine if there's more if (tasks.length &gt; 0)&#123; setTimeout(arguments.callee, 25); &#125; &#125;, 25);&#125; 限时运行代码可通过原生的Date 对象跟踪代码的运行时间。这是大多数JavaScript 分析工具所采用的工作方式：var start = +new Date(),stop;someLongProcess();stop = +new Date();if(stop-start &lt; 50)&#123; alert(\"Just about right.\");&#125; else &#123; alert(\"Taking too long.\");&#125; Web Workers工人线程的运行环境由下列部分组成： 一个浏览器对象，只包含四个属性：appName, appVersion, userAgent, 和platform 一个location 对象（和window 里的一样，只是所有属性都是只读的） 一个self 对象指向全局工人线程对象 一个importScripts()方法，使工人线程可以加载外部JavaScript 文件 所有ECMAScript 对象，诸如Object，Array，Data，等等。 XMLHttpRequest 构造器 setTimeout()和setInterval()方法 close()方法可立即停止工人线程 要创建网页工人线程，你必须传入这个JavaScript 文件的URL：var worker = new Worker(\"code.js\"); 工人线程和网页代码通过事件接口进行交互。网页代码可通过postMessage()方法向工人线程传递数据，它接收单个参数，即传递给工人线程的数据。此外，在工人线程中还有onmessage事件句柄用于接收信息。当工人线程通过importScripts()方法加载外部JavaScript 文件，它接收一个或多个URL参数，指出要加载的JavaScript文件网址。工人线程以阻塞方式调用importScripts()，直到所有文件加载完成并执行之后，脚本才继续运行。由于工人线程在UI线程之外运行，这种阻塞不会影响UI响应。 实际用途网页工人线程适合于那些纯数据的，或者与浏览器UI 没关系的长运行脚本。它看起来用处不大，而网页应用程序中通常有一些数据处理功能将受益于工人线程，而不是定时器。任何超过100毫秒的处理，都应当考虑工人线程方案是不是比基于定时器的方案更合适。当然，还要基于浏览器是否支持工人线程。 总结有效地管理UI 线程就是要确保JavaScript 不能运行太长时间，以免影响用户体验。最后，请牢记如下几点： JavaScript运行时间不应该超过100毫秒。过长的运行时间导致UI更新出现可察觉的延迟，从而对整体用户体验产生负面影响。 定时器可用于安排代码推迟执行，它使得你可以将长运行脚本分解成一系列较小的任务。 网页工人线程是新式浏览器才支持的特性，它允许你在UI线程之外运行JavaScript代码而避免锁定UI。 第七章 Ajax在现代高性能JavaScript 中使用的三种技术是XHR，动态脚本标签插入和多部分的XHR。 XMLHttpRequestvar url = '/data.php';var params = ['id=934875','limit=20'];var req = new XMLHttpRequest();req.onreadystatechange = function() &#123; if (req.readyState === 4) &#123; var responseHeaders = req.getAllResponseHeaders(); // Get the response headers. var data = req.responseText; // Get the data. // Process the data here... &#125;&#125;req.open('GET', url + '?' + params.join('&amp;'), true);req.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); // Set a request header.req.send(null); // Send the request. 动态脚本标签插入var scriptElement = document.createElement('script');scriptElement.src = 'http://any-domain.com/javascript/lib.js';document.getElementsByTagName('head')[0].appendChild(scriptElement); 多部分XHR这里介绍最新的技术，多部分XHR（MXHR）允许你只用一个HTTP 请求就可以从服务器端获取多个资源。它通过将资源（可以是CSS 文件，HTML 片段，JavaScript代码，或base64编码的图片）打包成一个由特定分隔符界定的大字符串，从服务器端发送到客户端。使用此技术有一些缺点，其中最大的缺点是以此方法获得的资源不能被浏览器缓存 第八章 编程实践避免二次评估大多数情况下，没必要使用eval_r()或Function()，如果可能的话，尽量避免使用它们。至于另外两个函数，setTimeout()和setInterval()，建议第一个参数传入一个函数而不是一个字符串。 使用对象/数组直接量位操作运算符位与&amp; 两个操作数的位都是1，结果才是1位或| 有一个操作数的位是1，结果就是1位异^或 两个位中只有一个1，结果才是1位非~ 遇0返回1，反之亦然for (var i=0, len=rows.length; i &lt; len; i++)&#123; if (i &amp; 1) &#123; //判断奇偶数 className = \"odd\"; &#125; else &#123; className = \"even\"; &#125;&#125; 总结 通过避免使用eval_r()和Function()构造器避免二次评估。此外，给setTimeout()和setInterval()传递函数参数而不是字符串参数。 创建新对象和数组时使用对象直接量和数组直接量。它们比非直接量形式创建和初始化更快。 避免重复进行相同工作。当需要检测浏览器时，使用延迟加载或条件预加载。 当执行数学远算时，考虑使用位操作，它直接在数字底层进行操作。 原生方法总是比JavaScript 写的东西要快。尽量使用原生方法。 第九章 构建和部署高性能JavaScript 应用第十章 工具","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"Javascript获取网页各种高宽及位置总结","date":"2016-07-26T15:00:00.000Z","path":"articles/javascript/javascript获取网页各种高宽及位置总结.html","text":"screen对象获取屏幕的高宽（分辨率）screen.width //屏幕的宽screen.height //屏幕的高screen.availWidth //屏幕可用宽度 屏幕的像素高度减去系统部件高度之后的值screen.availHeight //屏幕可用高度 屏幕的像素宽度减去系统部件宽度之后的值 window对象获得窗口位置及大小window.screenTop //窗口顶部距屏幕顶部的距离window.screenLeft //窗口左侧距屏幕左侧的距离window.innerWidth //窗口中可视区域(viewpoint)的宽度console.log(window.innerWidth); //chrome 1366 ff 1366 ie 1366window.innerHeight //窗口中可视区域(viewpoint)的高度 该值与浏览器是否显示菜单栏等因素有关console.log(window.innerHeight); //chrome 643 ff 657 ie 673window.outerWidth //浏览器窗口本身的宽度(可视区域宽度+浏览器边框宽度)console.log(window.outerWidth); //chrome 1366 ff 1382 ie 1382 //说明chrome在最大化时浏览器窗口没有边框宽度,非最大化时有8px边框//ff和ie上下左右有8px的边框宽度window.outerHeight //浏览器窗口本身的高度console.log(window.outerHeight); //chrome 728 ff 744 ie 744 element对象在介绍element对象各种高宽之前有必要解释一下盒模型默认盒模型 box-sizing:content-box;boxWidth = 2*border + 2*padding + widthboxHeight = 2*border + 2*padding + height 示例代码&lt;style type=\"text/css\"&gt; body &#123; margin: 8px; padding: 10px; border: 20px solid yellow; &#125; .no-scrollbar &#123; width: 100px; height: 100px; padding: 10px; border: 20px solid yellow; margin: 30px; background-color: red; &#125; .wrap&#123; width: 100px; height: 100px; padding: 10px; border: 20px solid yellow; margin: 30px; background-color: red; &#125;&lt;/style&gt;&lt;div class=\"no-scrollbar\"&gt;0123456789&lt;/div&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"has-scrollbar\"&gt;123456789&lt;/div&gt;&lt;/div&gt; element.clientWidth:表示元素的可见宽度，以像素计。包括内边距，但不包括垂直滚动条、边框和外边距。element.clientHeight:返回元素的可见高度，以像素计，包含内边距，但不包括水平滚动条、边框和外边距。element.clientLeft:返回元素的左边框的宽度，以像素计，包滚动条宽度(如果左侧有滚动条)，不包括外边距和内边距element.clientTop:返回元素的上边框的宽度，以像素计，不包括外边距和内边距//clientWidth = 2*padding + width//clientHeight = 2*padding + heightconsole.log(\"无滚动条时\");console.log(document.getElementsByClassName('no-scrollbar')[0].clientWidth); //120console.log(document.getElementsByClassName('no-scrollbar')[0].clientHeight); //120console.log(document.getElementsByClassName('no-scrollbar')[0].clientLeft);//20console.log(document.getElementsByClassName('no-scrollbar')[0].clientTop);//20console.log(\"有滚动条时\");console.log(document.getElementsByClassName('has-scrollbar')[0].clientWidth); //120console.log(document.getElementsByClassName('has-scrollbar')[0].clientHeight);//120console.log(document.getElementsByClassName('has-scrollbar')[0].clientLeft);//20console.log(document.getElementsByClassName('has-scrollbar')[0].clientTop);//20 element.offsetWidth:返回元素的布局宽度包括边框(border)、水平线上的内边距(padding)、竖直方向滚动条(scrollbar)（如果存在的话）、以及CSS设置的宽度(width)的值。element.offsetHeight:返回元素的布局高度包括边框(border)、垂直线上的内边距(padding)、水平方向滚动条(scrollbar)（如果存在的话）、以及CSS设置的宽度(height)的值。element.offsetLeft:返回当前元素左上角相对于父元素的左边界偏移的像素值。element.offsetTop:返回当前元素左上角相对于父元素的上边界偏移的像素值。//offsetWidth = 2*border + 2*padding + width //offsetHeight = 2*border + 2*padding + height console.log(\"无滚动条时\");console.log(document.getElementsByClassName('no-scrollbar')[0].offsetWidth); //160console.log(document.getElementsByClassName('no-scrollbar')[0].offsetHeight); //160console.log(document.getElementsByClassName('no-scrollbar')[0].offsetLeft);//38console.log(document.getElementsByClassName('no-scrollbar')[0].offsetTop);//30console.log(\"有滚动条时\");console.log(document.getElementsByClassName('has-scrollbar')[0].offsetWidth);//160console.log(document.getElementsByClassName('has-scrollbar')[0].offsetHeight);//160console.log(document.getElementsByClassName('has-scrollbar')[0].offsetLeft);//68console.log(document.getElementsByClassName('has-scrollbar')[0].offsetTop);//250 这是第二个子元素 scrollWidth: 返回元素的内容区域宽度或元素的本身的宽度中更大的那个值。若元素的宽度大于其内容的区域（例如，元素存在滚动条时）,scrollWidth的值要大于clientWidth。返回元素的整个宽度（包括带滚动条的隐蔽的地方）scrollHeight: 没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。scrollTop: 向下滑动滚动块时元素隐藏部分的高度。不设置时默认为0，其值随着滚动块滚动而变化scrollLeft: 向右滑动滚动块时元素隐藏部分的宽度。不设置时默认为0，其值随着滚动块滚动而变化//scrollWidth = 2*border + 2*padding + width + scrollLeft//scrollHeight = 2*border + 2*padding + height + scrollTopconsole.log(\"无滚动条时\");console.log(document.body.scrollWidth);//1360console.log(document.body.scrollHeight);//638console.log(document.body.scrollLeft);//0console.log(document.body.scrollTop);//0console.log(\"有滚动条且滚动条都拉到右下角时\");console.log(document.body.scrollWidth);//1468console.log(document.body.scrollHeight);//876console.log(document.body.scrollLeft);//125console.log(document.body.scrollTop);//255 element.getBoundingClientRect()getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下： var clientRect = element.getBoundingClientRect(); clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据，具体可查看链接Element.getBoundingClientRect() 在页面高宽调试时可参考：console.log(\"屏幕的宽：\" + window.screen.width); console.log(\"屏幕的高：\" + window.screen.height); console.log(\"屏幕可用工作区宽度：\" + window.screen.availWidth); console.log(\"屏幕可用工作区高度：\" + window.screen.availHeight); console.log(\"窗口左侧距屏幕左侧的距离：\" + window.screenLeft); console.log(\"窗口顶部距屏幕顶部的距离：\" + window.screenTop); console.log(\"body的可见宽度(2*padding + width)：\" + document.body.clientWidth); console.log(\"body的可见高度(2*padding + height)：\" + document.body.clientHeight); console.log(\"body的左边框宽度：\" + document.body.clientLeft); console.log(\"body的上边框宽度：\" + document.body.clientTop);console.log(\"body的布局宽度(2*border + 2*padding + width)：\" + document.body.offsetWidth); console.log(\"body的布局高度(2*border + 2*padding + width)：\" + document.body.offsetHeight); console.log(\"body左上角相对于父元素的左边界偏移的像素值：\" + document.body.offsetLeft);console.log(\"body左上角相对于父元素的上边界偏移的像素值：\" + document.body.offsetTop);console.log(\"body的整体宽度(2*margin + 2*border + 2*padding + width + scrollLeft)：\" + document.body.scrollWidth); console.log(\"body的枕套i高度(2*margin + 2*border + 2*padding + width + scrollTop)：\" + document.body.scrollHeight); console.log(\"body被卷去的高：\" + document.body.scrollTop); console.log(\"body被卷去的左: \" + document.body.scrollLeft); event对象event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。event.screenX:相对电脑屏幕的坐标，以屏幕左上角为坐标原点到鼠标所在点的水平距离event.screenY:相对电脑屏幕的坐标，以屏幕左上角为坐标原点到鼠标所在点的垂直距离event.pageX:相对整个页面的坐标，以页面的左上角为坐标原点到鼠标所在点的水平距离（IE8不支持）event.pageY:相对整个页面的坐标，以页面的左上角为坐标原点到鼠标所在点的垂直距离（IE8不支持）event.clientX:相对可视区域的坐标，以浏览器可视区域左上角为坐标原点到鼠标所在点的水平距离event.clientY:相对可视区域的坐标，以浏览器可视区域左上角为坐标原点到鼠标所在点的垂直距离event.offsetX:相对于自身的坐标，以自身的padding左上角为坐标原点到鼠标所在点的水平距离event.offsetY:相对于自身的坐标，以自身的padding左上角为坐标原点到鼠标所在点的水平距离 获取鼠标相对于可视窗口的位置坐标&lt;label for=\"mouseXPosition\"&gt;鼠标的X坐标为：&lt;/label&gt;&lt;input type=\"text\" id=\"mouseXPosition\" name=\"mouseXPosition\"&gt;&lt;label for=\"mouseYPosition\"&gt;鼠标的Y坐标为：&lt;/label&gt;&lt;input type=\"text\" id=\"mouseYPosition\" name=\"mouseYPosition\"&gt;&lt;script type=\"text/javascript\"&gt;document.onmousemove = mouseMove;function mouseMove(event) &#123; event = event || window.event; var mousePos = mousePosition(event); document.getElementById('mouseXPosition').value = mousePos.x; document.getElementById('mouseYPosition').value = mousePos.y;&#125;function mousePosition(event) &#123; if (event.pageX || event.pageY) &#123; return &#123; x: event.pageX, y: event.pageY &#125;; &#125;else&#123; return &#123; x: event.clientX + document.body.scrollLeft - document.body.clientLeft, y: event.clientY + document.body.scrollTop - document.body.clientTop &#125;; &#125;&#125;&lt;/script&gt;","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"前端构建工具Gulp使用总结","date":"2016-06-26T10:05:20.000Z","path":"articles/tool/front-end-build-tool-gulp-usage-summary.html","text":"1.安装准备1.1 Node.js安装在安装Gulp之前首先的安装Node.js,安装教程详见Node.js 安装配置 1.2 npm安装在安装node的时候会自动安装npm模块管理器，详见npm模块管理器win+r输入cmd打开命令终端 node -v查看所安装的node的版本号 npm -v查看所安装的npm的版本号 用win系统终端命令进入项目根目录 d: 进入d盘 dir d盘下文件列表 cd www 进入www文件夹,直至根目录 cd .. 退回上一级文件夹 2. 安装Gulp2.1 全局安装在全局安装gulpnpm install gulp -g 2.2 新建package.json文件npm init 配置package.json文件 2.3 本地安装进入项目根目录再安装一遍npm install gulp --save-devnpm从3.0.0开始，架包的依赖不再安装在每个架包的node_modules文件夹内，而是安装在顶层的node_modules文件夹中。所以安装的时候会生成许多文件包，如果要启用之前的风格，则可以添加命令参数legacy-bundling，如下：npm install gulp --save-dev --legacy-bundling 3. 安装插件我们将要使用Gulp插件来完成以下任务： less的编译（gulp-less） sass的编译（gulp-ruby-sass） 压缩js代码（gulp-uglify） 压缩css（gulp-minify-css） 压缩html（gulp-minify-html） 压缩图片（gulp-imagemin） 图片缓存（gulp-cache） 文件重命名（gulp-rename） 浏览器实时刷新（gulp-connect） 更改提醒（gulp-notify） 清除文件（del） 安装以上插件 npm install gulp-less gulp-ruby-sass gulp-connect gulp-uglify gulp-minify-css gulp-minify-html gulp-imagemin gulp-cache gulp-rename gulp-notify del --save-dev --legacy-bundling 具体的安装包还有哪些其他配置可在npm search查询安装完成后可通过’npm ls –depth=0’命令查看是否安装成功如果不需要某个插件可通过’gulp uninstall &lt;插件名称&gt; –save-dev’进行删除 4. 新建gulpfile.js文件说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件 //导入工具包 require('node_modules里对应模块')var gulp = require('gulp'); //本地安装gulp所用到的地方var jsmin = require('gulp-uglify'); //JS文件压缩 var cssmin = require('gulp-clean-css'); //css文件压缩var htmlmin = require('gulp-minify-html'); //html文件压缩var cache = require('gulp-cache'); //图片缓存var imgmin = require('gulp-imagemin'); //图片压缩var notify = require('gulp-notify'); //更动通知var rename = require('gulp-rename'); //重命名var del = require('del');var sass = require('gulp-ruby-sass'); //编译SASSvar sourcemaps= require('gulp-sourcemaps'); //使得浏览器能够直接调试SCSSvar connect = require('gulp-connect'); //实时刷新浏览器// var less = require('gulp-less'); // 编译Less// var jshint = require('gulp-jshint'); //js代码检查// var contact = require('gulp-contact'); //合并js或css文件等//docs 开发环境//dist 发布环境//demo 项目名称,每做一个项目需要修改项目名称//gulp.task(name[, deps], fn) 定义任务 name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件 globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径//gulp.watch(glob[, opts], tasks) 监视文件，并且可以在文件发生改动时候做一些事情。//**********************************////以下是开发过程中的需要执行各种任务////**********************************////浏览器自动刷新页面gulp.task('connect', function() &#123; connect.server(&#123; //地址，推荐写本地IP方便手机端同步调试，不写的话，默认localhost host: '14.42.1.148', port: 3000, //端口号，可不写，默认8000 root: './src/'+demo+'/', //当前项目主目录 livereload: true //自动刷新 &#125;);&#125;);//html文件有变化时，自动更新gulp.task('html', function() &#123; gulp.src('src/'+ demo + '/*.html') .pipe(connect.reload()) .pipe(notify(&#123; message: 'HTML has change' &#125;));&#125;);//当项目中只用CSS，且css文件有变化时，自动更新gulp.task('css', function() &#123; gulp.src('src/'+ demo + '/css/*.css') .pipe(connect.reload()) .pipe(notify(&#123; message: 'CSS has change' &#125;));&#125;);//编译SASS gulp sassgulp.task('sass', function()&#123; sass('src/'+ demo + '/css/scss/*.scss',&#123; //为scss编译的css添加sourcemap，使得在浏览器中能显示scss文件的具体行数 sourcemap: true, //Sass to CSS 的输出样式：nested,compact,expanded,compressed。 style:'expanded', //取消scss缓存 noCache:true //scss缓存文件的位置 //cacheLocation: 'src/'+ demo + '/css/scss/', &#125;) .pipe(sourcemaps.write()) .on('error', sass.logError) .pipe(gulp.dest('src/'+ demo + '/css/')) .pipe(notify(&#123; message: 'SCSS has change' &#125;)) .pipe(connect.reload());&#125;)// 编译Less ,在命令行项目目录下使用 gulp less 启动此任务// gulp.task('less', function () &#123;// gulp.src('src/*/less/*.less') //该任务针对的文件// .pipe(less()) //该任务调用的模块// .pipe(gulp.dest('dist/css')) //将会在dist/css下生成对应的css文件// .pipe(notify(&#123; message: 'less task complete' &#125;));// &#125;); //js文件有变化时，自动更新gulp.task('js', function() &#123; gulp.src('src/'+ demo + '/js/*.js') .pipe(notify(&#123; message: 'JavaScript has change' &#125;)) .pipe(connect.reload());&#125;);// js代码检查// gulp.task('jshint', function() &#123;// gulp.src('src/js/*.js')// .pipe(jshint())// //默认在命令行里输出结果// // .pipe(jshint.reporter('default')); // //输出结果到自定义的html文件// .pipe(jshint.reporter('gulp-jshint-html-reporter', &#123;filename:'jshint-report.html'&#125;)); // &#125;);//**********************************////以下是开发调试过程中的各种监听任务////**********************************//// 监听文件变化,在命令行项目目录下使用 gulp watch启动此任务,监听的文件有变化就自动执行gulp.task('watch',function()&#123; //监听HTML gulp.watch('src/'+ demo + '/*.html',['html']); //监听css gulp.watch('src/'+ demo + '/css/*.css',['css']); //监听scss gulp.watch('src/'+ demo + '/css/scss/*.scss',['sass']); //监听js gulp.watch('src/'+ demo + '/js/*.js',['js']);&#125;);//项目开始编码时，执行gulp命令打开服务器并监听各文件变化，浏览器实时刷新gulp.task('default',['clean','watch','connect']);//******************************************////以下是开发结束后打包到生产环境中的各种任务////******************************************////在任务执行前，最好先清除之前生成的文件： gulp cleangulp.task('clean', function() &#123; return del(['dist']); //删除发布环境文件&#125;);//css文件压缩,在命令行项目目录下使用 gulp cssmin 启动此任务gulp.task('cssmin', function () &#123; gulp.src('src/'+ demo + '/css/*.css') .pipe(cssmin(&#123; //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] advanced: false, //保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] compatibility: 'ie8', //类型：Boolean 默认：false [是否保留换行] keepBreaks: false &#125;)) .pipe(rename(&#123; suffix: '.min' &#125;)) //对压缩后的文件重命名 .pipe(gulp.dest('dist/'+ demo + '/css/'))&#125;);// js文件压缩 ,在命令行项目目录下使用 gulp jsmin 启动此任务gulp.task('jsmin', function() &#123; gulp.src('src/'+ demo + '/js/*.js') // 1. 找到文件 .pipe(jsmin()) // 2. 压缩文件 .pipe(rename(&#123;extname:'.min.js'&#125;)) // 3.对压缩文件重命名 .pipe(gulp.dest('dist/'+ demo + '/js/')) // 4. 输出压缩后的文件&#125;); //图片压缩,在命令行项目目录下使用 gulp imgmin 启动此任务gulp.task('imgmin', function() &#123; gulp.src('src/'+ demo + '/img/**/*.&#123;png,jpg,gif,ico&#125;') .pipe(cache(imgmin(&#123; optimizationLevel: 5,//类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;))) .pipe(gulp.dest('dist/'+ demo + '/img/'))&#125;);//html文件压缩,在命令行项目目录下使用 gulp htmlmin 启动此任务gulp.task('htmlmin', function () &#123; gulp.src('src/'+ demo + '/*.html') // 要压缩的html文件 .pipe(htmlmin()) //压缩 .pipe(gulp.dest('dist/'+ demo + '/')) .pipe(notify(&#123; message: 'Package task complete' &#125;));&#125;);//字体文件复制// gulp.task('fonts',function()&#123;// gulp.src('src/*/fonts')// .pipe(gulp.dest('dist'))// .pipe(notify(&#123;message: 'fonts task complete'&#125;));// &#125;)//合并js或css文件等// gulp.task('scripts', function() &#123;// gulp.src('./js/*.js')// .pipe(concat('all.js'))// .pipe(gulp.dest('./dist'))// .pipe(rename('all.min.js'))// .pipe(uglify())// .pipe(gulp.dest('./dist'));// &#125;);// 开发完成执行打包任务,在命令行项目目录下使用 gulp package启动此任务gulp.task('package',['clean','cssmin', 'jsmin', 'imgmin', 'htmlmin']); 5. 运行Gulp 通过终端命令行进入项目根目录 在命令行输入gulp进入项目开发监控状态 (说明：命令提示符执行gulp 任务名称) gulp package进行项目打包 如有不明之处，还请参阅gulp详细入门教程","tags":[{"name":"Gulp","slug":"gulp","permalink":"https://jesse121.github.io/tags/gulp/"}]},{"title":"《AngularJs权威指南》--读书笔记","date":"2016-06-26T09:28:13.000Z","path":"articles/notes/the-complete-book-on-angularjs.html","text":"第二章、数据绑定2.2 简单的数据绑定&lt;!DOCTYPE html&gt;&lt;html ng-app&gt; &lt;head&gt; &lt;title&gt;Simple app&lt;/title&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.13/angular.js\"&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input ng-model=\"name\" type=\"text\" placeholder=\"Your name\"&gt; &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; ng-app 指令定义一个 AngularJS 应用程序。ng-app 声明所有被它包含的元素都属于AngularJS 应用ng-model 指令把元素值（比如输入域的值）绑定到应用程序。ng-controller 指令定义了应用程序控制器。DOM元素上的ng-controller声明所有被它包含的元素都属于某个控制器。AngularJS 表达式写在双大括号内：。 它们可以包含文字、运算符和变量。 可以写在 HTML 中 支持过滤器,不支持条件判断，循环及异常。 是通过 ng-model=”name” 进行同步。 2.3 数据绑定的最佳实现通常认为，在视图中通过对象的属性而非对象本身来进行引用绑定，是Angular中的最佳实践。function MyController($scope) &#123; $scope.clock = &#123; now: new Date() &#125;; var updateClock = function() &#123; $scope.clock.now = new Date() &#125;; setInterval(function() &#123; $scope.$apply(updateClock); &#125;, 1000); updateClock();&#125;; 第三章、模块模块包含了主要的应用代码。一个应用可以包含多个模块，每一个模块都包含了定义具体功能的代码。AngularJS允许我们使用angular.module()方法来声明模块，这个方法能够接受两个参数，第一个是模块的名称，第二个是依赖列表，也就是可以被注入到模块中的对象列表。angular.module(name,requires); name是模块的名称，字符串变量。 requires包含了一个字符串变量组成的列表，每个元素都是一个模块名称，本模块依赖于这些模块，依赖需要在本模块加载之前由注入器进行预加载。 //是用来定义模块的angular.module('myApp', []);// 用于获取应用angular.module('myApp') 第四章、作用域4.1 视图和 $scopeAngularJS启动并生成视图时，会将根ng-app元素同$rootScope进行绑定。$rootScope是所有$scope对象的最上层。$rootScope是AngularJS中最接近全局作用域的对象$scope对象就是一个普通的JavaScript对象，我们可以在其上随意修改或添加属性。 4.2 作用域能做什么作用域的功能： 提供观察者以监视数据模型的变化； 可以将数据模型的变化通知给整个应用，甚至是系统外的组件； 可以进行嵌套，隔离业务功能和数据； 给表达式提供运算时所需的执行环境。 ng-controller和ng-repeat指令会创建自己的子作用域并将它们附加到DOM元素上。 第五章、控制器控制器并不适合用来执行DOM操作、格式化或数据操作，以及存储数据之外的状态维护操作，允许在$scope上设置数据 5.1 控制器嵌套&lt;div ng-controller=\"ParentController\"&gt; &lt;div ng-controller=\"ChildController\"&gt; &lt;a ng-click=\"sayHello()\"&gt;Say hello&lt;/a&gt; &lt;/div&gt; &#123;&#123; person &#125;&#125;&lt;/div&gt; 点击按钮时，可以在ChildController中访问ParentController中$scope.person的值var app=angular.module(\"myApp\",[]);app.controller(\"myController\",['$scope','aService',...,function($scope,aService,...)&#123; //可以注入你写的factory，provider等等&#125;]); controller第一个参数是名称，后面是一个数组，数组的前面是声明注入的内容，可以是n个，最后是个function，function的参数个数也必须是n个，必须跟前面声明注入的内容一一对应,就这样实现了依赖注入 第六章、表达式 所有的表达式都在其所属的作用域内部执行，并有访问本地$scope的权限； 如果表达式发生了TypeError和ReferenceError并不会抛出异常； 不允许使用任何流程控制功能（条件控制，例如if/eles） 可以接受过滤器和过滤器链。 6.1 解析angularjs表达式$watch(watchFn, watchAction, deepWatch)watchFn该参数是一个带有Angular表达式或者函数的字符串，它会返回被监控的数据模型的当前值watchAction这是一个函数或者表达式，当watchFn 发生变化时会被调用。如果是函数的形式，它将会接收到watchFn的新旧两个值，以及作用域对象的引用。function(newValue, oldValue, scope)。deepWatch如果设置为true，这个可选的布尔型参数将会命令Angular去检查被监控对象的每个属性是否发生了变化。$parse(expression)将一个AngularJS表达式转换成一个函数function(context,locals)context[object]:针对你要解析的语句，这个对象中含有你要解析的语句中的表达式(通常是一个scope object)locals[object]: 关于context中变量的本地变量，对于覆盖context中的变量值很有用。angular.module(\"myApp\", []).controller('MyController',function($scope,$parse) &#123; $scope.$watch('expr', function(newVal, oldVal, scope) &#123; if (newVal !== oldVal) &#123; // 用该表达式设置parseFun var parseFun = $parse(newVal); // 获取经过解析后表达式的值 $scope.parsedValue = parseFun(scope); &#125; &#125;);&#125;); 6.2 插值字符串要在字符串模板中做插值操作，需要在你的对象中注入$interpolate服务。$interpolate服务是一个可以接受三个参数的函数，其中第一个参数是必需的。返回一个函数，用来在特定的上下文中运算表达式。 text（字符串）：一个包含字符插值标记的字符串。 mustHaveExpression（布尔型）：如果将这个参数设为true，当传入的字符串中不含有表达式时会返回null。 trustedContext（字符串）：AngularJS会对已经进行过字符插值操作的字符串通过$sec.getTrusted()方法进行严格的上下文转义。 &lt;div ng-controller=\"MyController\"&gt; &lt;input ng-model=\"to\" type=\"email\" placeholder=\"Recipient\" /&gt; &lt;textarea ng-model=\"emailBody\"&gt;&lt;/textarea&gt; &lt;pre&gt;&#123;&#123; previewText &#125;&#125;&lt;/pre&gt;&lt;/div&gt;angular.module('myApp', []).controller('MyController', function($scope, $interpolate) &#123; $scope.$watch('emailBody', function(body) &#123; if (body) &#123; var template = $interpolate(body); $scope.previewText = template(&#123;to: $scope.to&#125;); &#125; &#125;;&#125;); 第七章、过滤器在HTML中的模板绑定符号运算符内通过|符号来调用过滤器。&#123;&#123; name | uppercase &#125;&#125; 在JavaScript代码中可以通过$filter来调用过滤器app.controller('DemoController', ['$scope', '$filter', function($scope, $filter) &#123; $scope.name = $filter('lowercase')('Ari'); &#125;]); 内置过滤器 currency date filter这个过滤器的第一个参数可以是字符串、对象或是一个用来从数组中选择元素的函数。我们也可以给filter过滤器传入第二个参数，用来指定预期值同实际值进行比较的方式 字符串返回所有包含这个字符串的元素。如果我们想返回不包含该字符串的元素，在参数前加!符号。 &#123;&#123; ['Ari','Lerner','Likes','To','Eat','Pizza'] | filter:'e' &#125;&#125;&lt;!-- [\"Lerner\",\"Likes\",\"Eat\"] --&gt; 对象AngularJS会将待过滤对象的属性同这个对象中的同名属性进行比较，如果属性值是字符串就会判断是否包含该字符串。 &#123;&#123; [ &#123;'name': 'Ari','City': 'San Francisco','favorite food': 'Pizza'&#125;, &#123;'name': 'Nate','City': 'San Francisco','favorite food': 'indian food'&#125; ] | filter:&#123;'favorite food': 'Pizza'&#125;&#125;&#125;&lt;!-- [&#123;\"name\":\"Ari\",\"City\":\"SanFrancisco\",\"favoritefood\":\"Pizza\"&#125;] --&gt; 函数对每个元素都执行这个函数，返回非假值的元素会出现在新的数组中并返回。 &#123;&#123; ['Ari','likes','to','travel'] | filter:isCapitalized &#125;&#125;&lt;!-- [\"Ari\"] --&gt;$scope.isCapitalized = function(str) &#123; return str[0] == str[0].toUpperCase();&#125;; jsonjson过滤器可以将一个JSON或JavaScript对象转换成字符串 limitTolimitTo过滤器会根据传入的参数生成一个新的数组或字符串，新的数组或字符串的长度取决于传入的参数，通过传入参数的正负值来控制从前面还是从后面开始截取。 &#123;&#123; San Francisco is very cloudy | limitTo:3 &#125;&#125;&lt;!-- San --&gt; lowercase uppercase numbernumber过滤器将数字格式化成文本。它的第二个参数是可选的，用来控制小数点后截取的位数。 orderByorderBy过滤器可以用表达式对指定的数组进行排序。可以接受两个参数，第一个是必需的，第二个是可选的,用来控制排序的方向（是否逆向）。 &#123;&#123; [&#123; 'name': 'Ari','status': 'awake' &#125;,&#123; 'name': 'Q','status': 'sleeping' &#125;,&#123; 'name': 'Nate','status': 'awake' &#125;] | orderBy:'name':true &#125;&#125;&lt;!--[ &#123;\"name\":\"Q\",\"status\":\"sleeping\"&#125;, &#123;\"name\":\"Nate\",\"status\":\"awake\"&#125;, &#123;\"name\":\"Ari\",\"status\":\"awake\"&#125;]--&gt; 7.1 自定义过滤器&#123;&#123; 'ginger loves dog treats' | lowercase | capitalize &#125;&#125;&lt;!-- Ginger loves dog treats --&gt;//自定义capitalize过滤器angular.module('myApp', []).filter('capitalize', function() &#123; return function(input) &#123; // input是我们传入的字符串 if (input) &#123; return input[0].toUpperCase() + input.slice(1); &#125;&#125;); 7.2 表单验证如果想要屏蔽浏览器对表单的默认验证行为，可以在表单元素上添加novalidate标记。可以在input元素上使用的所有验证选项 最小长度 &lt;input type=&quot;text&quot; ng-minlength=&quot;5&quot; /&gt; 最大长度 &lt;input type=&quot;text&quot; ng-maxlength=&quot;20&quot; /&gt; 模式匹配 &lt;input type=&quot;text&quot; ng-pattern=&quot;[a-zA-Z]&quot; /&gt; 在表单中控制变量 未修改的表单 formName.inputFieldName.$pristine 如果未修改，值为true 修改过的表单 formName.inputFieldName.$dirty 只要用户修改过表单，该值都返回true 合法的表单 formName.inputFieldName.$valid 不合法的表单 formName.inputFieldName.$invalid 错误 formName.inputfieldName.$error 如果验证失败，这个属性的值为true 一些有用的CSS样式 .ng-pristine{} .ng-dirty{} .ng-valid{} .ng-invalid{} $parsers $formatters给输入字段添加name属性非常重要：这决定了我们将验证信息展示给用户时如何引用表单输入字段。 第八章、指令简介8.1 自定义HTML元素和属性通过AngularJS模块API中的.directive()方法，我们可以通过传入一个字符串和一个函数来注册一个新指令。其中字符串是这个指令的名字函数应该返回一个对象包含了用来定义和配置指令所需的方法和属性。&lt;my-directive&gt;&lt;/my-directive&gt;angular.module('myApp',[]).directive('myDirective', function() &#123; return &#123; restrict: 'E', template: '&lt;a href=\"http://google.com\"&gt; Click me to go to Google&lt;/a&gt;' &#125;;&#125;); 将replace设置为true就将自定义标签从生成的DOM中完全移除掉，并只留下由模版生成的链接restrict可以指定以元素（E）、属性（A）、类（C）或注释（M）的格式来调用指令,好的经验法则就是始终用属性来声明指 8.2 向指令中传递数据AngularJS允许通过创建新的子作用域或者隔离作用域来解决这个常见问题 第九章、内置指令9.1 基础ng属性指令9.1.1 布尔属性 ng-disabled 用ng-disabled可以把disabled属性绑定到&lt;input&gt;&lt;textarea&gt;&lt;select&gt;&lt;button&gt;表单输入字段上 ng-readonly 通过ng-readonly可以将某个返回真或假的表达式同是否出现readonly属性进行绑定： ng-checked 通过ng-checked将某个表达式同是否出现checked属性进行绑定。 ng-selected ng-selected可以对是否出现option标签的selected属性进行绑定 9.1.2 类布尔属性 ng-href 当使用当前作用域中的属性动态创建URL时，应该用ng-href代替href。 ng-src AngularJS会告诉浏览器在ng-src对应的表达式生效之前不要加载图像 9.2 在指令中使用子作用域 ng-appng-app为AngularJS应用创建$rootScope，任何具有ng-app属性的DOM元素将被标记为$rootScope的起始点。任何嵌套在ng-app内的指令都会继承它 ng-controllerng-controller则会以$rootScope或另外一个ng-controller的作用域为原型创建新的子作用域子$scope只是一个JavaScript对象，其中含有从父级$scope中通过原型继承得到的方法和属性，包括应用的$rootScope ng-include使用ng-include可以加载、编译并包含外部HTML片段到当前的应用中。模板的URL被限制在与应用文档相同的域和协议下. &lt;div ng-include=\"/myTemplateName.html\" ng-controller=\"MyController\" ng-init=\"name = 'World'\"&gt; Hello &#123;&#123; name &#125;&#125;&lt;/div&gt; ng-switch这个指令和ng-switch-when及on=”propertyName”一起使用，可以在propertyName发生变化时渲染不同指令到视图中 &lt;input type=\"text\" ng-model=\"person.name\"/&gt;&lt;div ng-switch on=\"person.name\"&gt; &lt;p ng-switch-default&gt;And the winner is&lt;/p&gt; &lt;h1 ng-switch-when=\"Ari\"&gt;&#123;&#123; person.name &#125;&#125;&lt;/h1&gt;&lt;/div&gt; ng-viewng-view指令用来设置将被路由管理和放置在HTML中的视图的位置 ng-if使用ng-if指令可以完全根据表达式的值在DOM中生成或移除一个元素ng-if同no-show和ng-hide指令最本质的区别是，它不是通过CSS显示或隐藏DOM节点，而是真正生成或移除节点。 ng-repeatng-repeat用来遍历一个集合或为集合中的每个元素生成一个模板实例 $index：遍历的进度（0…length-1）。 $first：当元素是遍历的第一个时值为true。 $middle：当元素处于第一个和最后元素之间时值为true。 $last：当元素是遍历的最后一个时值为true。 $even：当$index值是偶数时值为true。 $odd：当$index值是奇数时值为true。 ng-initng-init指令用来在指令被调用时设置内部作用域的初始状态。 双括号 与ng-bind双括号语法是AngularJS内置的模板语法，它会在内部$scope和视图之间创建绑定.在屏幕可视的区域内使用双括号会导致页面加载时未渲染的元素发生闪烁，用ng-bind可以避免这个问题。 ng-cloak除使用ng-bind来避免未渲染元素闪烁，还可以在含有双括号的元素上使用ng-cloak指令,ng-cloak指令会将内部元素隐藏，直到路由调用对应的页面时才显示出来 &lt;body ng-init=\"greeting='HelloWorld'\"&gt; &lt;p ng-cloak&gt;&#123;&#123; greeting &#125;&#125;&lt;/p&gt;&lt;/body&gt; ng-bind-template同ng-bind指令类似，ng-bind-template用来在视图中绑定多个表达式 ng-modelng-model指令用来将input、select、text area或自定义表单控件同包含它们的作用域中的属性进行绑定我们应该始终用ngModel来绑定$scope上一个数据模型内的属性，而不是$scope上的属性，这可以避免在作用域或后代作用域中发生属性覆盖。 ng-show/ng-hideng-show和ng-hide根据所给表达式的值来显示或隐藏HTML元素元素的显示或隐藏是通过移除或添加ng-hide这个CSS类来实现的。.ng-hide类被预先定义并且它的display属性的值为none ng-change这个指令会在表单输入发生变化时计算给定表达式的值。因为要处理表单输入，这个指令要和ngModel联合起来使用。 ng-formng-form用来在一个表单内部嵌套另一个表单。普通的HTML&lt;form&gt;标签不允许嵌套，但ng-form可以。 ng-clickng-click用来指定一个元素被点击时调用的方法或表达式 ng-selectng-select用来将数据同HTML的&lt;select&gt;元素进行绑定。这个指令可以和ng-model以及ng-options指令一同使用 &lt;div ng-controller=\"CityController\"&gt; &lt;select ng-model=\"city\" ng-options=\"city.name for city in cities\"&gt; &lt;option value=\"\"&gt;Choose City&lt;/option&gt; &lt;/select&gt; Best City: &#123;&#123; city.name &#125;&#125;&lt;/div&gt;angular.module('myApp',[]).controller('CityController',function($scope) &#123; $scope.cities = [ &#123;name: 'Seattle'&#125;, &#123;name: 'San Francisco'&#125;, &#123;name: 'Chicago'&#125;, &#123;name: 'New York'&#125;, &#123;name: 'Boston'&#125; ];&#125;); ng-submitng-submit用来将表达式同onsubmit事件进行绑定。这个指令同时会阻止默认行为（发送请求并重新加载页面），除非表单不含有action属性 ng-class使用ng-class 动态设置元素的类，方法是绑定一个代表所有需要添加的类的表达式。 ng-attr-(suffix) &lt;svg&gt; &lt;circle cx=\"&#123;&#123; cx &#125;&#125;\"&gt;&lt;/circle&gt;&lt;/svg&gt; 指出我们有一个非法属性。可以用ng-attr-cx来解决这个问题。&lt;svg&gt; &lt;circle ng-attr-cx=\"&#123;&#123; cx &#125;&#125;\"&gt;&lt;circle&gt;&lt;/svg&gt; 第十章、指令详解10.1 指令定义directive()这个方法是用来定义指令的angular.module('myApp', []).directive(name,factory_function()&#123; // 指令定义放在这里&#125;);angular.module('myApp', []).directive('myDirective', function() &#123; return &#123; restrict: String, priority: Number, terminal: Boolean, template: String or Template Function: function(tElement, tAttrs) (...&#125;, templateUrl: String, replace: Boolean or String, scope: Boolean or Object, transclude: Boolean, controller: String or function(scope, element, attrs, transclude, otherInjectables)&#123; ... &#125;, controllerAs: String, require: String, link: function(scope, iElement, iAttrs) &#123; ... &#125;, compile: // 返回一个对象或连接函数，如下所示： function(tElement, tAttrs, transclude) &#123; return &#123; pre: function(scope, iElement, iAttrs, controller) &#123; ... &#125;, post: function(scope, iElement, iAttrs, controller) &#123; ... &#125; &#125; // 或者 return function postLink(...) &#123; ... &#125; &#125; &#125;;&#125;); 指令的生命周期开始于$compile方法并结束于link方法 10.1.1 restrict（字符串）restrict是一个可选的参数。它告诉AngularJS这个指令在DOM中可以何种形式被声明,默认AngularJS认为restrict的值是A，即以属性的形式来进行声明 10.1.2 优先级（数值型）如果一个元素上具有两个优先级相同的指令，声明在前面的那个会被优先调用。如果其中一个的优先级更高，则不管声明的顺序如何都会被优先调用：具有更高优先级的指令总是优先运行 10.1.3 terminal（布尔型）这个参数用来告诉AngularJS停止运行当前元素上比本指令优先级低的指令。 10.1.4 template（字符串或函数）template参数是可选的，必须被设置为以下两种形式之一： 一段HTML文本; 一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个代表模板的字符串 在实际生产中，更好的选择是使用templateUrl参数引用外部模板 10.1.5 templateUrl（字符串或函数）templateUrl是可选的参数，可以是以下类型: 一个代表外部HTML文件路径的字符串； 一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个外部HTML文件路径的字符串。 默认情况下，调用指令时会在后台通过Ajax来请求HTML模板文件,模板加载后，AngularJS会将它默认缓存到$templateCache服务中。在实际生产中，可以提前将模板缓存到一个定义模板的JavaScript文件中，这样就不需要通过XHR来加载模板了 10.1.6 replace（布尔型）replace是一个可选参数，如果设置了这个参数，值必须为true，因为默认值为false。默认值意味着模板会被当作子元素插入到调用此指令的元素内部 10.2 指令作用域10.2.1 scope参数（布尔型或对象）scope参数是可选的，可以被设置为true或一个对象。默认值是false。当scope设置为true时，会从父作用域继承并创建一个新的作用域对象。内置指令ng-controller的作用，就是从父级作用域继承并创建一个新的子作用域。如果要创建一个能够从外部原型继承作用域的指令，需将scope属性设置为true 10.2.2 隔离作用域具有隔离作用域的指令最主要的使用场景是创建可复用的组件 10.3 绑定策略AngularJS提供了几种方法能够将指令内部的隔离作用域，同指令外部的作用域进行数据绑定。为了让新的指令作用域可以访问当前本地作用域中的变量，需要使用下面三种别名中的一种 本地作用域属性：使用@符号将本地作用域同DOM属性的值进行绑定。指令内部作用域可以使用外部作用域的变量 双向绑定：通过=可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定。 父级作用域绑定 通过&amp;符号可以对父级作用域进行绑定，以便在其中运行函数。意味着对这个值进行设置时会生成一个指向父级作用域的包装函数。 10.3.1 transcludetransclude是一个可选的参数。如果设置了，其值必须为true，它的默认值是false。嵌入通常用来创建可复用的组件，典型的例子是模态对话框或导航栏。为了将作用域传递进去，scope参数的值必须通过{}或true设置成隔离作用域。如果没有设置scope参数，那么指令内部的作用域将被设置为传入模板的作用域如果指令使用了transclude参数，那么在控制器（下面马上会介绍）中就无法正常监听数据模型的变化了。这就是最佳实践总是建议在链接函数里使用$watch服务的原因。 10.3.2 controller（字符串或函数）controller参数可以是一个字符串或一个函数angular.module('myApp', []).directive('myDirective', function() &#123; restrict: 'A', // 始终需要 controller: 'SomeController'&#125;) 可以在指令内部通过匿名构造函数的方式来定义一个内联的控制器：angular.module('myApp',[]).directive('myDirective', function() &#123; restrict: 'A', controller: function($scope, $element, $attrs, $transclude) &#123; // 控制器逻辑放在这里 &#125;&#125;); 控制器中也有一些特殊的服务可以被注入到指令当中。这些服务有： $scope 与指令元素相关联的当前作用域 $element 当前指令对应的元素 $attrs 由当前元素的属性组成的对象 $transclude 嵌入链接函数会与对应的嵌入作用域进行预绑定","tags":[{"name":"AngularJs","slug":"angularjs","permalink":"https://jesse121.github.io/tags/angularjs/"}]},{"title":"《JavaScript面向对象的编程指南》--读书笔记","date":"2016-06-09T16:00:00.000Z","path":"articles/notes/object-oriented-javascript.html","text":"第一章、引言1.5 面向对象的程序设计常用概念对象（名词）：是指“事物”在程序设计语言中的表现形式。这里的事物可以是任何东西，我们可以看到它们具有某些明确特征，能执行某些动作。这些对象特征就叫做属性（形容词），动作称之为方法（动词）。 类：实际上就是对象的设计蓝图或制作配方。类更多的是一种模板，而对象就是在这些模版的基础上被创建出来的。 封装：主要阐述对象中包含的内容。通常包括： 相关数据（用于存储属性） 基于这些数据所能做的事（所能调用的方法） 聚合：将几个现有对象合并成一个新对象的过程继承：实现代码重用多态：不同对象通过相同的方法调用来实现各自行为的能力 第二章、基本数据类型、数组、循环及条件表达式2.3基本数据类型2.3.2 指数表示法2e+3表示在数字2后面加3个0，即2000typeof Infinity // number typeof NaN // numbertypeof null // object null值表示一个空指针对象 2.3.4 惰性求值Javascript引擎在一个逻辑表达式中遇到一个非布尔类型操作数，那么该操作数的值就会成为该表达式返回的结果。true || \"something\" //truetrue &amp;&amp; \"something\" //\"something\" 2.9 练习题var s = \"1s\"; //隐式转换Number()用于任何数据类型s++ //NaN10 % \"0\" //NaN 如果被除数是有限大的数值而除数是零，则结果是NaN//乘法口诀程序代码for(var i=1;i&lt;10;i++)&#123; for(var j=1;j&lt;=i;j++)&#123; document.write(j+\"*\"+i+\"=\"+i*j+\" \"); &#125; document.write(\"&lt;br&gt;\");&#125; 第三章、函数3.1 函数3.1.2 函数参数函数内部都有一个内建的arguments数组，能返回函数所接收的所有参数function sumOnSteroids()&#123; var i,res = 0; for(i = 0; i &lt; arguments.length; i++)&#123; res += arguments[i]; &#125; return res;&#125;sumOnSteroids(1,2,3,4,5,6); //21 3.3 函数的作用域var a = 123;function f()&#123; alert(a); //undefined 这是因为函数域优先于全局域 var a = 1; alert(a); //1&#125;f(); 3.4.2 回调函数当我们将函数B传递给函数A，并由A来执行B时，B就成了一个回调函数function A(a,b,c,callback)&#123; var i=0,ar = []; for(i=0;i&lt;3;i++)&#123; ar[i] = callback(arguments[i]*2); &#125; return ar;&#125;function B(a)&#123; //回调函数 return a+1;&#125;A(a,b,c,B) 3.4.4 自调函数(function(name)&#123; alert('Hello '+name+' !');&#125;)('Jesse') //Hello Jesse !//第二对括号起到的是立即调用的作用，同时也是向函数传递参数的地方 使用自调函数的好处是不会产生任何全局变量，缺点是无法重复执行，这使得匿名自调函数最合适于执行一些一次性的或者初始化的任务 3.4.5 私有函数function a(param)&#123; function b(theinput)&#123; //私有函数 return theinput * 2 &#125;; return 'The result is '+b(param)&#125; 使用私有函数的好处： 有助于全局命名空间的纯净性（命名冲突的机会很小） 私有性–不被外部其他用用程序所用 3.4.7 能重写自己的函数这对于要执行某些一次性初始化工作的函数非常有用function a()&#123; alert('A'); //第一次调用该函数时该语句会被执行 a = function()&#123; //第一次调用时a被赋予新函数 alert('B'); //第二次调用该函数时该语句会被执行 &#125;;&#125;var a = function()&#123; function someSetup()&#123; var setup = 'done' &#125; function actualWork()&#123; alert('work') &#125; someSetup(); return actualWork;&#125;(); 3.5 闭包3.5.1 作用域链在函数内定义的变量在函数外是不可见的，但是如果该变量是在某个代码块中定义的（if或for语句中），它在代码块外是可见的。 3.5.2 词法作用域在javascript中每个函数都有一个属于自己的词法作用域，也就是说每个函数在被定义时（而非执行时）都会创建一个属于自己的环境（即作用域）function f1()&#123;var a = 1;f2();&#125;function f2()&#123;return a;&#125; //f2()被定义时a是不可见的，只能访问自身作用域和全局作用域f1(); //a is not defined 3.5.3 利用闭包突破作用域链3.5.3.1 闭包#1function f()&#123; var b = \"m\"; return function()&#123; //有着私有作用域，可以访问f()的作用域和全局作用域 return b; &#125; &#125;var n = f();n(); //m f()是全局函数，我们可以将它的返回值赋值给另一个全局变量，从而生成一个可以访问f()私有空间的新全局函数 3.5.3.3 相关定义与闭包#3如果一个函数在其父函数返回之后想留住对父级作用域的链接，就必须要为此建立一个闭包 3.5.3.4 循环中的闭包function f()&#123; var a = []; for(var i = 0; i &lt; 3; i++)&#123; a[i] = function()&#123; return i; &#125; &#125; return a;&#125;var s = f();s[0](); //3s[1](); //3s[2](); //3 我们在这里创建了3个闭包，它们都指向一个共同的局部变量i，但是闭包不会记录它们的值，他们所拥有的只是一个i的引用，因此只能返回i的当前值(循环结束时i=3).function f()&#123; var a = []; for(var i = 0; i &lt; 3; i++)&#123; a[i] = (function(x)&#123; return function()&#123; return x; &#125; &#125;)(i); &#125; return a;&#125;var s = f();s[0](); //0s[1](); //1s[2](); //2 3.7 练习题1.十六进制值转为颜色函数getRGB()function getRGB(hex)&#123; var rgb=[0,0,0]; if(/#(..)(..)(..)/g.test(hex))&#123; rgb=[parseInt(RegExp.$1,16),parseInt(RegExp.$2,16),parseInt(RegExp.$3,16)]; &#125;; return \"rgb(\"+rgb.join(\",\")+\")\";&#125;getRGB('#00ff00'); //\"rgb(0,255,0)\" 第四章、对象4.1 从数组到对象用[]定义数组的方法我们称之为数组文本标识法用{}定义对象的方法我们称之为对象文本标识法 4.1.2 哈希表、关联型数组在javascript中我们用数组表示索引型数组，用对象表示关联型数组 4.1.3 访问对象属性一般通过以下两种方式访问对象的属性： 中括号表示法：hero[‘name’] 点号表示法：hero.name 4.1.7 构造器函数function Hero(name)&#123; //构造器函数首字母大写 this.name = name; this.occupation = 'ninja'&#125;var hero = new Hero('jesse'); //使用new操作符创建新对象hero.name; //ninja 使用构造器函数的好处是能利用同一个构造器函数通过传参从而创建出不同的对象。 4.1.8 全局对象事实上程序所在的宿主环境一般都会为其提供一个全局对象，而所谓的全局变量其实只不过是该对象的属性 4.1.9 构造器属性构造器属性实际上是一个指向用于创建该对象的构造器函数的引用 hero.contructor //Hero 通过instanceof操作符，我们可以测试一个对象是不是由某个指定的构造器函数所创建的 hero instanceof Hero; //true 4.1.12 传递对象引用类型，因为其值大小不固定，因此栈内存中存放的只是该对象的访问地址，（即该对象的引用）堆内存为这个值分配空间。因此我们在引用上所做的任何改动，都会影响到他所引用的源对象。 4.2 内建对象4.2.1 Object所有对象都继承自Object对象，因此都具有toLocaleString()、toString()和valueOf()方法。var o = new Object();var o = &#123;&#125;;alert(o); //[object,Object] 由于alert()要接收字符串参数，所以它会在后台调用toString()方法 Object构造器的成员: 用Object()构造器所建对象的成员: 4.2.2 Arrayvar a = new Array();var a = [];typeof a; //'object' 数组也是对象 值得关注的数组的属性与方法 length属性：定义数组时会自动生成length属性，而一般对象中没有 sort()、join()、slice()、splice() Array对象的成员: 4.2.3 Function函数实际上也是一种对象，函数对象的内建构造器是Function() 定义函数的三种方式： function sum(a,b){return a + b;}; //函数声明 var sum = function(a,b){return a + b;}; //函数表达式 var sum = new Function(&#39;a&#39;,&#39;b&#39;,&#39;return a + b;&#39;); //Function构造器 避免使用 4.2.3.1 Function对象的属性: prototype属性详见第五章 length:用于记录该函数所拥有的参数数量 caller:返回一个调用该函数对象的外层函数引用function A()&#123;return A.caller;&#125;function B()&#123;return A();&#125;B(); //function B()&#123;return A();&#125; 4.2.3.2 Function对象的方法Function对象继承自Object对象，默认拥有Object对象的所有方法 call()、apply()方法都能让对象去借用其他对象中的方法为己所用，这也是一种代码重用的方式。 call()方法：var someObj = &#123; name: 'Ninja', say: function(who)&#123; return 'Hello '+who+', my name is '+ this.name; &#125;&#125;;var myObj = &#123; name:'Jesse'&#125;;someObj.say.call(myObj, 'Dude');//\"Hello Dude, my name is Jesse\"//当say()被调用时其中的this就被自动设置成myObj对象的引用 如果我们调用call方法时需要传递更多的参数，可以在后面依次加入他们 someObj.say.call(myObj,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) 如果我们没有将对象传递给call()的首参数，或者传递的是null，则它的调用对象默认为全局对象 apply()方法：apply()的工作方式与call()基本相同，唯一的不同之处在于第二个参数的传递形式apply()方法的第二个参数是通过一个数组来传递的 someObj.say.apply(myObj,[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) 4.2.3.3 重新认识arguments对象 在函数中通过arguments访问传递给函数的所有参数 arguments对象的callee属性，该属性返回的是当前被调用的函数对象 通过arguments.callee属性实现匿名函数的递归调用(function(count)&#123; if(count &lt; 5)&#123; console.log(count); arguments.callee(++count); &#125;&#125;)(1) //1,2,3,4 Function对象的成员 4.2.4 Booleanvar b = new Boolean();typeof b; //'object'typeof b.valueOf();// 'boolean' 4.2.5 NumberNumber对象的toString()方法有一个可选的radix参数（默认10）var n =new Number(255);n.toString(16); // 'ff' Number()构造器的成员 Number对象的成员 4.2.6 String当我们将一个基本字符串当做对象来使用时，后台会执行相应的String对象创建操作 String()构造器的成员 String对象的成员 4.2.7 MathMath对象既不能当做一般函数来使用，也不能用new操作符创建对象，只是一个包含一系列方法和属性的内建对象 获取某个max和min之间的值，公式((max-min)*Math.random())+min Math对象的成员 4.2.8 DateDate()构造器成员 Date对象的成员 4.2.9 RegExpvar reg = new RegExp('j.*t');var reg = /j.*t/; //匹配任何以j开头t结尾的字符串，且这俩字符之间包含1个或多个字符 4.2.9.1 RegExp对象的属性 global:如果该值为false（默认），相关搜索在找到第一个匹配位置时就会停止，如果为true则会找出所有匹配位置,简写为‘g’ ignoreCase:设置是否忽略大小写，默认为false,简写为’i’ multiline:设置是否跨行搜索，默认为false,简写为’m’ lastIndex:搜索开始的索引位置，默认为0。在对象创建之后可以修改 source:用于存储正则表达式匹配模式 var reg = /j.*t/img; 4.2.9.2 RegExp对象的方法 test():返回的是一个布尔值（找到匹配内容为true，否则为false） exec():返回的是一个由匹配字符串组成的数组 /j.*t/i.test('Javascript') //true /j.*t/i.exec('Javascript')[0] //Javascript 4.2.9.3 以正则表达式为参数的字符串方法 match():返回的是一个包含匹配内容的数组 search()：返回的是第一个匹配内容所在的位置 replace()：将匹配的文本替换成指定的字符串 split()：根据指定的正则表达式将目标字符串分割成若干数组元素var s = new String('HelloJavascriptWorld');s.match(/j.*a/ig); //['Java']s.search(/j.*a/i); //5//当某个匹配对象被找到时，如果我们想让相关的替换字符串中包含匹配的文本，可以使用$&amp;修饰符s.replace(/[A-Z]/g,'_$&amp;'); //\"_Hello_Javascript_World\"//如果正则表达式分了组（即带括号），那么可以用$1代表匹配分组中的第一组，$2代表第二组s.replace(/[A-Z]/g,'_$1'); //\"_Hello_Javascript_World\"var csv = 'one, two,three ,four';csv.split(/\\s*,\\s*/) //[\"one\", \"two\", \"three\", \"four\"]// \\s*匹配0个或多个空格//以上的4个方法可以接受的参数也包括字符串\"test\".replace('t','r'); //\"rest\" RegExp对象的成员 4.2.10 Error对象try&#123; //可能会导致错误的代码&#125;catch(e)&#123; //在发生错误时处理代码&#125;finally&#123; //可选的 //无论如何都会执行的代码&#125; 4.4 练习题c = [1,2,[1,2]];c.sort(); //[1, [1,2], 2] 4、在String()构造器不存在时，自定义MyString()构造器函数并通过以下测试function MyString(string)&#123; //this.length = this.toString = function()&#123; return string.toString(); &#125; this.valueOf = function()&#123; return string.valueOf(); &#125; this.reverse = function()&#123; return Array.prototype.reverse.apply(string.split('')).join(''); &#125;&#125;var s = new MyString('hello');s.length; //5s[0]; //'h's.toString(); //'hello's.valueOf(); //'hello's.chatAt(1); //'e's.concat(' world!'); //'hello world!'s.slice(0,-1); //'hell's.split('l'); //['he','','o'] 6、在Array()不存在时，创建MyArray()构造器并通过以下测试var a = new MyArray(1,2,3,'test');a.length;//4a.toString();//'1,2,3,test'a[a.length - 1];//'test'a.push('boo');//5a.pop();//'1,2,3,test'a.join(',');//'1,2,3,test'function MyArray()&#123; this.length = &#125; 第五章、原型5.1 原型属性5.1.4 利用自身属性重写原型属性如果在一个对象自身属性中没有找到指定的属性，就可以去原型链中查找相关属性。但是如果遇上对象自身属性与原型链属性同名时，那么对象自身属性的优先级高于原型链属性。function Gadget(name,color)&#123; this.name = name; this.color = color; this.method =function()&#123; return 1; &#125;&#125;Gadget.prototype.price = 10;Gadget.prototype.rating = 3;var newtoy = new Gadget('webcam','back');for(var prop in newtoy)&#123; console.log(prop + '=' + newtoy[prop]);&#125;//name=webcam//color=back//method=function ()&#123;return 1;&#125;//price=10//rating=3 hasOwnProperty()方法用于区分对象自身属性(返回true)与原型属性(返回false)newtoy.hasOwnProperty('name'); //truenewtoy.hasOwnProperty('price'); //false propertyIsEnumerable()方法对所有非内建对象属性返回true,表示可通过for-in枚举; newtoy.propertyIsEnumerable(&#39;name&#39;); //true isPrototypeOf()方法会告诉我们当前对象是否是另一个对象的原型var monkey = &#123; hair:true, feeds:'bananas', breathes:'air'&#125;;function Human(name)&#123; this.name = name;&#125;Human.prototype = monkey;var jesse = new Human('Jesse');monkey.isPrototypeOf(jesse); //true 5.2 扩展内建对象为Array对象添加inArray()方法，用于查询数组中是否存在某个特定的值if(!Array.prototype.inArray)&#123; //如果想通过原型为某个对象添加新属性，请务必检查该属性是否已存在 Array.prototype.inArray = function (needle)&#123; for(var i = 0;i &lt; this.length; i++)&#123; if(this[i] == needle)&#123; return true; &#125; &#125; return false; &#125;&#125;var a = ['a','b','c'];a.inArray('d'); //false 为String对象添加reverse()方法，用于反向输出该字符串if(!String.prototype.reverse)&#123; //如果想通过原型为某个对象添加新属性，请务必检查该属性是否已存在 String.prototype.reverse = function()&#123; return Array.prototype.reverse.apply(this.split('')).join(''); &#125;&#125;\"Jesse\".reverse(); //\"esseJ\"//首先利用this.split('')将目标字符串转为数组，并作为apply()的第二个参数，第一个参数不传值时默认为全局对象//再调用数组的reverse()方法生成反向数组//最后通过join()方法将数组转化为字符串 5.2.2 原型陷阱 当我们对原型对象完全替换时，可能会触发异常 prototype.constructor属性不可靠 解决方法:当我们重写某对象的prototype时，必须重置相应的constructor属性 5.4 练习题var shape = &#123; type:\"triangle\", getType:function()&#123; return this.type; &#125;&#125;function Triangle(a,b,c)&#123; this.a = a; this.b = b; this.c = c;&#125;Triangle.prototype = shape;//当我们重写某对象的prototype时，必须重置相应的constructor属性Triangle.prototype.constructor = Triangle;Triangle.prototype.getPerimeter = function()&#123; return this.a + this.b + this.c;&#125;var t = new Triangle(1,2,3);for(var prop in t)&#123; if(t.hasOwnProperty(prop))&#123; console.log(prop + '=' + t[prop]); &#125;&#125;t.constructor; //Trianle(a,b,c)shape.isPrototypeOf(t); //truet.getPerimeter(); //6t.getType(); //\"triangle\" 第六章、继承6.1 原型链6.1.1 原型链示例function Shape()&#123; this.name = 'shape'; this.toString = function()&#123;return this.name;&#125;;&#125;function TwoDShape()&#123; this.name = '2D shape';&#125;function Triangle(side,height)&#123; this.name = 'Triangle'; this.side = side; this.height = height; this.getArea = function()&#123; return this.side*this.height/2; &#125;&#125;TwoDShape.prototype = new Shape();Triangle.prototype = new TwoDShape();//我们用构造器Shape()另建了一个新的实体，然后用它去覆盖该对象的原型//这确保了在继承实现之后，我们对Shape()所进行的任何修改、重写、删除都不会对TwoShape()产生影响TwoDShape.prototype.constructor = TwoDShape;Triangle.prototype.constructor = Triangle;var my = new Triangle(5,10);my.getArea();//25my.toString(); // Triangle 6.1.2 将共享属性迁移到原型中function Shape()&#123;&#125;;Shape.prototype.name = 'shape';Shape.prototype.toString = function()&#123;return this.name;&#125;;function TwoDShape()&#123;&#125;;TwoDShape.prototype = new Shape();TwoDShape.prototype.constructor = TwoDShape;//我们需要在对原型对象进行扩展之前，先完成相关继承关系的构建TwoDShape.prototype.name = '2D shape';function Triangle(side,height)&#123; this.side = side; this.height = height;&#125;Triangle.prototype = new TwoDShape();Triangle.prototype.constructor = Triangle;Triangle.prototype.name = 'Triangle';Triangle.prototype.getArea = function()&#123; return this.side*this.height/2;&#125; 6.2 只继承于原型function Shape()&#123;&#125;;Shape.prototype.name = 'shape';Shape.prototype.toString = function()&#123;return this.name;&#125;;function TwoDShape()&#123;&#125;;//TwoDShape.prototype = new Shape(); new Shape()会将Shape的属性设定为对象自身属性，这样的代码是不可重用的TwoDShape.prototype = Shape.prototype;TwoDShape.prototype.constructor = TwoDShape;TwoDShape.prototype.name = '2D shape';function Triangle(side,height)&#123; this.side = side; this.height = height;&#125;Triangle.prototype = TwoDShape.prototype;//这样固然可以提高效率，但是子对象和父对象都指向同一对象，一旦对原型属性进行修改，继承的对象相关属性也随之改变Triangle.prototype.constructor = Triangle;Triangle.prototype.name = 'Triangle';Triangle.prototype.getArea = function()&#123; return this.side*this.height/2;&#125;var s = new Shape();s.name;//\"Triangle\" 6.3 uber–子对象访问父对象的方式在构建继承关系的过程中引入一个uber属性，并令其指向其父级原型对象 6.8 深拷贝当对象类型的属性拷贝时，实际上拷贝的只是该对象在内存中的位置指针，这一过程就是浅拷贝//浅拷贝function extendCopy(p)&#123; var c = &#123;&#125;; for(var i in p)&#123; c[i] = p[i]; &#125; c.uber = p; return c;&#125;//深拷贝function deepCopy(p,c)&#123; var c = c || &#123;&#125;; for(var i in p)&#123; if(typeof p[i] === 'object')&#123; c[i] = (p[i].constructor == Array) ? [] : &#123;&#125;; deepCopy(p[i],c[i]); //在遇到一个对象引用型的属性时，需要再次调用深拷贝 &#125;else&#123; c[i] = p[i]; &#125; &#125; return c;&#125;var parent = &#123; numbers:[1,2,3], letters:['a','b','c'], obj:&#123;prop:1&#125;, bool:true&#125;;var mydeep = deepCopy(parent);var myshallow = extendCopy(parent);mydeep.numbers.push(4,5,6); //6mydeep.numbers; //[1, 2, 3, 4, 5, 6]parent.numbers; //[1, 2, 3]myshallow.numbers.push(10); //4myshallow.numbers; //[1, 2, 3, 10]parent.numbers; //[1, 2, 3, 10]mydeep.numbers; //[1, 2, 3, 4, 5, 6] 6.9 object基于在对象之间直接构建继承关系的理念，可以用object()来接收父对象，并返回一个以该父对象为原型的新对象。function object(p)&#123; function F()&#123;&#125;; F.prototype = p; return new F();&#125; 6.12 寄生式继承var twoD = &#123; name:'2d shape', dimensions:2&#125;function triangle(s,h)&#123; var that = object(twoD);//把twoD对象全属性拷贝进that对象 that.name = 'Triangle'; that.getArea = function()&#123;return this.side * this.height / 2&#125;; that.side = s; that.height = h; return that;&#125; 6.14 本章小结实现继承的方法大致上分为两类： 基于构造器工作模式 基于对象工作模式 6.15 案例学习：图形绘制未完成 第七章、浏览器环境7.3 BOM7.3.1 Window对象window.open('新URL','新窗口名','以逗号分割的功能性列表')window.close();window.moveTo(x,y);window.moveBy(x,y);window.resizeTo(x,y);window.resizeBy(x,y);window.alert();window.prompt(); //点击确认返回相应文本，点击取消返回nullwindow.confirm();//点击确认返回true，点击取消返回falsewindow.setTimeout();//指定多长时间后执行代码window.setInterval();//指定每隔多长时间执行代码 7.3.2 navigation对象navigation.userAgent是一个用户浏览器识别的长字符串，但不要过分依赖这种用户代理字符串，浏览器能力检测是更好地选择 这种字符串很难追踪到所有的浏览器以及其各种版本 这种字符串可以被修改 7.3.3 location对象localtion对象的完整属性： href hash host hostname port protocol search location对象的方法： reload()重载某页面 assign()打开新URL，并在历史记录中生成新纪录 replace()与assign()相同，但不会生成新纪录 7.3.4 history对象history.forward();history.back(); 7.3.5 screen对象screen.width();screen.availwidth(); 7.4 DOM7.4.2 DOM节点的访问hasChildNodes()方法用于判断一个节点是否存在子节点hasAttributes()方法用于检查该元素中书否存在属性document.documentElement.childNodes.length; //2//任何节点都可以通过自身的parentNode来访问它的父节点document.documentElement.parentNode; //&lt;html&gt;document.getElementsByTagName();document.getElementsByName();document.getElementById();nextSibling/previousSibling;firstChild/lastChild 7.4.4 新建节点createElement();var myp = document.createElement('p');createTextNode();//新建文本节点appendChild();document.body.appendChild(myp);cloneNode(true)//true深拷贝 false浅拷贝insertBefore(要插入的节点,参照节点);replaceChild(要插入的节点,要替换的节点)removeChild(要移除的节点); 7.5 事件7.5.3 DOM的事件监听器addEventListener('事件类型',函数指针[,false]);removeEventListener('事件类型',函数指针[,false]);//匿名函数所定义的监听器是不能被移除的 该方法基于某一节点对象来调用，第三个参数决定代码是否采用事件捕捉，可选的，为了适应更多的浏览器，我们一般将其设置为false，即采用事件冒泡。 7.6 XMLHttpRequest对象//创建xhr对象var xhr;if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest();&#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\")&#125;//设置一个能触发readystatechange事件的事件监听器,及处理响应程序xhr.onreadystatechange=function()&#123; if (xhr.readyState==4 &amp;&amp; xhr.status==200)&#123; console.log(xhr.responseText); &#125;&#125;//open(请求类型,请求目标URL,是否异步请求)xhr.open('GET','somefile.txt',true);//发送请求xhr.send('') 7.8 练习题2.3function include(js)&#123; var script = document.createElement('script'); script.src = js; document.body.appendChild(script);&#125;include('somescript.js');3.1var myevent = &#123; addListener:function(el,type,fn)&#123; if(typeof window.addEventListener === 'function')&#123; myevent.addListener = function(el,type,fn)&#123; el.addEventListener(type,fn,false); &#125;; &#125;else if(typeof window.attachEvent === 'function')&#123; //code for IE myevent.addListener = function(el,type,fn)&#123; el.attachEvent('on'+type,fn); &#125;; &#125;else&#123; // code for older browsers myevent.addListener = function(el,type,fn)&#123; el['on' + type] = fn; &#125;; &#125; myevent.addListener(el,type,fn); &#125;, removeListener : function(el,type,fn)&#123; if(typeof window.removeEventListener === 'function')&#123; myevent.removeListener = function(el,type,fn)&#123; el.removeEventEventListener(type,fn,false); &#125;; &#125;else if(typeof window.detachEvent === 'function')&#123; //code for IE myevent.removeListener = function(el,type,fn)&#123; el.detachEvent('on'+type,fn); &#125;; &#125;else&#123; // code for older browsers myevent.removeListener = function(el,type,fn)&#123; el['on' + type] = null; &#125;; &#125; myevent.removeListener(el,type,fn); &#125;, getEvent:function(event)&#123;&#125;, getTarget:function(event)&#123;&#125;, stopPropagation:function(event)&#123;&#125;, preventDefault:function(event)&#123;&#125;&#125;4.1var ajax =&#123; request:function(url,requestType,queryString)&#123; var xhr; if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\") &#125; xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); &#125; &#125; xhr.open(requestType,url,true); xhr.send(''); &#125;&#125;ajax.request('some.txt','get'); 第八章、编程模式与设计模式8.1 编程模式8.1.2 命名空间与初始化分支模式为了减少命名冲突，最好的办法是将变量和方法定义在不同的命名空间中，这种方法的实质是只定义一个全局变量，并将其他的方法和属性定义为该变量的属性。var mySpace = &#123;&#125;;mySpace.event = &#123; addListener:null, removeListener:null ……&#125;if(typeof window.addEventListener === 'function')&#123; mySpace.event.addListener = function(el,type,fn)&#123; el.addEventListener(type,fn,false); &#125;; mySpace.event.removeListener = function(el,type,fn)&#123; el.removeEventListener(type,fn,false); &#125;;&#125;else if(typeof window.attachEvent === 'function')&#123; //code for IE mySpace.event.addListener = function(el,type,fn)&#123; el.attachEvent('on'+type,fn); &#125;; mySpace.event.removeListener = function(el,type,fn)&#123; el.detachEvent('on'+type,fn); &#125;;&#125;else&#123; // code for older browsers mySpace.event.addListener = function(el,type,fn)&#123; el['on' + type] = fn; &#125;; mySpace.event.removeListener = function(el,type,fn)&#123; el['on' + type] = null; &#125;;&#125; 8.1.4 延迟定义模式var mySpace = &#123;&#125;;mySpace.event = &#123; addListener:function(el,type,fn)&#123; if(typeof window.addEventListener === 'function')&#123; mySpace.event.addListener = function(el,type,fn)&#123; el.addEventListener(type,fn,false); &#125;; &#125;else if(typeof window.attachEvent === 'function')&#123; //code for IE mySpace.event.addListener = function(el,type,fn)&#123; el.attachEvent('on'+type,fn); &#125;; &#125;else&#123; // code for older browsers mySpace.event.addListener = function(el,type,fn)&#123; el['on' + type] = fn; &#125;; &#125; mySpace.event.addListener(el,type,fn); &#125;&#125;; 8.1.5 配置对象该模式适用于有很多参数的函数或方法 用单个对象来替代多个参数有以下几点优势： 不用考虑参数的顺序 可以跳过某些参数的设置 函数的扩展性强 代码可读性好 var myapp = &#123;&#125;;myapp.dom = &#123;&#125;;myapp.dom.Button = function(text,conf)&#123; var type = conf.type || 'submit'; var font = conf.font || 'microsoftyahei'; //……&#125;//使用方法如下：var config = &#123; font:'Arial,Verdana,microsoftyahei', color:'#fff'&#125;;new myapp.dom.Button('lalala',config); 8.1.6 私有属性和方法8.1.7 特权函数8.1.8 私有函数的公有化8.1.9 自执行函数(function()&#123; // code in here&#125;)()//该模式特写适用于某些脚本加载时所执行的一次性初始化工作 8.1.10 链式调用构造器返回的是新建对象的this指针，我们可以使用这些方法所返回的实例来调用其他方法document.body.appendChild( new mySpace.dom.Element('span') .setText('hello') .setStyle('color','red')); 8.1.11 JSONvar obj = JSON.parse(xhr.responseText); 8.2 设计模式8.2.2 单件模式8.2.3 工厂模式8.2.4 装饰器模式8.2.5 观察者模式","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]},{"title":"SublimeText3常用插件及快捷键总结","date":"2016-06-09T16:00:00.000Z","path":"articles/tool/the-usual-plugins-and-shortcut-key-of-sublimetext3.html","text":"SublimeText可谓是前端工程师的代码编辑神器，自从用上它以后一直爱不释手，特别是它强大的插件功能，简直要逆天了。网上也有很多关于SublimeText3的各种插件介绍，其插件功能之多，让人眼花缭乱。今天我主要是来整理一下自己常用的前端插件，并打包上传至我的github,欢迎大家下载交流，若有更好用的插件，还希望推荐。好了废话不多说现在就开始惊奇的sublime之旅 下载安装点击进入sublime官网,根据自己的电脑系统下载相应的版本将下载的压缩包解压后直接放进你要安装的文件夹，双击sublime_text.exe即可运行 获取license虽然没有许可证也可以使用，但软件开发及维护不易，建议有条件的同学还是购买license，获得永久使用权 插件安装这是今天的重点，在安装插件之前我们需要安装package control组件 在线安装 按ctrl+`调出console面板,粘贴以下代码（或者SUBLIME TEXT 3面板中的代码）到命令行并回车 import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 重启Sublime Text 3。如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。 手动安装 如果你的电脑没有外网权限(小编就是这样)，那只能手动安装了 点击Preferences 选择Browse Packages… ，打开其上一级文件夹Data并进入Installed Packages文件夹 将下载的Package Control.sublime-package文件复制进去，再重启Sublime Text 安装方法介绍 在线安装 按下Ctrl+Shift+P调出命令面板，输入install选择Install Package 选项并回车， 再输入你要安装的插件名称(例如sublime tmpl)，然后在列表中选中要安装的插件。 安装成功后一般在Perferences-&gt;package settings中可看到 有些插件有可能在列表中搜索不到，你可以选择手动安装 手动安装 进入sublimetext安装包管理器官网在搜索框里输入你所需要的插件名称 进入插件的github页面（点击Details下面的github.com）,点击右侧的clone or download -&gt; Download ZIP,将下载的压缩包解压后放在Preferences-&gt;Browse Packages（即packages文件夹）里面，并重命名（去掉文件名中的-master） 重启Sublimetext3即可安装成功 There are no packages available for installation现实中没有什么事情总是一帆风顺的，特别是计算机程序，时不时就给你来点意外情况。例如在在线安装步骤中选择Install Package后Sublime弹出窗口提示There are no packages available for installation出现的原因：据说是IPv6的原因，如果我们的Intent服务提供者（ISP）不支持IPv6就会引发上述错误，解决方法一：打开C:\\Windows\\system32\\drivers\\etc\\hosts文件，增加如下对应关系：50.116.34.243 sublime.wbond.net终极解决方法：用手动安装插件 在线安装的插件介绍1. Alignment使用说明：Alignment是一个代码格式化插件，它可以使多行代码中的等号对齐，也可以调整多行代码为一个缩进级别。快捷键：ctrl+shift+alt+a 2. AutoFileName使用说明：文件名自动补全 3. BracketHighlighter使用说明：BracketHighlighter插件是用来匹配相对的符号，然后高亮显示，比如{ }、[ ]、” “等符号的对应高亮显 4. ConvertToUTF8使用说明：自动转为UTF-8编码类型 5. DeleteBlankLines使用说明：选中需要批量删除空行的部分，Ctrl + Alt + Backspace，选中部分的所有空行就都被删除了快捷键：ctrl+alt+backspace 6. DocBlockr使用说明：生成js ,php 等语言函数注释,只需要在函数上面输入/** ,然后按tab 就会自动生成注释 7. Emmet使用说明：它让编写 HTML 代码变得简单。Emmet用法参见Emmet插件使用方法总结 8.HTML-CSS-JS Prettify使用说明：快速格式化html css js快捷键：ctrl+shift+h 9. jQuery使用说明：会出现jquery提示 10. LESS使用说明：支持less语法高亮 11. Less2Css使用说明：ctrl+s保存less文件时，会将目录下所有less文件自动编译为同名的css文件，详细使用方法参见sublime中如何用less实现css预编译快捷键：ctrl+s 12. SideBarEnhancements使用说明：SideBarEnhancements 是一款很实用的右键菜单增强插件，有以 diff 形式显示未保存的修改、在文件管理器中显示该文件、复制文件路径、在侧边栏中定位该文件等功能，也有基础的诸如新建文件/目录，编辑，打开/运行，显示，在选择中/上级目录/项目中查找，剪切，复制，粘贴，重命名，删除，刷新等常见功能。 13. SublimeCodeInte使用说明：Sublime​Code​Intel 是一个代码提示、补全插件，支持 JavaScript、Mason、XBL、XUL、RHTML、SCSS、Python、HTML、Ruby、Python3、XML、Sass、XSLT、Django、HTML5、Perl、CSS、Twig、Less、Smarty、Node.js、Tcl、TemplateToolkit 和 PHP 等语言，是 Sublime Text 自带代码提示功能的很好扩展。 14. sublime tmpl使用说明：按指定快捷键生成模板。快捷键：ctrl+alt+h 新建html模板文件ctrl+alt+j 新建javascript模板文件ctrl+alt+c 新建css模板文件ctrl+alt+p 新建php模板文件ctrl+alt+r 新建ruby模板文件ctrl+alt+shift+p 新建python模板文件 15. SublimeLinter使用说明：它可以帮你找出错误或编写不规范的代码 需要安装nodejs,jshint 16. SublimeLinter-jshint使用说明：对错误的javascript代码在状态栏进行提示， 17. Terminal使用说明：调出终端直接进入项目所在根目录，这个插件与gulp配合很好用快捷键：ctrl+shift+t 18. View In Browser使用说明：sublime以本地服务器方式打开网页为了使用插件，你需要建立一个sublime-project文件，点击Project-&gt;Edit Project粘贴以下代码(这是我的相关配置),并保存到user目录下&#123; \"folders\": [ &#123; \"path\": \"D:\\\\wamp\\\\www\" &#125; ], \"settings\": &#123; \"sublime-view-in-browser\": &#123; \"baseUrl\": \"http://localhost\" \"basePath\": \"D:\\\\wamp\\\\www\", //本地虚拟主机根目录 &#125; &#125;&#125; 快捷键：ctrl+alt+v 19. MarkdownEditing使用说明：它支持Markdown语法高亮显示。 20. OmniMarkupPreviewer使用说明：用来在浏览器中预览markdown 编辑的效果快捷键：ctrl+alt+o 手动安装的插件介绍注意：手动安装的插件不会自动添加到Package Control.sublime-package文件 1. Compact​Expand​Css下载地址:https://github.com/TooBug/CompactExpandCss使用说明：css横竖向排列切换快捷键：ctrl+alt[横向排列ctrl+alt]竖向排列 2. Codelf下载地址：Codelf for Sublime Text使用说明：变量命名神器Codelf通过搜索在线开源平台的项目源码帮开发者给变量命名 ，有了它再也不用为了命名而绞尽脑汁了快捷键：鼠标右键，选择Codelf 待定的插件sublime git YUI compress livestyle GBKEncoding support 中文支持 php_beautifier php code sniffer Sublime Text 3 快捷键大全选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11：全屏模式 Shift+F11 免打扰模式","tags":[{"name":"SublimeText3","slug":"sublimetext3","permalink":"https://jesse121.github.io/tags/sublimetext3/"}]},{"title":"CSS选择器总结","date":"2016-05-25T16:00:00.000Z","path":"articles/html-css/css-selector-summary.html","text":"本文主要介绍css各种选择器，总结一下方便自己查询与使用 选择器 优先级 实例 ID选择器 100 #E 类选择器 10 .E 伪类选择器 10 :link,:visited, :focus, :hover, :actived, :lang &nbsp;&nbsp;&nbsp;&nbsp;UI元素状态伪类 E:enabled{}匹配所有用户界面（form表单）中处于可用状态的E元素 E:disabled{}匹配所有用户界面（form表单）中处于不可用状态的E元素 E:checked{}匹配所有用户界面（form表单）中处于选中状态的E元素 &nbsp;&nbsp;&nbsp;&nbsp;结构性伪类 E:first-child{}匹配父元素中第一个E元素 E:last-child{}匹配父元素中最后一个E元素 E:nth-child(n){}匹配第n个子元素E E:nth-last-child(n){}匹配倒数第n个结构子元素E E:nth-of-type(n){}匹配同类型中的第n个同级兄弟元素E E:nth-last-of-type(n){}匹配同类型中的倒数第n个同级兄弟元素E E:first-of-type{}匹配同级兄弟元素中的第一个E元素 E:only-child{}匹配属于父元素中唯一子元素的E E:only-of-type{}匹配属于同类型中唯一兄弟元素的E E:root{} 不常用 匹配文档的根元素。在HTML中，根元素永远是HTML E:empty{} 不常用 匹配没有任何子元素（包括text节点）的元素E &nbsp;&nbsp;&nbsp;&nbsp;否定伪类 p:not(s){}匹配所有不匹配简单选择符s的元素p &nbsp;&nbsp;&nbsp;&nbsp;目标伪类 不常用 属性选择器 10 &nbsp;&nbsp;&nbsp;&nbsp;简单属性选择器 h1[foo]{color:red;} &nbsp;&nbsp;&nbsp;&nbsp;具体属性值选择器 h1[foo=”sun”]{color:red;} 选择foo属性值是sun的所有h1元素 &nbsp;&nbsp;&nbsp;&nbsp;子串匹配属性选择器 h1[foo*=”sun”]{color:red;} 选择foo属性值中包含sun的所有h1元素 h1[foo^=”sun”]{color:red;} 选择foo属性值以sun开头的所有h1元素 h1[foo$=”sun”]{color:red;} 选择foo属性值以sun结尾的所有h1元素 元素选择器 1 &nbsp;&nbsp;&nbsp;&nbsp;子元素选择器 h1 &gt; span{color:red;} &nbsp;&nbsp;&nbsp;&nbsp;相邻兄弟元素选择器 h1 + h1{font-size:20px;} 伪元素选择器 1 p::first-letter{}设置段落p的首字母样式 p::first-line{} 设置段落p的首行样式 p::before{} p::after{} p::selection{}设置被用户选取部分的样式","tags":[{"name":"CSS","slug":"css","permalink":"https://jesse121.github.io/tags/css/"}]},{"title":"jQuery插件开发总结","date":"2016-05-15T16:00:00.000Z","path":"articles/jquery/jQuery-plugin-development.html","text":"自从用上了jQuery之后，发现真是离不开它，它几乎成了前端开发的标配，越来越多的前端项目中引入了jQuery。在实际开发中我们常常需要载入一些其他jQuery插件，起初都是从网上找的一些别人已经写好的插件，可有些插件却不太适合自己目前的项目，于是尝试着修改了一些插件源码。最终目标是自己能开发出一个适合项目所需的jQuery组件。在开发jQuery插件时也是有一些套路可寻的，今天就来总结一下jQuery插件开发的几种方法。 jQuery插件开发两个底层方法jQuery.extend([deep ], target [, object1 ] [, objectN ] )将两个或更多对象的内容合并到第一个对象。 deep 如果是true，合并成为递归（又叫做深拷贝） target 一个对象，如果object对象存在新属性或新方法，那么target将接收新的属性或方法，如果它是唯一的参数则将扩展jQuery的命名空间，这对于插件开发者希望向 jQuery 中添加新方法是很有用的。 object1 一个对象，它包含额外的属性合并到第一个参数 objectN 包含额外的属性合并到第一个参数 当我们提供两个或多个对象给$.extend()，对象的所有属性都添加到目标对象（target参数）目标对象将被修改，并且将通过$.extend()返回。然而，如果我们想保留原对象，我们可以通过传递一个空对象作为目标对象：var settings = $.extend({}, defaults, options);这样defaults对象就不会被更改在默认情况下，通过$.extend()合并操作是不递归的，如果第一个对象的属性本身是一个对象或数组，那么它将完全用第二个对象相同的key重写这个属性。这些值不会被合并。;//注意浅拷贝和深拷贝的区别var object1 = &#123;apple: 0,banana: &#123;weight: 52, price: 100&#125;,cherry: 97&#125;;var object2 = &#123;banana: &#123;price: 200&#125;,durian: 100&#125;;$.extend(object1, object2);//&#123;apple: 0, banana: &#123;price:200&#125;, cherry: 97, durian: 100&#125;$.extend(true, object1, object2);//&#123;apple: 0, banana: &#123;weight: 52, price:200&#125;, cherry: 97, durian: 100&#125; jQuery.fn.extend()在jQuery源码中有jQuery.fn = jQuery.prototype = function(){……}即指向jQuery对象的原型链，对其它进行的扩展，作用在jQuery对象上面； 总结 jQuery.extend()能够创建全局函数或选择器，在实际开发中常使用jQuery.extend()方法作为插件方法传递系列选项结构的参数 jQuery.fn.extend()能够创建jQuery对象方法，一般用此方法来扩展jQuery的对象插件 jQuery插件开发通用框架;(function($, window, document, undefined)&#123; //Plugin code here&#125;)(jQuery, window, document); 使用分号是为了防止因前面的代码没有使用分号而导致插件函数不能正确解析传入jQuery是为了确保在匿名函数中正确的使用jQuery对象，防止多库共存时$冲突传入window、document并非必须，只不过为了更快的访问window和document传入undefined是为了防止undefined变量被更改，确保undefined的准确性 jQuery插件开发的3种形式类级别开发(封装全局函数的插件)方式1 常用;(function($, window, document, undefined)&#123; $.pluginName = function()&#123; //Plugin implementation code here &#125;; &#125;)(jQuery, window, document); 方式2 当全局函数较多时;(function($, window, document, undefined)&#123; $.extend(&#123; pluginName = function()&#123; //Plugin implementation code here &#125;; &#125;)&#125;)(jQuery, window, document); 调用方法：$.pluginName(); 对象级别的插件开发方式1 常用;(function($, window, document, undefined)&#123; $.fn.pluginName = function(options) &#123; return this.each(function() &#123; //this关键字代表了这个插件将要执行的jQuery对象 //return this.each()使得插件能够形成链式调用 var defaults = &#123; //pro : value &#125;; var settings = $.extend(&#123;&#125;, defaults, options); // plugin implementationcode here &#125;); &#125;&#125;)(jQuery, window, document); 方式2;(function($, window, document, undefined)&#123; $.fn.extend(&#123; pluginName : function()&#123; return this.each(function()&#123; // plugin implementationcode here &#125;); &#125;; &#125;)&#125;)(jQuery, window, document); 方式3将原型和构造函数组合使用，使得通过构造函数创建的每个实例既能实现对原型属性和方法的继承，从而实现函数复用，也能实现对实例属性的继承保证每个实例都有自己的属性。;(function($, window, document, undefined) &#123; //定义构造函数 var pluginName = function(ele, opt) &#123; this.element = ele; this.defaults = &#123; //设置默认参数 &#125;; this.options = $.extend(&#123;&#125;, this.defaults, opt); &#125; //定义pluginName的原型方法 pluginName.prototype = &#123; init: function() &#123; //this.element // plugin implementationcode here &#125; // 补充其他相关的方法 &#125; $.fn.pluginName = function(options) &#123; //创建pluginName的实体 var pluginObj = new pluginName(this, options); //调用其方法 pluginObj.init(); //返回jQuery选择器的集合，以便链式调用 return this; &#125;&#125;)(jQuery, window, document); 方式4 不常用这种类型的插件架构允许您封装所有的方法在父包中，通过传递该方法的字符串名称和额外的此方法需要的参数来调用它们。;(function($, window, document, undefined) &#123; // 在我们插件容器内，创造一个公共变量来构建一个私有方法 var privateFunction = function() &#123; // code here &#125; // 通过字面量创造一个对象，存储我们需要的公有方法 var methods = &#123; // 在字面量对象中定义每个单独的方法 init: function() &#123; //为了更好的灵活性，对来自主函数并进入每个方法中的选择器其中的每个单独的元素都执行代码 return this.each(function() &#123; // 为每个独立的元素创建一个jQuery对象 var $this = $(this); // 创建一个默认设置对象 var defaults = &#123; propertyName: 'value', onSomeEvent: function() &#123;&#125; &#125; // 使用extend方法从options和defaults对象中构造出一个settings对象 var settings = $.extend(&#123;&#125;, defaults, options); // 执行代码 // 例如： privateFunction(); &#125;); &#125;, destroy: function() &#123; // 对选择器每个元素都执行方法 return this.each(function() &#123; // 执行代码 &#125;); &#125; &#125;; $.fn.pluginName = function() &#123; // 获取我们的方法，遗憾的是，如果我们用function(method)&#123;&#125;来实现，这样会毁掉一切的 var method = arguments[0]; // 检验方法是否存在 if (methods[method]) &#123; // 如果方法存在，存储起来以便使用 // 注意：我这样做是为了等下更方便地使用each（） method = methods[method]; // 如果方法不存在，检验对象是否为一个对象（JSON对象）或者method方法没有被传入 &#125; else if (typeof(method) == 'object' || !method) &#123; // 如果我们传入的是一个对象参数，或者根本没有参数，init方法会被调用 method = methods.init; &#125; else &#123; // 如果方法不存在或者参数没传入，则报出错误。需要调用的方法没有被正确调用 $.error('Method ' + method + ' does not exist on jQuery.pluginName'); return this; &#125; // 调用我们选中的方法 // 再一次注意我们是如何将each()从这里转移到每个单独的方法上的 return method.call(this); &#125;&#125;)(jQuery, window, document); 调用方法：$(‘selector’).pluginName(); 通过$.widget()应用jQuery UI的部件工厂方式创建用来开发更高级jQuery部件的，该模式开发出来的部件带有很多jQuery内建的特性，比如插件的状态信息自动保存，各种关于插件的常用方法等 编写JQuery插件需要注意的地方： 插件的推荐命名方法为：jquery.[插件名].js 所有的对象方法都应当附加到jQuery.fn对象上面，而所有的全局函数都应当附加到jQuery对象本身上。 可以通过this.each() 来遍历所有的元素 在jQuery开发中，this关键词通常引用的是当前正在操作的DOM元素，但在当前的jQuery插件上下文中，this关键词引用的是当前jQuery实例自身，唯一的例外是在当前jQuery集合中遍历所有元素时，$.each循环体内的this引用的是这一轮遍历所暴露的DOM元素 所有方法或函数插件，都应当以分号结尾，否则压缩的时候可能会出现问题。为了更加保险写，可以在插件头部添加一个分号(;)，以免他们的不规范代码给插件带来影响。 插件应该返回一个jQuery对象，以便保证插件的可链式操作。","tags":[{"name":"jQuery","slug":"jquery","permalink":"https://jesse121.github.io/tags/jquery/"}]},{"title":"CSS3新特性，兼容性，兼容方法总结","date":"2016-04-28T14:46:26.000Z","path":"articles/html-css/css3-new-features-compatibility-compatibility-methods-summary.html","text":"参考工具css3手册CSS3 click chart border-radius用于添加圆角效果 语法:border-radius：[ &lt;length&gt; | &lt;percentage&gt; ]&#123;1,4&#125; [ / [ &lt;length&gt; | &lt;percentage&gt; ]&#123;1,4&#125; ]? &lt;length&gt;：用长度值设置对象的圆角半径长度。不允许负值&lt;percentage&gt;：用百分比设置对象的圆角半径长度。不允许负值 实例:border-radius:10px; border-radius:5px 10px 15px 20px; //顺序是顺时针border-radius:26px 106px 162px 32px/28px 80px 178px 26px; //标准语法格式border-radius:50%; //是相对于元素占据尺寸的百分比，即包含边框和padding后的尺寸.radius&#123; border-top-left-radius:5px; /*左上角，注意顺序是先上下后左右*/ border-top-right-radius:10px; /*右上角*/ border-bottom-left-radius:15px; /*左下角*/ border-bottom-left-radius:20px; /*右下角*/ /*即使元素没有边框，圆角也可以用到 background 上面， 具体效果受 background-clip 影响。*/ background-color:red; &#125; 兼容性：IE9+,Firefox4+,Chrome5+,Safari5+,Opera01.5+,iOS Safari4+,Android Browser2.2+ ,Android Chrome18+ 兼容方法：低版本的chrome:-webkit-border-radius:10px;低版本的firefox:-moz-border-radius:10px;IE6/7/8: 使用DD_roudies.js(推荐)，详情参考DD_roundies &lt;style type=\"text/css\"&gt;.radius &#123; width: 300px; height: 300px; border:1px solid red;&#125;&lt;/style&gt;&lt;div class=\"radius\"&gt;&lt;/div&gt;&lt;script src=\"http://dillerdesign.com/experiment/DD_roundies/DD_roundies_0.0.2a-min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; DD_roundies.addRule('.radius', '10px 15px 30px 0',false);&lt;/script&gt; 使用jquery.corner.js，详情参考jquery.corner.js &lt;style type=\"text/css\"&gt;.render &#123; width: 300px; height: 300px; background: red;&#125;&lt;/style&gt;&lt;div class=\"render\"&gt;&lt;/div&gt;&lt;script src=\"http://apps.bdimg.com/libs/jquery/1.2.6/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"jquery.corner.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $('.render').corner(\"top 30px\");&lt;/script&gt; 引入ie-css3兼容文件，详情参阅让IE6/IE7/IE8浏览器支持CSS3属性 .radius&#123; -moz-border-radius: 15px; /* Firefox */ -webkit-border-radius: 15px; /* Safari 和 Chrome */ border-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 */ behavior: url(ie-css3.htc);&#125; 详情参阅border-radius box-shadow用于添加阴影效果 语法：box-shadow：none|[inset? &amp;&amp; [&lt;offset-x&gt;&lt;offset-y&gt;&lt;blur-radius&gt;?&lt;spread-radius&gt;?&lt;color&gt;?]]# inset：设置对象的阴影类型为内阴影。该值为空时，则对象的阴影类型为外阴影&lt;offset-x&gt;: 这是第一个 length值设置水平偏移量，如果是负值则阴影位于元素左边。&lt;offset-y&gt;: 这是第二个 length值设置垂直偏移量，如果是负值则阴影位于元素上面。&lt;blur-radius&gt;:这是第三个 length值。值越大，糊糊面积越大，阴影就越大越淡。不能为负值。默认为0，此时阴影边缘锐利。&lt;color&gt;：设置对象的阴影的颜色。 实例：box-shadow: 10px 10px 5px gray; box-shadow: 3px 3px green, -1em 0 0.4em gold; 兼容性：IE9.0+,Firefox4.0+,Chrome10.0+,Safari5.1+,Opera10.5+,Safari5.0+,Android Browser4.0+,Android Chrome18.0+ 兼容方法：低版本的chrome:-webkit-box-shadow:10px 10px 5px #888;低版本的firefox:-moz-box-shadow:10px 10px 5px #888;IE6/7/8: 引入ie-css3兼容文件(推荐)，缺点：不支持除了黑色(#000)以外的其他颜色，详情参阅让IE6/IE7/IE8浏览器支持CSS3属性 .box&#123; width:100px; height:100px; background-color:red; -webkit-box-shadow:10px 10px 5px gray; -moz-box-shadow:10px 10px 5px gray; box-shadow: 10px 10px 5px gray; behavior:url(ie-css3.htc);&#125; 使用DropShadow滤镜，缺点：阴影不能边缘模糊 filter:progid:dXImageTransform.Microsoft.DropShadow(color=#888888,offX=10,offY=10,positives=true); 使用Shadow滤镜，类似于投影效果，缺点：阴影不能边缘模糊 filter:progid:DXImageTransform.Microsoft.Shadow(color='#0099ff', Direction='120', Strength='10'); 详情参阅box-shadow border-image用来给元素边框添加背景图片 语法：border-image：&lt;' border-image-source '&gt; || &lt;' border-image-slice '&gt; [ / &lt;' border-image-width '&gt; | / &lt;' border-image-width '&gt;? / &lt;' border-image-outset '&gt; ]? || &lt;' border-image-repeat '&gt; &lt;’ border-image-source ‘&gt;：设置或检索对象的边框是否用图像定义样式或图像来源路径。&lt;’ border-image-slice ‘&gt;： 设置或检索对象的边框背景图的分割方式,该属性指定从上，右，下，左方位来分隔图像，将图像分成4个角，4条边和中间区域共9份，中间区域始终是透明的（即没图像填充），除非加上关键字 fill。&lt;’ border-image-width ‘&gt;： 设置或检索对象的边框厚度。&lt;’ border-image-outset ‘&gt;：设置或检索对象的边框图像可超出边框盒的大小。&lt;’ border-image-repeat ‘&gt;：设置或检索对象的边框图像的平铺方式repeat,round,stretch。 实例：border-image:url(&quot;http://www.w3school.com.cn/i/border.png&quot;) 30 30 round; border-image:url(&quot;http://www.w3school.com.cn/i/border.png&quot;) 30 30 stretch; 兼容性：IE11+, Firefox15+, Chrome16+ , Safari6+,Opera15+,iOS Safari6+,Android Browser4.4+, Android Chrome18+ 兼容方法：低版本的chrome:-webkit-border-image:url(&quot;http://www.w3school.com.cn/i/border.png&quot;) 30 30 stretch;低版本的firefox:-moz-border-image:url(&quot;http://www.w3school.com.cn/i/border.png&quot;) 30 30 stretch;低版本的Opera:-o-border-image:url(&quot;http://www.w3school.com.cn/i/border.png&quot;) 30 30 stretch;IE未解决详情参阅border-image,border-image background-size设置背景图片大小。 语法：background-size：&lt;bg-size&gt;#&lt;bg-size&gt; = [ &lt;length&gt; | &lt;percentage&gt; | auto ]{1,2} | cover | contain&lt;length&gt;：用长度值指定背景图像大小。不允许负值。&lt;percentage&gt;：用百分比指定背景图像大小。不允许负值。auto：背景图像的真实大小。cover：将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器。contain：将背景图像等比缩放到宽度或高度与容器的宽度或高度相等，背景图像始终被包含在容器内。 实例：background-size: cover; background-size: contain; 兼容性：IE9+,Firefox4+, Chrome15+,Safari7+, Opera15+, iOS Safari7+, Android Browser4.4+, Android Chrome18+ 兼容方法：低版本的chrome:-webkit-background-size:10px 10px 5px #888; //不支持background简写低版本的firefox:-moz-background-size:10px 10px 5px #888;IE8： 方法一(推荐)、引入backgroundsize.min.htc兼容文件 .size &#123; width: 400px; height: 400px; margin: 20px auto 0; background: green url(img/1.jpg) no-repeat scroll center 0; background-size: cover; -ms-behavior: url(js/backgroundsize.min.htc);&#125; 方法二、针对IE8的hack &lt;!--[if IE 8]&gt;&lt;style type=\"text/css\"&gt;.size&#123; -ms-filter: \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='img/1.jpg', sizingMethod='scale')\";&#125; //该函数只能模仿cover值,IE8下效果与IE9/10稍有不同,图片占满背景大小且不超出,而且可能会带来其他影响&lt;/style&gt;&lt;![endif]--&gt; 详情参阅background-size background-origin指定背景图片background-image 属性的原点位置的背景相对区域,当使用 background-attachment 为fixed时，该属性将被忽略不起作用 语法：background-origin：&lt;box&gt;#&lt;box&gt; = border-box | padding-box | content-boxpadding-box：从padding区域（含padding）开始显示背景图像。border-box： 从border区域（含border）开始显示背景图像。content-box：从content区域开始显示背景图像 实例：background-origin:content-box;padding:10px; 111111111111111111111111111background-origin:border-box;padding:10px;border:15px solid transparent;111111111111111111 兼容性：IE9+,Firefox4.0+ Chrome4.0+ Safari6.0+, iOS Safari6.0+, Android Browser3.0+, Android Chrome18+ 兼容方法：firefox4.0以下：-moz-background-origin:padding | border; //没有contentIE8下background-origin默认为padding-box详情参阅background-origin background-clip设置元素的背景（背景图片或颜色）是否延伸到边框下面。 语法：background-clip：&lt;box&gt;#&lt;box&gt; = border-box | padding-box | content-box | inheritborder-box背景延伸到边框外沿（但是在边框之下）。padding-box边框下面没有背景，即背景延伸到内边距外沿。content-box背景裁剪到内容区 (content-box) 外沿。 实例：background-clip:border-box; 111111111111111 兼容性：IE9+,Firefox4.0+, Chrome4.0+, Safari6.0+,iOS Safari6.0+, Android Browser3.0+, Android Chrome18.0+ 兼容方法：firefox4.0以下：-moz-background-clip:padding | border; //没有contentIE8下background-clip默认为padding-box multiple backgrounds语法：background：[&lt;bg-layer&gt;,]*&lt;final-bg-layer&gt;&lt;bg-layer&gt;=&lt;bg-image&gt;||&lt;position&gt;[/&lt;bg-size&gt;]?||&lt;repeat-style&gt;||&lt;attachment&gt;||&lt;box&gt;||&lt;box&gt;&lt;final-bg-layer&gt;=&lt;bg-image&gt;||&lt;position&gt;[/&lt;bg-size&gt;]?||&lt;repeat-style&gt;||&lt;attachment&gt;||&lt;box&gt;||box&gt;||&lt;'background-color'&gt; 实例：background: url(test1.jpg) no-repeat scroll 10px 20px/50px 60px padding-box, url(test1.jpg) no-repeat scroll 10px 20px/70px 90px padding-box, url(test1.jpg) no-repeat scroll 10px 20px/110px 130px padding-box #aaa; 兼容性：IE9+,Firefox3.6+, Chrome4.0+, Safari3.1+ 兼容方法：未解决 text-shadow为文字添加阴影 语法：textshadow：none | [inset? &amp;&amp; [ &lt;offset-x&gt; &lt;offset-y&gt; &lt;blur-radius&gt;?&lt;color&gt;? ] ]#inset：设置对象的阴影类型为内阴影。该值为空时，则对象的阴影类型为外阴影&lt;offset-x&gt;: 这是第一个 length值设置水平偏移量，如果是负值则阴影位于元素左边。&lt;offset-y&gt;: 这是第二个 length值设置垂直偏移量，如果是负值则阴影位于元素上面。&lt;blur-radius&gt;:这是第三个 length值。值越大，糊糊面积越大，阴影就越大越淡。 不能为负值。默认为0，此时阴影边缘锐利。&lt;color&gt;：设置对象的阴影的颜色。 实例：text-shadow:1px 1px 2px red; 12212121 兼容性：IE10+, Firefox3.5+, Chrome4.0+, Safari6.0+ 兼容方法：低版本的chrome:-webkit-text-shadow:1px 1px 1px #000;低版本的firefox:-moz-text-shadow:1px 1px 1px #000;IE6/7/8: 方法一、引入ie-css3兼容文件behavior:url(ie-css3.htc); 方法二、 filter:shadow(color=blue,direction=225),direction表示投影角度 详情参阅让IE6/IE7/IE8浏览器支持CSS3属性 word-wrap浏览器是否允许单词中断换行word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap当你使用 &lt;’ overflow-wrap ‘&gt; 时，最好同时使用 &lt;’ word-wrap ‘&gt; 作为备选，作向前兼容。 语法：word-wrap：normal | break-word 实例：word-wrap: break-word; FStrPrivFinÄndG (Gesetz zur Änderung des Fernstraßenbauprivatfinanzierungsgesetzes und straßenverkehrsrechtlicher Vorschriften) 兼容性：IE6+,Firefox3.5+, Chrome4+, Safari6+, iOS Safari6+, Android Browser2.1+, Android Chrome18+ 兼容方法：现代浏览器几乎都支持 @font-face能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。 语法：@font-face &#123; font-family: &lt;YourWebFontName&gt;; src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*; [font-weight: &lt;weight&gt;]; [font-style: &lt;style&gt;];&#125; 实例：@font-face &#123; font-family: 'YourWebFontName'; src: url('YourWebFontName.eot'); /* IE9 Compat Modes */ src: url('YourWebFontName.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('YourWebFontName.woff') format('woff'), /* Modern Browsers */ url('YourWebFontName.ttf') format('truetype'), /* Safari, Android, iOS */ url('YourWebFontName.svg#YourWebFontName') format('svg'); /* Legacy iOS */ font-weight: normal; font-style: normal;&#125; 兼容性：几乎所有浏览器支持网络字体@font-face的用法 兼容方法：详情参阅 @font-face transform元素可以按照设定的值变形、旋转、缩放、倾斜 语法：transform ： none | &lt;transform-function&gt; [ &lt;transform-function&gt; ]*transform-function list: matrix() = matrix(&lt;number&gt;[,&lt;number&gt;]{5,5}) matrix3d() = matrix3d(&lt;number&gt;[,&lt;number&gt;]{15,15}) translate() = translate(&lt;translation-value&gt;[,&lt;translation-value&gt;]?) translate3d() = translate3d(&lt;translation-value&gt;,&lt;translation-value&gt;,&lt;length&gt;) translatex() = translatex(&lt;translation-value&gt;) translatey() = translatey(&lt;translation-value&gt;) translatez() = translatez(&lt;length&gt;) rotate() = rotate(&lt;angle&gt;) rotate3d() = rotate3d(&lt;number&gt;,&lt;number&gt;,&lt;number&gt;,&lt;angle&gt;) rotatex() = rotatex(&lt;angle&gt;) rotatey() = rotatey(&lt;angle&gt;) rotatez() = rotatez(&lt;angle&gt;) scale() = scale(&lt;number&gt;[,&lt;number&gt;]?) scale3d() = scale3d(&lt;number&gt;,&lt;number&gt;,&lt;number&gt;) scalex() = scalex(&lt;number&gt;) scaley() = scaley(&lt;number&gt;) scalez() = scalez(&lt;number&gt;) skew() = skew(&lt;angle&gt;[,&lt;angle&gt;]?) skewx() = skewx(&lt;angle&gt;) skewy() = skewy(&lt;angle&gt;) perspective() = perspective(&lt;length&gt;) &lt;translation-value&gt; = &lt;length&gt; | &lt;percentage&gt; 实例：transform:none; transform:rotate(30deg) scale(0.5);//大家记住了是空格隔开transform:skew(45deg);transform:translate(100px 20px); 兼容性：IE9+, Firefox3.5+, Chrome4.0+, Safari6.0+, iOS Safari8.4+, Android Browser4.4+, Android Chrome34+ 兼容方法：.transform&#123; -webkit-transform: x,y; -moz-transform: x,y; -ms-transform: x,y; -o-transform: x,y; transform: x,y;&#125; IE8及以下：用IE滤镜&#123; filter:fliph;/*水平翻转相当于transform:rotateY(180deg)*/ filter:flipv;/*垂直翻转相当于transform:rotateX(180deg)*/&#125; 详情参阅transform transitioncss的属性值在一定的时间区间内平滑地过渡 语法：transition ：[&lt;'transition-property'&gt; || &lt;'transition-duration'&gt; ||&lt;'transition-timing-function'&gt; || &lt;'transition-delay'&gt; [, [&lt;'transition-property'&gt; || &lt;'transition-duration'&gt; || &lt;'transition-timing-function'&gt; || &lt;'transition-delay'&gt;]]* transition-property ： none | all | [ &lt;ident&gt; ] [, &lt;ident&gt; ]*检索或设置对象中的参与过渡的属性transition-duration ： &lt;time&gt; [, &lt;time&gt;]*检索或设置对象过渡的持续时间 transition-timing-function ：ease | linear | ease-in | ease-out | ease-in-out | step-start | step-end | steps(&lt;integer&gt;[, [ start | end ] ]?) | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)[,ease | linear | ease-in | ease-out | ease-in-out | step-start | step-end | steps(&lt;integer&gt;[, [ start | end ] ]?) | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)]* 检索或设置对象中过渡的动画类型 transition-delay ： &lt;time&gt; [, &lt;time&gt;]* 检索或设置对象延迟过渡的时间 实例：transition: all .5s ease-in-out 1s; .transition{width:100px;height:100px;background-color:red;transition: all .5s ease-in-out 1s;}.transition:hover{width:200px;transform:rotate(45deg);} 兼容性：IE10+, Firefox16+, Chrome26+ ,Safari6.1+ , iOS Safari7+, Android Browser4.4+, Android Chrome25+ 兼容方法：p &#123; -webkit-transition: all .5s ease-in-out 1s; -moz-transition: all .5s ease-in-out 1s; -o-transition: all .5s ease-in-out 1s; transition: all .5s ease-in-out 1s;&#125; IE9以及更早的版本，不支持 transition 属性。详情参阅transition animation检索或设置对象所应用的动画特效。 语法：animation：&lt;single-animation&gt;[,&lt;single-animation&gt;]*&lt;single-animation&gt; = &lt;single-animation-name&gt; || &lt;time&gt; || &lt;single-animation-timing-function&gt; || &lt;time&gt; || &lt;single-animation-iteration-count&gt; || &lt;single-animation-direction&gt; || &lt;single-animation-fill-mode&gt; || &lt;single-animation-play-state&gt; &lt;’ animation-name ‘&gt;：检索或设置对象所应用的动画名称&lt;’ animation-duration ‘&gt;：检索或设置对象动画的持续时间&lt;’ animation-timing-function ‘&gt;：检索或设置对象动画的过渡类型&lt;’ animation-delay ‘&gt;：检索或设置对象动画延迟的时间&lt;’ animation-iteration-count ‘&gt;：检索或设置对象动画的循环次数&lt;’ animation-direction ‘&gt;：检索或设置对象动画在循环中是否反向运动&lt;’ animation-fill-mode ‘&gt;：检索或设置对象动画时间之外的状态&lt;’ animation-play-state ‘&gt;：检索或设置对象动画的状态。 实例： 兼容性：IE10+,Firefox16+, Chrome43+, Safari9+ 兼容方法：低版本的chrome:-webkit-低版本的firefox：-moz-IE9及以下不支持详情参阅animation @keyframes用于创建动画 语法：@keyframes IDENT &#123; 0% &#123; Properties:Properties value; &#125; Percentage &#123; Properties:Properties value; &#125; 100% &#123; Properties:Properties value; &#125;&#125; 实例：见上例 兼容性：IE10+,Firefox16+, Chrome43+, Safari9+ 兼容方法：低版本的chrome:-webkit-低版本的firefox：-moz-IE9及以下不支持详情参阅animation linear-gradient &amp; radial-gradient实现真实的渐变效果。 语法：&lt;linear-gradient&gt; = linear-gradient([ [ &lt;angle&gt; | to &lt;side-or-corner&gt; ] ,]? &lt;color-stop&gt;[, &lt;color-stop&gt;]+)&lt;side-or-corner&gt; = [left | right] || [top | bottom]&lt;color-stop&gt; = &lt;color&gt; [ &lt;length&gt; | &lt;percentage&gt; ]?&lt;angle&gt;：用角度值指定渐变的方向（或角度）。&lt;color-stop&gt; 用于指定渐变的起止颜色： 实例：background:linear-gradient(to bottom, #fff 0%, red 100%); background:radial-gradient(#fff 0%, red 100%); 兼容性：IE10+, Firefox16+, Chrome26+, Safari6.1+ 兼容方法：低版本的chrome:-webkit-低版本的firefox：-moz-IE9及以下可使用 IE 滤镜处理:filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#000000',endColorstr='#ffffff'); 详情参阅gradient rgba(r,g,b,a)设置颜色red+green+blue+alpha 语法：rgba(r,g,b,alpha) 实例：rgba(255,0,0,.2) 兼容性：IE9+, Firefox2+, Chrome4+, Safari3+, iOS Safari3.2+, Android Browser2.1+, Android Chrome18+ 兼容方法：IE6/7/8不支持使用 rgba 模式实现透明度，可使用 IE 滤镜处理filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#7fff0000,endColorstr=#7fff0000); 详情参阅IE8下兼容rgba颜色的半透明背景 flex设置或检索弹性盒模型对象的子元素如何分配空间。用在子容器上 语法：flex：none | &lt;&#39; flex-grow &#39;&gt; &lt;&#39; flex-shrink &gt;&#39;? || &lt;&#39; flex-basis &#39;&gt;默认值为0 1 auto，建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。flex-grow：&lt;number&gt;设置或检索弹性盒的扩展比率。默认为0,如果所有子容器的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个子容器的flex-grow属性为2，其他都为1，则前者占据的剩余空间将比其他项多一倍。flex-shrink：&lt;number&gt;设置或检索弹性盒的收缩比率。如果所有子容器的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个子容器的flex-shrink属性为0，其他子容器都为1，则空间不足时，前者不缩小。flex-basis：&lt;length&gt; | &lt;percentage&gt; | auto | content定义了在分配多余空间之前，子容器占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即子容器的本来大小。 实例：children1children2children3 兼容性：IE11+,Firefox22+, Chrome21+, Safari6.1+ 兼容方法：低版本的chrome:-webkit- 或者 -webkit-box-flex低版本的firefox：-moz-box-flex:1;IE10:-ms-flex:1;box-flex效果类似于过渡版本和新版本的flex属性；详情参阅flex flex-flow设置或检索弹性盒模型对象的子元素排列方式。用在父容器上 语法：flex-flow：&lt;&#39; flex-direction &#39;&gt; || &lt;&#39; flex-wrap &#39;&gt;&lt;’ flex-direction ‘&gt;：定义弹性盒子元素的排列方向。flex-direction：row | row-reverse | column | column-reverse row：主轴与行内轴方向作为默认的书写模式。即横向从左到右排列（左对齐）。 row-reverse：对齐方式与row相反。 column：主轴与块轴方向作为默认的书写模式。即纵向从上往下排列（顶对齐）。 column-reverse：对齐方式与column相反。 &lt;’ flex-wrap ‘&gt;控制flex容器是单行或者多行.flex-wrap：nowrap | wrap | wrap-reverse nowrap：flex容器为单行。该情况下flex子项可能会溢出容器 wrap：flex容器为多行。该情况下flex子项溢出的部分会被放置到新行，子项内部会发生断行 wrap-reverse：反转 wrap 排列。 实例： 兼容性：IE11+, Firefox28+, Chrome29+, Safari9+ 兼容方法：可以通过box-orient:horizontal + box-direction:normal 达到新版本 flex-direction:row 的效果；可以通过box-orient:horizontal + box-direction:reverse 达到新版本 flex-direction:row-reverse 的效果；可以通过box-orient:vertical + box-direction:normal 达到新版本 flex-direction:column 的效果；可以通过box-orient:horizontal + box-direction:reverse 达到新版本 flex-direction:column-reverse 的效果；box-lines效果类似于过渡版本和新版本的flex-wrap属性 justify-content设置或检索弹性盒子元素在主轴（横轴）方向上的定位方式。 语法：justify-content：flex-start | flex-end | center | space-between | space-around flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个子元素两侧的间隔相等。所以，子元素之间的间隔比子元素与边框的间隔大一倍 实例： 兼容性：IE11+, Firefox22+, Chrome29+, Safari9+ 兼容方法：详情参阅justify-content align-content调整伸缩子元素在侧轴(纵轴)上的定位方式，如果子元素只有一根轴线，该属性不起作用 语法：align-content：flex-start | flex-end | center | space-between | space-around | stretch flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 实例： 兼容性：IE11+, Firefox22+, Chrome29+, Safari9+ 兼容方法：低版本的chrome：-webkit- box-pack效果等同于过渡版本的flex-pack属性和新版本的justify-content属性； 详情参阅align-content align-items定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的定位方式。 语法：align-items：flex-start | flex-end | center | baseline | stretch flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 实例： 兼容性：IE11+, Firefox22+, Chrome29+, Safari9+ 兼容方法：低版本的chrome：-webkit- box-align效果等同于过渡版本的flex-align属性和新版本的align-items属性； 详情参阅align-items align-self定义flex子项单独在侧轴（纵轴）方向上的对齐方式。align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 语法：align-self：auto | flex-start | flex-end | center | baseline | stretch 实例： 兼容性：IE11+, Firefox22+, Chrome29+, Safari9+ 兼容方法：低版本的chrome：-webkit-详情参阅align-self order设置或检索弹性盒模型对象的子元素的排列顺序。数值越小，排列越靠前，默认为0。 语法：order：&lt;integer&gt;默认为0 实例： 兼容性：IE11+, Firefox22+, Chrome29+, Safari9+ 兼容方法：低版本的chrome：-webkit- box-oridinal-group效果等同于过渡版本的flex-order属性和新版本的order属性；详情参阅order box-sizing用来改变默认的 CSS 盒模型 对元素宽高的计算方式 语法：box-sizing：content-box | border-boxcontent-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding )border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width ) 实例：box-sizing：content-box box-sizing：border-box 兼容性：IE8+, Firefox29+, Chrome10+, Safari6+ #####兼容方法：详情参阅box-sizing resize设置或检索对象的区域是否允许用户缩放，调节元素尺寸大小。多用于textarea元素 语法：resize：none | both | horizontal | vertical 实例：resize:none 兼容性：Firefox Chrome Safari现代版都兼容 兼容方法：IE全不兼容 opacity设置设置元素的不透明级别 语法：opacity: value|inherit; 实例：opacity:0.5; 兼容性：IE8不兼容 Firefox Chrome Safari现代版都兼容 兼容方法：IE8及以下可使用IE滤镜处理filter：alpha(opacity=50); 对于行内元素需要先将其转化为块状元素才行","tags":[{"name":"CSS","slug":"css","permalink":"https://jesse121.github.io/tags/css/"}]},{"title":"《图解HTTP》--读书笔记","date":"2016-04-01T16:00:00.000Z","path":"articles/notes/graphic-http.html","text":"第一章、了解web及网络基础1.2 http的诞生HTTP于1990年问世，那时候HTTP并没有作为正式的标准被建立，被称为HTTP/0.9 HTTP正式作为标准被公布是在1996年5月，版本被命名为HTTP/1.0，该协议至今仍被广泛用在服务器端。 HTTP/1.1于1997年1月公布，是目前主流的HTTP协议版本。 HTTP/2.0正在制定中。 1.3 TCP/IPTCP/IP不是某个协议，而是互联网相关的各类协议族的总称。详细内容参见TCP/IP详解学习笔记 TCP/IP协议族按层次分别为以下4层： 应用层：决定了向用户提供应用服务时的通信活动，该层包括FTP DNS HTTP 传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，该层包括TCP UDP 网络层：用来处理在网络上流动的数据包，该层规定了通过怎样的路径达到对方计算机并把数据包传送给对方 链路层：用来处理连接网络的硬件部分，网卡 光纤 TCP/IP通信传输流程（http举例） 首先作为发送端的客户端在应用层（http协议）发出一个想看某个web页面的http请求。接着，为了传输的方便，在传输层（tcp协议）把从应用层处收到的数据（http请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。在网络层（ip协议）增加作为通信目的地的MAC地址后转发给链路层。这样，发往网络的通信请求就齐全了。 1.4.1 负责传输的IP协议IP协议的作用是把各种数据包传送给对方 IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址 1.4.2 确保可靠性的TCP协议TCP协议为了更容易送达大数据才把数据分割，采用三次握手策略确保数据最终送达对方 三次握手策略： 发送端首先发送一个带SYN(synchronize)标志的数据包给对方，接收端收到后回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后发送端再回传一个带ACK(acknowledgement)标志的数据包代表握手结束。 1.5 负责域名解析的DNS(Domain Name System)服务DNS提供域名到IP地址之间的解析服务 1.6 各种协议在http协议通信过程中的职责按流程顺序分别为： DNS服务：把用户输入的域名解析为IP地址 HTTP协议：生成针对目标web服务器的HTTP请求报文 TCP协议：为了方便通信将HTTP请求报文分割成报文段，把每个报文段可靠的传给对方 IP协议：搜索对方的地址，一边中转一边传送 TCP协议：从对方那里接收报文段并按序号从组请求报文 HTTP协议：对web服务器请求的内容的处理 1.7 URI/URLURI(Uniform Resource Identifier)某个协议方案的资源的定位标识符 URL(Uniform Resource Locator)表示互联网资源的具体地点 第二章、简单的http协议2.2 通过请求和响应的交换达成通信请求报文是由请求方法、请求URI、协议版本、可选的请求头部字段和内容实体构成的。 响应报文基本上是由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段及实体主体构成。 2.3 HTTP是不保存状态的协议HTTP协议自身不对请求和响应之间的通信状态进行保存 2.5 告知服务器意图的http方法GET:用来访问已被URI识别的资源 POST:用来传输实体的主体 GET方法和POST方法的区别： 安全性 GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，参数将明文出现在URL上，容易被他人看到，URL信息也可能会被记录到历史纪录中。 POST请求是把提交的数据则放置在是HTTP包的包体中。 数据长度： HTTP协议没有对传输的数据和URL长度进行限制， 但特定浏览器和服务器对URL长度有限制， 因此对于GET提交时，传输数据就会受到URL长度的限制； 由于POST操作不是通过URL传值，理论上数据长度不受限； GET请求能够被缓存,以GET请求的URL能够保存为浏览器书签，而POST请求则都不能 Get是用来从服务器上获得数据，而Post是用来向服务器上传递数据。 以下其他方法均不常用 PUT:传输文件 HEAD：获得报文首部 DELETE:删除文件 OPTUIONS:询问支持的方法 TRACK:追踪路径 CONNECT：要求用隧道协议连接代理 2.7 持久连接节省通信量持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻服务器端荷载。在HTTP/1.1中所有连接默认都是持久连接 持久连接使得多数请求以管线化方式发送，即能同时并行发送多个请求。 2.8 使用cookie的状态管理cookie技术是通过在请求和响应报文中写入cookie信息来控制客户端的状态 Cookie会根据从服务器发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端接收到客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。 第三章、http报文内的http信息3.1 HTTP报文HTTP报文大致可分为报文首部和报文主体两块，两者有最初出现的空行来划分，通常并不一定要有报文主体 3.2 请求报文和响应报文的结构请求行：包含用于请求的方法，请求URI和HTTP版本 状态行：包含响应结果的状态码，原因短语和HTTP版本 首部字段：包含表示请求和响应的各种条件和属性的各类首部，一般分别为：通用首部、请求首部、响应首部和实体首部。 其他：包含HTTP的RFC里未定义的首部（Cookie等） 3.3 编码提升传输速率常用的内容编码方式有以下几种： gzip(GNU zip) compress(UNIX系统的标准压缩) deflate(zlib) identity(不进行编码) 3.5 获取部分内容的范围请求(Range Request)执行范围请求时，会用到首部字段Range来指定资源的byte范围 针对范围请求，响应会返回状态码为206 Partial Content的响应报文 3.6 内容协商返回最合适的内容内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。如首部字段中的Accept、Accept-Charset、Accept-Enoding、Accept-Language、Content-Language 第四章、返回结果的http状态4.1 状态码告知从服务器端返回的请求结果 类别 Cool 1XX informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作已完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器端错误状态码) 服务器处理请求出错 4.2 2XX成功200 OK 表示从客户端发来的请求在服务器端被正常处理 204 No Content 表示服务器接收的请求已成功处理，但返回的响应报文中不允许返回任何实体的主体部分 206 Partial Content 表示客户端进行了范围请求，服务器成功执行了这部分GET请求 4.3 3XX 重定向304 Not Modified 表示客户端发送附带条件的GET请求时，其访问的资源（自上次访问以来或者根据请求的条件）未变化 4.4 4XX客户端错误401 Bad Request 表示报文中存在语法错误 403 Forbidden 表示对请求资源的访问被服务器拒绝了 404 Not Found 表示服务器上无法找到请求的资源 4.5 5XX 服务器错误501 Internet Sever Error 表示服务器端在执行请求时发生了错误 503 Service Unavailable 表示服务器暂时处于超负荷或正在停机维护，现无法处理请求 第五章、与http协作的web服务器5.1 用单个虚拟主机实现多个域名在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI 5.2.1 代理代理服务器的基本行为接收客户端发送的请求后转发给其他服务器，代理不改变请求URI,转发时需要附加Via首部字段已标记出经过的主机信息。 使用代理服务器的理由： 利用缓存技术（代理缓存）减少网络带宽的流量 组织内部针对特定网站的访问控制，以获取访问日志为主要目的。 5.2.2 网关网关能使通信线路上的服务器提供非HTTP服务（SQL数据查询） 5.2.3 隧道隧道的目的是确保客户端能与服务器进行安全的通信 第六章、http首部6.2.4 首部字段一览表通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Cache-Control 逐跳首部、连接的管理 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言 Authorization web认证信息 Expect 期待服务器的特定行为 Form 用户的电子邮箱地址 Host 请求资源所在服务器 if-Match 比较实体标记ETag if-None-Math 比较实体标记 if-Modified-Since 比较资源的更新时间 if-Unmodified-Since 比较资源的更新时间 if-Range 资源未更新时发送实体byte的范围请求 Max-Forwards 最大传输逐跳数 Proy-Authorization 代理服务器要求的客户端认证信息 Referer 对请求中URI的原始获取方 Range 实体的字节范围请求 TE 传输编码的优先级 User-Agent http客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Range 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向指定URI Proxy-Authenticate 代理服务器对客户端的认证信息 Petry-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 第七章、确保web安全的https7.1http缺点 通信使用明文，内容可能被窃听 不验证通信方身份，有可能遭遇伪装 无法证明报文的完整性，有可能已遭篡改 7.2 HTTP+加密+认证+完整性保护=HTTPSHTTPS并非应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议代替而已，其实就是身披SSL协议这层外壳的HTTP SSL采用一种叫做公开密钥加密的加密处理方式 公开密钥加密使用一对非对称的密钥，私有密钥和公开密钥，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密 公开密钥加密处理起来比共享密钥加密方式更为复杂，因此若在通信时使用公开密钥加密方式，效率会很低。所以HTTPS采用采用共享密钥加密和公开密钥加密两者并用的混合加密机制 混合加密机制原理： 使用公开密钥加密方式安全的交换共享密钥（在稍后的共享密钥加密中要使用的密钥） 确保交换的秘钥安全的前提下，使用共享密钥加密方式通信。 第八章、确认访问用户身份的认证第九章、基于http的功能追加协议9.2 消除http瓶颈的spdyhttp瓶颈： 一条连接上只可发送一个请求 请求只能从客户端开始，客户端不可以接收除响应以外的指令 请求/响应首部未经压缩就发送，首部信息越多延迟越大 发送冗长的首部，每次发送相同的首部造成的浪费较多 可任意选择数据压缩格式，非强制压缩发送 消除http瓶颈方法尝试: Ajax 能实时地从服务器获取内容，可能导致大量请求产生 Comet 内容随可以实时更新，但为了保留响应，一次连接的持续时间变长了，消耗更多资源 SPDY 虽然能有效消除瓶颈，但当一个web网站使用多个域名下的资源时，改善效果受限制 9.3 使用浏览器进行双全工通信的WebSocketWebSocket协议主要特点： 支持由服务器向客户端推送数据功能 减少通信量，不但每次连接总开销减少，而且首部信息也很少 为了实现WebSocket通信需要将Http的Upgrade首部字段值设为websocket,对于之前的握手请求，返回状态码101 Switching Proticols.成功握手确立WebSocket连接之后，不再使用HTTP的数据帧，而采用WebSocket独立数据帧 WebSocket API javascript可调用“The Websocket API”内提供的websocket程序接口，以实现websocket协议下双全工通信 第十章、构建web内容的技术第十一章、web的攻击技术","tags":[{"name":"HTTP","slug":"http","permalink":"https://jesse121.github.io/tags/http/"}]},{"title":"《HTML5程序设计第二版》--读书笔记","date":"2016-03-13T14:16:52.000Z","path":"articles/notes/pro-html5-programming-2nd-edition.html","text":"第一章、HTML5概述1.6 HTML5的新功能1.6.1 新的DOCTYPE和字符集&lt;!DOCTYPE html&gt;&lt;meta charset=\"utf-8\"&gt; 使用HTML5的DOCTYPE会触发浏览器以标准模式渲染显示页面web页面有多种渲染模式，怪异模式(Quriks)、近标准模式(Almost Standards)以及标准模式(Standards)。浏览器会根据DOCTYPE识别该用哪种模式渲染页面。 1.6.2 新元素和旧元素&lt;article&gt;标签定义外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog的文本，或者是来自论坛的文本。亦或是来自其他外部源内容,内容独立于文档的其余部分 &lt;address&gt;标签定义文档作者或拥有者的联系信息。通常的做法是将 address 元素添加到网页的头部或底部。 &lt;aside&gt;标签定义主内容之外的内容。aside 标签的内容应该与附近的内容相关。 &lt;embed&gt;标签定义嵌入的内容，比如插件。 &lt;fieldset&gt;标签会在相关表单元素周围绘制边框 &lt;legend&gt;fieldset 元素定义标题（caption）。 &lt;figure&gt; 标签规定独立的流内容（图像、图表、照片、代码等等），用于对元素进行组合。使用 figcaption元素为元素组添加标题。 &lt;figcaption&gt; 标签定义 figure 元素的标题。figcaption元素应该被置于figure元素的第一个或最后一个子元素的位置。 &lt;footer&gt; 标签定义 section 或 document 的页脚。它包含创作者的姓名、文档的创作日期以及联系信息。 &lt;header&gt; 标签定义 section 或 document 的页眉。 &lt;hgroup&gt; 标签用于对网页或区段（section）的标题进行组合。 &lt;main&gt; 元素中的内容对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏、版权信息、站点标志或搜索表单。IE不支持PS：在一个文档中，不能出现一个以上的 &lt;main&gt; 元素。&lt;main&gt;元素不能是以下元素的后代：&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;、&lt;header&gt; 或 &lt;nav&gt;。 &lt;mark&gt;主要用来在视觉上向用户呈现那些需要突出的文字。比较典型的应用就是在搜索结果中向用户高亮显示搜索关键词。 &lt;nav&gt; 标签定义导航链接的部分。 &lt;details&gt;标签定义元素的细节，用户可进行查看，或通过点击进行隐藏。与 legend 一起使用，来制作 detail 的标题。该标题对用户是可见的，当在其上点击时可打开或关闭 detail。目前只有 Chrome 支持 details 标签。 &lt;datalist&gt;标签定义可选数据的列表。与 input 元素配合使用，就可以制作出输入值的下拉列表。 &lt;section&gt;标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 &lt;summary&gt; 标签包含 details 元素的标题，details 元素用于描述有关文档或文档片段的详细信息。summary 元素应该是 details 元素的第一个子元素。 &lt;time&gt; 标签定义日期或时间，或者两者。 &lt;audio&gt;标签象网页中插入声音，比如音乐或其他音频流。 &lt;video&gt; 标签定义视频，比如电影片段或其他视频流 &lt;canvas&gt; 标签定义图形，比如图表和其他图像。这个 HTML元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript以使脚本能够把想绘制的东西都绘制到一块画布上。 &lt;command&gt; 标签定义命令按钮，比如单选按钮、复选框或按钮 &lt;keygen&gt; 标签定义生成密钥。 &lt;meter&gt; 标签定义度量衡。仅用于已知最大和最小值的度量。必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。 &lt;output&gt; 标签定义不同类型的输出，比如脚本的输出。 &lt;progress&gt; 标签运行中的进程。可以使用progress标签来显示 JavaScript 中耗费时间的函数的进程。 HTML中所有自闭合的标签：&lt;br&gt; &lt;img&gt; &lt;input&gt; &lt;area&gt; &lt;base&gt; &lt;br&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;hr&gt; &lt;keygen&gt; &lt;link&gt;&lt;meta&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 被移除的旧元素basefont、big、center、font、strike、tt,推荐用css处理更好 1.6.4 使用Selectors API简化选取操作document.querySelector(\".error\"); //返回第一个.errordocument.querySelectorAll(\".error\") //返回所有的.error IE8及以上支持 第二章、Canvas API2.2 使用HTML5 Canvas API2.2.1 检测浏览器支持情况&lt;canvas id=\"drawing\"&gt;Update your browser to enjoy canvas!&lt;/canvas&gt;&lt;script type=\"text/javascript\"&gt; var drawing = document.getElementById('drawing'); //确定浏览器支持canvas if(drawing.context)&#123; //code &#125;&lt;/script&gt; 2.2.2 在页面中加入canvas&lt;canvas id=\"diagonal\" style=\"border: 1px solid;\" width=\"200\" height=\"200\"&gt; &lt;/canvas&gt;&lt;script&gt; function drawDiagonal() &#123; // Get the canvas element and its drawing context var canvas = document.getElementById('diagonal'); //canvas中所有操作数通过上下文对象来完成的 var context = canvas.getContext('2d'); // Create a path in absolute coordinates context.beginPath(); context.moveTo(70, 140); context.lineTo(140, 70); // Stroke the line onto the canvas context.stroke(); &#125; window.addEventListener(\"load\", drawDiagonal, true);&lt;/script&gt; 注意：使用canvas元素，必须先设置其width、height属性，其效果与在style中设置并不相同Canvas 是一个画板和一张画纸，画板相当于一个容器，画图是在画纸上进行的，画板和画纸的默认宽高是300*150px，当画纸与画板宽高相等时，图像不会被拉伸，当画纸与画板宽高不一样时，图像就会被拉伸（变形）。style样式里设定的是仅画板的宽高，画纸的宽高还是为默认值300*150px， 画纸不会让画板就这么空出一片，于是画纸连同图像就要一起拉伸到跟画板大小一样。所以就得到了变形之后的图片。 2.2.3 偏移function drawDiagonal() &#123; var canvas = document.getElementById('diagonal'); var context = canvas.getContext('2d'); //在变换前保存context状态可方便以后恢复 context.save(); // Move the drawing context to the right, and down context.translate(70, 140); // Draw the same line as before, but using the origin as a start context.beginPath(); context.moveTo(0, 0); context.lineTo(70, -70); context.stroke(); // 恢复context至原始状态 context.restore();&#125; 2.2.4 路径beginPath() //开始绘制moveTo(x,y) //将当前位置移动到新目标位置lineTo(x,y) //从上一位置划线到新位置closePath() //闭合路径 2.2.5 描边样式lineWidth = value 设置线条宽度。value描述线段宽度的数字。 0、 负数、 Infinity 和 NaN 会被忽略。 lineCap = type 设置线条末端样式。butt 线段末端以方形结束。round 线段末端以圆形结束。square 线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。 lineJoin = type 设定线条与线条间接合处的样式。round通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。bevel在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。miter通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。这个设置可以通过 miterLimit 属性看到效果。 miterLimit = value限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。value 斜接面限制比例的的数字。 0、负数、Infinity 和 NaN 都会被忽略。 getLineDash()返回一个包含当前虚线样式，长度为非负偶数的数组。 setLineDash(segments) 设置当前虚线样式。 lineDashOffset = value 设置虚线样式的起始偏移量。 2.2.6 填充样式fillStyle = color 设置图形的填充颜色。strokeStyle = color 设置图形轮廓的颜色。context.strokeStyle = '#663300';context.stroke(); //填充路径context.fillStyle = '#339900';context.fill(); //填充闭合路径内部像素点context.fillStyle = '#663300';context.fillRect(-5, -50, 10, 50); //填充矩形区域 2.2.7 绘制曲线arc(x, y, radius, startAngle, endAngle, anticlockwise)画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。 arcTo(x1, y1, x2, y2, radius)根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。 quadraticCurveTo(cp1x, cp1y, x, y)绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。 2.2.9 在canvas中插入图片var bark = new Image();bark.src = \"bark.jpg\";// 必须等到图片完全加载后才能对其操作bark.onload = function () &#123; ... context.drawImage(bark, -5, -50, 10, 50); ...&#125; 2.2.10 渐变createLinearGradient(x1, y1, x2, y2)createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。 createRadialGradient(x1, y1, r1, x2, y2, r2)createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。 gradient.addColorStop(position, color)addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。 // Create a 3 stop gradient horizontally across the trunkvar trunkGradient = context.createLinearGradient(-5, -50, 5, -50);// The beginning of the trunk is medium browntrunkGradient.addColorStop(0, '#663300');// The middle-left of the trunnk is lighter in colortrunkGradient.addColorStop(0.4, '#996600');// The right edge of the trunk is darkesttrunkGradient.addColorStop(1, '#552200');// Apply the gradient as the fill style, and draw the trunkcontext.fillStyle = trunkGradient;context.fillRect(-5, -50, 10, 50); 2.2.11 使用图案样式createPattern(image, type)该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。var gravel = new Image();gravel.src = \"gravel.jpg\";gravel.onload = function () &#123; ... context.strokeStyle = context.createPattern(gravel, 'repeat'); context.lineWidth = 20; context.stroke(); ...&#125; 2.2.12 缩放scale(x, y)scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。context.scale(2, 2); 2.2.13 旋转rotate(angle)这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。context.rotate(Math*PI/2); 2.2.14 文本fillText(text, x, y [, maxWidth])在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的. strokeText(text, x, y [, maxWidth])在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.context.textAlign = 'center';context.fillText('Happy Trails!', 200, 60, 400); 2.2.15 阴影shadowOffsetX = floatshadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。 shadowOffsetY = floatshadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。 shadowBlur = floatshadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。 shadowColor = colorshadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。context.shadowOffsetX = 15;context.shadowOffsetY = -10;context.shadowBlur = 2; 第三章、SVG3.1.5 在页面中添加SVG&lt;svg width=\"400\" height=\"600\"&gt;&lt;/svg&gt; 3.1.7 变换SVG元素&lt;g&gt;元素代表“组”,可以用来结合多个相关元素 3.1.8 复用内容&lt;defs&gt;元素定义留待将来使用的内容&lt;use&gt;元素用于连接到&lt;defs&gt;定义的内容&lt;svg width=\"200\" height=\"200\"&gt; &lt;defs&gt; &lt;g id=\"ShapeGroup\"&gt; &lt;rect x=\"10\" y=\"20\" width=\"100\" height=\"80\" stroke=\"red\" fill=\"#ccc\" /&gt; &lt;/g&gt; &lt;/defs&gt; &lt;use xlink:href=\"#ShapeGroup\" transform=\"translate(60,0) scale(0.5)\" /&gt; &lt;use xlink:href=\"#ShapeGroup\" transform=\"translate(120,80) scale(0.4)\" /&gt;&lt;/svg&gt; 3.1.9 图案和渐变3.1.10 SVG路径3.1.11 使用SVG文本&lt;svg width=\"200\" height=\"200\"&gt; &lt;text y=\"60\" x=\"200\" font-family=\"impact\" font-size=\"60px\" fill=\"#996600\" text-anchor=\"middle\"&gt; Happy Trails! &lt;/text&gt;&lt;/svg&gt; 第四章、Audio and Video4.2.1 浏览器支持性检测&lt;video src=\"vide.webm\" controls&gt; Your browser does not suport HTML5 video.&lt;/video&gt; 4.2.3 理解媒体元素4.2.3.3 媒体的控制如果内置的空间不适用用户界面的布局，那么可以借助javascript函数和特性 函数 动作 load() 加载为播放做准备 play() 加载并播放 pause() 暂停播放 canPlayType(type) 测试video元素是否支持给定的MIME类型的文件 第五章、Geolocation API5.1 位置信息HTML5 Geolocation API不指定设备使用哪种底层技术来定位应用程序的用户，只是用于检索位置信息的API 5.1.3 IP地址地理定位数据基于IP地址的地理定位的实现方式是：自动查找用户IP地址，然后检索其注册的物理地址 5.1.4 GPS地理定位数据GPS利用多个GPS卫星的信号实现，定位时间较长，不适合快速响应的应用程序 5.1.5 WI-FI地理定位数据基于WI-FI的地理定位信息是通过三角距离计算得出的，这个三角距离指的是用户当前位置到已知的多个wi-fi接入点的距离 5.1.6 手机地理定位数据通过用户嗲一些基站的三角距离确定的，可提供相当准确的位置信息 5.1.7 用户自定义的地理定位数据5.4 使用HTML5 Geolocation API执行HTML5 Geolocation的方式有很多，例如调用navigator.geolocation.getCurrentPosition()function loadDemo() &#123; if(navigator.geolocation) &#123; document.getElementById(\"status\").innerHTML = \"HTML5 Geolocation is supported in your browser.\"; navigator.geolocation.getCurrentPosition(updateLocation, handleLocationError,&#123;timeout:10000&#125;);//调用位置信息 &#125;&#125;function updateLocation(position) &#123; var latitude = position.coords.latitude; //纬度 var longitude = position.coords.longitude; //经度 var accuracy = position.coords.accuracy; //准确度 var timestamp = position.timestamp; if (!latitude || !longitude) &#123; document.getElementById(\"status\").innerHTML = \"HTML5 Geolocation is supported in your browser, but your location is currently not available.\"; return; &#125; document.getElementById(\"latitude\").innerHTML = \"Latitude: \" + latitude; document.getElementById(\"longitude\").innerHTML = \"Longitude: \" + longitude; document.getElementById(\"accuracy\").innerHTML = \"Accuracy: \" + accuracy + \" meters\"; document.getElementById(\"timestamp\").innerHTML = \"Timestamp: \" + timestamp;&#125;function handleLocationError(error) &#123; document.getElementById(\"status\").style.background = \"papayaWhip\"; switch(error.code)&#123; case 0: updateStatus(\"There was an error while retrieving your location. Additional details: \" + error.message); break; case 1: updateStatus(\"The user opted not to share his or her location.\"); break; case 2: updateStatus(\"The browser was unable to determine your location. Additional details: \" + error.message); break; case 3: updateStatus(\"The browser timed out before retrieving the location.\"); break; &#125;&#125;function updateStatus(message) &#123; document.getElementById(\"status\").innerHTML = \"&lt;strong&gt;Error&lt;/strong&gt;: \" + message;&#125; 第六章、Communication API6.1 跨文档消息通信跨文档消息通信可以确保iframe、标签页、窗口间安全的进行跨源通信chatFrame.contentWindow.postMessage(\"hello world\",\"http://www.example.com/\"); 6.1.3 使用postMessage API 浏览器支持情况检测 if(typeof window.postMessage === \"undefined\"){ //不支持postMessage } 发送消息 window.postMessage(\"hello world\",\"portal.example.com\"); 监听消息事件 window.onmessage = function(e){ if(e.origin === \"\"){ //接收方可以接收特定源的消息 console.log(e.data) //打印接收数据 } } &lt;!-- http:localhost/test/index.html --&gt;&lt;iframe id=\"iframe\" src=\"http://127.0.0.1/test/a.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var iframe = document.getElementById(\"iframe\"); iframe.contentWindow.postMessage(\"null\", \"http://127.0.0.1/test/a.html\"); &#125; window.onmessage = function(e) &#123; if(e.origin === \"http://127.0.0.1/a.html\")&#123; document.write(e.data); //123 这里获取到了a页面的dom内容 &#125; &#125;&lt;/script&gt;&lt;!-- http://127.0.0.1/test/a.html --&gt;&lt;div id=\"test\"&gt;123&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onmessage = function(e) &#123; if(e.origin === \"http:localhost/test/index.html\")&#123; var text = document.getElementById('test').innerHTML; //window.parent.postMessage()返回想要的数据 window.parent.postMessage(text, \"http://localhost/test/index.html\"); &#125; &#125;&lt;/script&gt; 6.2 XMLHttpRequsest Level 2XMLHttpRequsest Level 2的功能改进主要体现在： 跨源XMLHttpRequest; 进度事件(progress events) 6.2.1 跨源XMLHttpRequestXMLHttpRequsest Level 2通过CORS实现了跨源XMLHttpRequest跨源XMLHttpRequest请求包括一个origin头部服务器端需要为请求的内容添加”Access-Control-Allow-Origin:”头部 6.2.2 进度事件利用进度事件实现文件上传率xhr.onprogress = function(e)&#123; var total = e.total; var loaded = e.loaded; setProgress(radio + \"% uploaded\");&#125; 第七章、WebSockets APIWebSockets定义了双全工通信，大幅度减少了网络流量，并降低网络延迟 IE10+支持 7.3 使用 Web Sockets API7.3.2 基本用法为接受ws://loclahost:8080/echo上的链接，需要启动Python WebSocket服务器。打开命令行窗口执行以下命令：python websocket.py Web Socket对象的创建及其与Web Socket服务器的连接 url = \"ws://localhost:8080/echo\"; w = new WebSocket(url); 添加事件监听器 w.onopen = function() { //建立连接触发open log(\"open\"); w.send(\"thank you for accepting this Web Socket request\"); } w.onmessage = function(e) { //收到消息触发message log(e.data.toString()); } w.onclose = function(e) { //链接关闭触发close log(\"closed\"); } w.onerror = function(e) { //错误事件 log(\"error\"); } 发送消息 document.getElementById(\"sendButton\").onclick = function() { w.send(document.getElementById(\"inputMessage\").value); } 第八章、Froms API8.1 Froms API概述HTML5表单包含了大量的新的API和元素类型 新的输入型控件 新的函数和特性 8.1.4 输入型控件email&lt;input type=\"email\" name=\"email\"&gt; type=”email”的input输入类型用于表示语义上的e-mail地址输入域，在提交表单时，会自动验证 email 域的值。[注意] IE9-浏览器及safari浏览器不支持 tel&lt;input type=\"tel\" placeholder=\"请输入11位手机号码\" pattern=\"\\d&#123;11&#125;\"&gt; type=”tel”的input输入类型用于表示语义上的电话输入域 search&lt;input type=\"search\"&gt; url&lt;input type=\"url\" /&gt; type=”url”的input输入类型用于表示语义上的url地址的输入域,在提交表单时，会自动验证 url 域的值。[注意]IE9-浏览器及safari浏览器不支持 number&lt;input type=\"number\" min=\"0\" max=\"10\" step=\"0.5\" value=\"6\"/&gt; type=”number”的input输入类型用于处理数字输入,step 规定合法的数字间隔[注意]IE不支持该类型 range&lt;input type=\"range\" min=\"0\" max=\"10\" step=\"0.5\" value=\"6\"/&gt; type=”range”的input输入类型用于处理包含在一定范围内的数字输入[注意]IE9-不支持该类型 color&lt;input type=\"color\"&gt; type=”color”的input输入类型会创建一个调色板用来选择颜色，颜色值以URL编码后的十六进制数值提交。如黑色会以%23000000发送，其中%23是#的URL编码[注意]safari和IE不支持该类型 Date pickers&lt;input type=\"time\" value=\"hh:mm:ss\"&gt;&lt;input type=\"month\"&gt; [注意]IE和firefox这种日期类型都不支持，chrome不支持datetime类型 8.2.1 新的表单特性和函数placeholder&lt;input type=\"tel\" placeholder=\"请输入11位手机号码\"&gt; placeholder 属性提供可描述输入字段预期值的提示信息（hint）。该提示会在输入字段为空时显示，并会在字段获得焦点时消失。[注意]placeholder 属性适用于以下的 &lt;input&gt;类型：text, search, url, tel, email 以及 password。 autocomplete&lt;form action=\"demo_form.asp\" method=\"get\" autocomplete=\"on\"&gt; Name:&lt;input type=\"text\" name=\"fname\" /&gt;&lt;br /&gt; E-mail: &lt;input type=\"email\" name=\"email\" autocomplete=\"off\" /&gt;&lt;br /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; Name: E-mail: autocomplete 属性规定表单是否应该启用自动完成功能。自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。[注意]autocomplete 属性适用于 &lt;form&gt;，以及下面的 &lt;input&gt; 类型：text, search, url, tel, email, password, datepickers, range 以及 color。 autofocus&lt;input type=\"text\" name=\"usr_name\" autofocus=\"autofocus\" /&gt; 每个页面上只允许出现一个autofocus特性非type=”hidden”的input、select、textarea、button可使用autofocus元素来制定自动获得焦点的元素 list、datalist&lt;form action=\"demo_form.asp\"&gt; Webpage: &lt;input type=\"url\" list=\"url_list\" name=\"link\" /&gt; &lt;datalist id=\"url_list\"&gt; &lt;option label=\"w3schools\" value=\"http://www.w3schools.com\" /&gt; &lt;option label=\"Google\" value=\"http://www.google.com\" /&gt; &lt;option label=\"Microsoft\" value=\"http://www.microsoft.com\" /&gt; &lt;/datalist&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; Webpage: list 属性引用数据列表，其中包含输入字段的预定义选项。 min、max&lt;input type=\"number\" name=\"points\" min=\"0\" max=\"10\" /&gt; max 属性规定输入字段所允许的最大值 max 属性与 min 属性配合使用，可创建合法值范围[注意]max 和 min 属性适用于以下 &lt;input&gt;类型：number, range, date, datetime, datetime-local, month, time 以及 week。 required&lt;input type=\"text\" name=\"usr_name\" required=\"required\" /&gt; required 属性规定必需在提交之前填写输入字段。如果使用该属性，则字段是必填（或必选）的。[注意]required 属性适用于以下 &lt;input&gt;类型：text, search, url, tel, email, password, datepickers, number, checkbox, radio 以及 file。 step&lt;input type=\"number\" name=\"points\" step=\"3\" /&gt; step 属性规定输入字段的合法数字间隔（假如 step=”3”，则合法数字应该是 -3、0、3、6，以此类推）。[注意]step、max 以及 min 属性适用于以下 &lt;input&gt; 类型：number, range, date, datetime, datetime-local, month, time 以及 week。 multipleSelect images: &lt;input type=\"file\" name=\"img\" multiple=\"multiple\" /&gt; multiple 属性规定输入域中可选择多个值。multiple 属性适用于以下类型的 input 标签：email 和 file。 pattern&lt;input type=\"text\" name=\"country_code\" pattern=\"[a-z]&#123;3&#125;\" title=\"Three letter country code\" /&gt; pattern 属性规定用于验证输入字段的正则表达式模式。[注意]pattern 属性适用于以下 &lt;input&gt;类型：text, search, url, tel, email 以及 password 。 novalidate&lt;form action=\"demo_form.asp\" novalidate=\"novalidate\"&gt; E-mail: &lt;input type=\"email\" name=\"user_email\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; E-mail: novalidate 属性规定当提交表单时不对其进行验证。如果使用该属性，则表单不会验证表单的输入。[注意]novalidate 属性适用于：&lt;form&gt;以及以下类型的 &lt;input&gt; 标签：text, search, url, tel, email, password, datepickers, range 以及 color。 第九章、Drag and drop9.2.2 拖放事件流 dragstart 开始拖动页面中某元素时触发的事件他是唯一一个支持datatransfer通过setData调用来设置数据的事件 drag 拖动操作中持续发生的事件 dragenter 拖动跨入了页面中的新元素时 dragleave 用户鼠标移出之前调用dragenter的元素时触发的事件 dragover 在拖动过程中移动到某元素之上时，会频繁的触发dragover事件 drop 用户释放鼠标时，drop事件会在当前鼠标停留的目标上调用 dragend 拖动完成时在拖动源上出发，指示拖动完成 9.2.3 设置元素可拖动为了标记特定元素为可拖动，要为其添加一个属性draggable 第十章、Web Workers APIweb worker可以让web应用程序具备后台处理能力，可以充分利用多核cpu带来的优势。将耗时长的任务分配给web worker 可以避免弹出脚本运行缓慢的警告web worker执行的脚本不能访问该页面的window对象 10.2.2 创建web worker/* index.js */var worker = new Worker(\"worker.js\");worker.postMessage(\"hello world!\");worker.onmessage = function(e) &#123; console.log(e.data); //终止worker worker.terminate();&#125;;worker.onerror = function(e) &#123; console.log('Error:' + e);&#125;;/* worker.js */self.onmessage = function (e) &#123; self.postMessage('You said: ' + e.data);&#125;; 第十一章、Web Storage APIcookie的缺点： cookie大小受限 在网络上来回传送不安全，消耗带宽 web storage适用于存储超出cookie大小限制的文档和文件数据 11.3.2 设置和获取数据//设置数据sesstionStorage.setItem(\"firstKey\",\"firstValue\");sesstionStorage.firstKey = \"firstValue\";//保存对象var data = &#123;name:\"jesse\"&#125;;localStorage.setItem(\"info\",JSON.stringify(data));//获取数据sesstionStorage.getItem(\"firstKey\");sesstionStorage.firstKey;//删除数据某项数据removeItem(key)//清除所有数据clear() 11.3.4 sessionStorage和localStorage sesstionStorage localStorage 浏览器窗口或标签页关闭时，数据被清除 数据永久保存，除非用户强制清除 数据只在构建他们的窗口或标签页内可见 数据可被同源的每个窗口或标签页共享 第十二章、构建离线web应用缓存清单文件中表示的资源构成了应用缓存(application cache),他是浏览器持久性存储资源的地方，通常在硬盘上 12.2.2 搭建简单的离线应用程序在html元素中加入manifest特性&lt;html manifest=\"application.appcache\"&gt; //……&lt;/html&gt; 12.2.3 支持离线行为navigator.onLine标明浏览器是否处于在线状态if(navigator.onLine)&#123; log(\"online\")&#125;else&#123; log(offline)&#125; 12.2.4 manifest文件离线应用程序包含一个manifest文件，此文件列出了浏览器为离线应用缓存的所有资源。manifest文件的MIME类型是text/cache-manifest要配置Apache Http服务器，开发人员需要将下面一行代码添加到conf文件夹中的mime.types文件中text/cache-manifest appcache manifest文件示例CACHE MANIFEST#要缓存的文件，无论程序是否在线都会从缓存中获取# JavaScript./offline.js./log.js# stylesheets./html5.css# imageslake-tahoe.gifNETWORK# 不缓存的signup.htmlFALLBACK# 获取不到缓存资源时的备选资源路径signup.html offline.html 12.2.6 运行中的应用缓存浏览器在应用缓存中成功的缓存了应用资源后，他总会优先从缓存汇总获取资源，之后在检查服务器上的manifest文件后被修改过","tags":[{"name":"HTML","slug":"html","permalink":"https://jesse121.github.io/tags/html/"}]},{"title":"《Javascript高级程序设计》第三版--读书笔记","date":"2016-03-04T16:00:00.000Z","path":"articles/notes/professional-javascript-for-web-developers-3rd-edition.html","text":"第二章、在HTML中使用Javascript2.1 script在使用&lt;script&gt;嵌入JS代码时，不要在代码中的任何地方出现&quot;&lt;/script&gt;&quot;字符串，否则会产生错误，可以这样用”&lt;\\/script&gt;” 2.1.2 延迟脚本在&lt;script&gt;元素中设置defer属性，相当于告诉浏览器立即下载，但其中包含的脚本将延迟到浏览器遇到&lt;/html&gt;标签后在执行。HTML5规范要求脚本按照它们出现的先后顺序执行。现实中延迟脚本不一定会按照顺序执行，因此最好只包含一个延迟脚本。只适用于外部JS文件，IE4~7支持defer，IE8级以上则完全支持HTML5规定 2.1.3 异步脚本html5位script定义了async属性，与defer类似，告诉浏览器立即下载，但不保证按照先后顺序执行。其目的是不让页面等待两个脚本下载和执行，建议异步脚本不要在加载期间修改DOM 第三章、基本概念3.1.2 标识符所谓标识符就是指变量、函数、属性的名字或者函数的参数。第一个字符必须是字母或或$，其他字符可以是字母、、$、数字 3.3 变量在函数中使用var定义的变量是局部变量，这个变量在函数退出后会被销毁，因此在外部不能访问了在函数内部省略var操作符可以定义全局变量，但不推荐，会导致不必要的混乱可以使用一条语句定义多个变量，中间用逗号分隔 3.4 数据类型JS中有5中基本（标准）类型undefined null boolean number string和一种对象类型Object 3.4.1 typeof操作符typeof可以识别标准类型（null除外）不能识别具体的对象类型（function除外）如果这个值未定义则结果是undefined如果这个值是对象或null则结果是object如果这个值是函数则结果是functiontypeof是一个操作符不是函数，圆括号可用，但不是必须 3.4.2 undefined类型对未初始化的变量执行typeof操作符会返回undefined值，而对未声明的变量执行typeof操作符同样会返回undefined值 3.4.3 null类型null值表示一个空指针对象，而这也正是使用typeof操作符检测null值会返回object的原因。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null，这样一来只要检查null值就可以知道相应的变量是否已经保存一个对象的引用 3.4.4 boolean类型可以对任何数据类型的值调用boolean()函数，而且该值总会返回一个boolean值 在if语句中很重要，会自动调用boolean函数 3.4.5 number类型在进行算术计算时，所有八进制和十六进制表示的数值都将被转化为十进制数值isFinite()在参数位于最小和最大数值之间时会返回true任何涉及NaN的操作都会返回NaN,NaN与任何值都不相等，包括NaN本身isNaN()函数在接到值后会尝试将这个值转化为数值，不能转为数值的这个函数返回false在基于对象调用isNaN()函数时，会首先调用对象的valueOf()方法，如果不能转化为数值则再调用toString()方法，再测试返回值。这个过程也是ECMAscript种内置函数和操作符的一般执行流程。有3个函数可以把非数值转化为数值（返回的是NaN或十进制的数值） number()可用于任何数据类型 parseInt()函数会忽略字符串前的空格，如果第一个字符不是数字或负号会返NaN，若是数字继续解析第二个，直到解析完所有后续字符或者遇到了一个非数字字符为止。parseInt(“oxAF”,16)指定基数16作为第二个参数，返回的是十进制的数 parseFloat()从第一个字符解析直到遇见一个无效的浮点数字字符为止，(第二个小数点无效)，只解析十进制值，其他进制值返回0 3.4.6 string类型var text=\"this is the letter sigma:\\u03a3.\";alert(text.length); //28 6个字符长的转义序列表示1个字符 数值、布尔值、对象、字符串值都有tostring()方法，null undefined没有该方法默认情况下tostring()方法以十进制格式返回数值的字符串表示，通过传递基数可以输出其他进制格式在不知道要转化的值是不是null undefined的情况下，可以使用string()函数string(null); //&quot;null&quot; 3.4.7 object类型object的每个实例都具有下列属性: constructor:保存着用于创建当前对象的函数 hasownproperty(propertyname):用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在.ropertyname必须以字符串形式指定 isprototypeof(object):用于检查传入的对象是否是另一个对象的原型 propertyIsEnumberable(propertyname):用于检查给定的的属性能否使用for -in语句来枚举 toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应 toString()返回对象的字符串表示 valueof()返回对象的字符串、数值或布尔值 3.5 操作符3.5.1 一元操作符前置递增或递减操作符时，变量的值都是在语句被求值以前改变的后置递增或递减操作是在包含他们的语句被求值之后才执行的这4个操作符还可以用于字符串、布尔值、浮点数值和对象 3.5.3 布尔操作符 逻辑非操作符 !首先会将它的操作数转换为一个布尔值，然后再求其反。同时使用两个逻辑非操作符会将一个值转化为与其对应的布尔值，相当于boolean() 逻辑与操作符 &amp;&amp;逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值如果第一个操作数的布尔值为false，则不解析第二个操作数直接返回第一个操作数，如果第一个的布尔值为true第二个操作数的布尔值为false，则返回第二个操作数如果有一个操作数为null或NaN或undefined则返回null NaN undefined 逻辑或操作符 ||逻辑或操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值如果第一个操作数的布尔值为true，则不解析第二个操作数直接返回第一个操作数，如果第一个的布尔值为false第二个操作数的布尔值为true，则返回第二个操作数如果有一个操作数为null或NaN或undefined则返回null NaN undefined 3.5.4 乘性操作符在操作数为非数值的情况下会自动执行隐式类型转换求模var result = 26 % 5; //1var re = 5 % 26; //5 当被除数小于除数时结果直接返回被除数 如果操作数都是数值。执行常见的除法计算，返回出的的余数 3.5.5 加性操作符加法如果有一个操作数是字符串，则将另一个操作数转化为字符串，再拼接起来如果有一个操作数是对象、布尔值，则调用他们的toString()方法取得相应的字符串 3.5.6 关系操作符3.5.7 相等操作符相等==和不相等!=——先转换为数值在比较全等===和不全等!==——仅比较不转换null和undefined是相等的null和undefined不全等 数据类型不同 3.5.8 条件操作符var boolean_expression ? true_value : flase_value 3.5.10 逗号操作符使用逗号操作符可以再一条语句中执行多个操作，多用于声明多个变量 3.6 语句通过for-in 语句循环输出的属性名的顺序是不可预测的label语句 可以再代码中添加标签，以便将来使用，var num = 0;outermost:for(var i = 0;i &lt; 10; i++)&#123; for(var j = 0;j &lt;10;j++)&#123; if(i == 5 &amp;&amp; j == 5)&#123; break outermost; &#125; num ++ &#125;&#125;alert(num); with语句的作用是将代码的作用域设置到一个特定的对象中switch语句中可以使用任何数据类型 3.7 函数argument.length用来确定传递进来多少个参数，arguments[0]表示第一个参数 与数组类似 第四章、变量 作用域和内存问题4.1 基本类型的值和引用类型的值在给变量赋值时，解析器必须确定这个值是基本类型还是引用类型基本类型是按值访问的引用类型是按引用访问的，其值保存在内存中，在操作对象时是操作对象的引用 4.1.1 动态的属性对于引用类型，我们可以为其添加属性和方法，也可以改变和删除其属性和方法，但是我们不能给基本类型的值添加属性，尽管不出错 4.1.2 复制变量值如果从一个变量向另一个变量复制基本类型的值时，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，这两个值是独立的不会互相影响。如果一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份到为新变量分配的空间中，不同的是这个副本其实是一个指针。复制操作结束后，两个变量实际上将引用同一个对象，因此改变其中一个变量就会影响另一个变量。 4.1.3 传递参数ECMAscript中所有函数的参数都是按值传递的，基本类型值和引用类型值的传递就如同其变量的复制一样为了证明对象是按值传递的，有下面的例子：function setName(obj)&#123; obj.name = 'jesse'; obj = new Objext(); obj.name = 'grey';&#125;var person = new Object();setName(person);alert(person.name); //jesse 当函数内部重写Obj时，这个变量引用的就是一个局部对象，这个局部对象会在函数执行完毕后立即被销毁。 4.1.4 检测类型typeof常用于检测基本数据类型（null除外)typeof null; //object typeof不能识别具体的对象类型（function除外）如果变量是给定引用类型的实例，那么instanceof操作符就会返回trueperson instanceof Object; //true 4.2 执行环境全局执行环境被认为是window对象，所有全局变量和函数都作为window对象的属性和方法创建的内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数 4.2.1 延长作用域链try-catch语句的catch块会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明witch语句会将指定的对象添加到作用域链中 4.2.2 JS没有块级作用域在JS中，if语句中的变量声明会将变量添加到当前的执行环境中，for语句创建的变量i即使在for循环结束后，也会依旧存在于循环外部的执行环境中。 声明变量使用var声明的变量会自动被添加到最接近的环境中，如果初始化变量时没有使用var，该变量会自动被添加到全局环境。在编写JS过程中，不声明而直接初始化变量是一个常见的错误做法 查询标识符沿着作用域链向上逐级查找，找到后即搜索停止 4.4 小结基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本引用类型的值是对象，保存在堆内存中从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof所有变量（基本类型和引用类型）都存在于一个执行环境中，这个执行环境决定了变量的生命周期函数的局部环境不仅能访问函数作用域中的变量，而且能访问其父环境乃至全局环境中的变量 第五章、引用类型5.2.1 检测数组if(value instanceof Array)&#123; &#125;if(Array.isArray(value))&#123; //对数组的操作&#125; 5.2.2 转换方法所有对象都有toLocalString() toString() valueOf()方法var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; color; //red,blue,green由于alert()要接受字符串参数，所以它会在后台调用toString()方法join()将数组转为字符串只接受一个参数，即用作分隔符的字符串，然后返回所有数组项的字符串 5.2.5 重排序方法sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串 5.2.6 数组的操作方法contact()合并数组并返回新数组slice()截取数组中项并返回新数组splice()数组中项的插入删除替换，参数分别为起始位置、要删除的项数、要插入的项数。返回一个新数组，该数组中包含原数组中的删除项 5.2.8 数组的迭代方法every(),some(),filter(), map(), forEach() 5.3 Date类型var now = new Date(); //创建新对象自动获得当前日期和时间Date.parse()接受一个表示日期的字符串函数，并返回相应日期的毫秒数var someDate = new Date(“May 25,2004”)会在后台调用Date.parse()方法Date.now()返回表示调用这个方法时的日期和时间的毫秒数 5.5 function类型函数名仅仅是一个包含指针的变量而已 5.5.4 函数内部属性argument 保存函数参数argument.callee 指向拥有这个argument对象的函数this 引用的是函数据以执行的环境对象caller 保存着调用当前函数的函数的引用 5.5.5 函数属性和方法属性：length prototype方法：apply() call()这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值，真正的作用是扩充函数的作用域它们的区别仅在于接受参数的方式不同bind() 这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。 5.6 基本包装类型ECMA提供了3个特殊的引用类型：boolean number string每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象 5.6.2 Number类型toFixed()方法会按照指定的小数位返回数值的字符串表示toExponential()方法返回以指数表示法toPrecision()方法可能返回固定大小格式 5.6.3 String类型 字符方法charAt()方法以单字符字符串的形式返回给定位置的那个字符charCodeAt()方法以单字符编码的形式返回给定位置的那个字符 字符串操作方法合并contact()用于将一或多个字符串拼接起来，并返回拼接得到的新字符串。可以接收任意多个参数，可以拼接任意多个字符串截取基于子字符串创建新字符串的方法，都会返回被操作字符串的一个子字符串，对原始字符串无影响，第二个参数为空时默认将字符串长度作为结束位置。slice(子字符串的开始位置，子字符串最后一个字符后面的位置)参数为负数时，将负值与字符串长度相加substr(子字符串的开始位置，返回的字符个数)负的第一个参数加上字符串长度，负的第二个参数转为0substring(子字符串的开始位置，子字符串最后一个字符后面的位置)会把所有的负数转为0 字符串位置方法从一个字符串中搜索给定的子字符串，并返回子字符串的位置，未找到则返回-1indexOf()方法从字符串开头向后搜索lastIndexOf()方法从字符串末尾向前搜索 trim()方法trim()返回删除前置后置所有空格后的字符串副本，对原始字符串无影响。IE9+ 字符串的模式匹配方法match(),search(),replace(regexp对象或字符串，字符串会函数)split()方法基于指定的分隔符讲一个字符串分割成多个子字符串，并将结果放在一个数组中，第二个参数可以指定数组长度 第六章、面向对象的程序设计6.1.1 属性类型及特征ECMAScript中有两种属性类型： 数据属性 [[Configurable]]表示能否修改属性的特性,默认为true [[Enumerable]]表示能否通过for-in循环返回属性,默认为true [[Writable]]表示能否修改属性的值,默认为true [[Value]]包含这个属性的数据值，默认为undefined 要修改属性默认的特性，必须使用Object.defineProperty()方法，该方法接收三个参数：属性所在的对象，属性的名字，描述符对象。描述符对象的属性必须是：configurable,enumerable,writable,value var person = &#123;&#125;;Object.defineProperty(person,'name',&#123; configurable:false, //设置为不可配置,就不能再变回可配置 writable:false, //设置为不能修改 value:\"Jack\"&#125;);alert(person.name); //\"Jack\"person.name = 'Greg';alert(person.name); //\"Jack\" 访问器属性 6.2.2 构造函数模式构造函数始终都应该以一个大写字母开头，必须使用new操作符 6.2.3 原型模式这个对象的用途是包含可以由特定的所有实例共享的属性和方法isPrototypeOf()方法来确定对象之间是否存在指向关系alert(Person.prototype.isPrototypeOf(person1)); //trueObject.getPrototypeOf()返回取得一个对象的原型使用hasOnProperty()方法可以检测一个属性是存在实例中，还是存在原型中。是从Object继承来的原型与in操作符在单独使用时 in操作符会在对象都够访问给定属性时返回true,无论该属性存在实例中还是原型中 6.2.4 组合使用构造函数模式和原型模式6.3.2 借用构造函数通过使用apply()和call()也可以在新创建的对象上执行构造函数，从而实现继承 6.3.3 组合继承将原型链和借用构造函数的技术组合到一起，使用原型链实现对原型链属性和方法的继承，而通过借用构造函数实现对实例属性的继承 第七章、函数表达式创建函数的两种方式：函数声明function关键字和函数表达式var functionName=function()函数表达式在调用前必须先赋值函数声明提升 是指在执行代码之前会先读取函数声明，这意味着可以把函数声明放在调用他的语句后面 7.1 递归递归函数是在一个函数通过名字调用自身的情况下构成的arguments.callee是一个指向正在执行的函数的指针，因此可以用来实现对函数的递归调用，比使用函数名更保险 在严格模式下不能通过脚本访问callee,可以使用命名函数表达式来实现相同的效果 7.2 闭包闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另一个函数。 7.3 模仿块级作用域块级作用域的匿名函数的语法如下所示：(function()&#123; //块级作用域&#125;)() 创建并立即调用一个匿名函数 第八章、BOM8.1 window对象全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。跨浏览器取得窗口左边和上边的位置screenTop,screenLeft表示的是从屏幕左边和上边到由window对象表示的页面可见区域的距离var leftPos = (typeof window.screenLeft == \"number\") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == \"number\") ? window.screenTop : window.screenY; 8.2 location对象window.location和document.location引用的是同一个对象获取查询字符串方法 //用以解析查询字符串，返回包含所有参数的一个对象function getQueryStringArgs()&#123; var qs = (location.search.length &gt; 0 ? location.search.substring(1) : \"\"), args = &#123;&#125;, items = qs.length ? qs.split(\"&amp;\") : [], item = null, name = null, value = null, i = 0, len = items.length; for(i = 0; i &lt; len; i++)&#123; item = items[i].split(\"=\"); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if(name.length)&#123; args[name] = value; &#125; &#125; return args;&#125; location.hreflocation.reload()重新加载当前显示页（可能从缓存中加载）location.reload(true)重新加载当前显示页（从服务器中加载） ####8.5history对象history.go(-1);//后退一页history.go(1);//前进一页 第九章、客户端检测9.1 能力检测只需要检测浏览器知否支持特定的能力 9.3 用户代理检测检测用户使用的是PC端还是mobile端？ 第十章、DOM10.1. 节点层次JS中所有节点类型都继承自Node类型，因此都共享这基本属性和方法每一个节点都有一个parentNodes属性，该属性指向文档数中的父节点。每一个节点都有一个childNodes属性，其中保存着一个NodeList类数组对象，childNodes列表中每个节点的previousSibling和nextSibling可以访问同一列表中的其他节点所有节点的ownerDocument属性直接指向整个文档的文档节点。appendChild(要插入的节点)如果传入到appendChild()中的节点已经是文档的一部分，那么结果就是该节点从原来的位置转移到新位置。insertBefore(要插入的节点，参照节点)replaceChild(要插入的节点，要替换的节点)removeChild(要移除的节点)要使用以上4个方法必须先取得父节点cloneNode(false)浅复制，只复制节点本身cloneNode(true)深复制，复制节点及整个节点树Document类型document对象是window对象的一个属性，因此可以讲其作为全局对象来访问doucmentElement始终指向html元素document.body始终指向body元素docuemnt.links 包含文档中所有带href特性的a元素getElementById() getElementsByTagName() getElementsByClassName() namedItem()document.write() 原样写入document.writeln()在字符串末尾添加换行符操作特性的DOM方法分别是getAttribute(),setAttribute()和removeAttribute()有些浏览器会将文本节点看做子节点，有些则不会，因此在执行某项操作前需要检查nodeType是否==1（表示元素节点） 第十一章、DOM扩展11.1 选择符APIquerySelectot()方法接受一个CSS选择符，返回与该模式匹配的第一个元素，未找到返回nullquerySelectorAll()方法接受一个css选择符，返回与该模式匹配的所有元素，一个Nodelist实例 11.2 元素遍历Element Traversal API为DOM元素添加了以下5个属性： childElementCount返回子元素的个数（不包含文本节点及注释） firstElementChild指向第一个子元素 lastElementChild指向最后一个子元素 previousElementSibling指向前一个同辈元素 nextElementSibling指向后一个同辈元素 支持的浏览器有IE9+ firefox3.5+ safari4+ chrome opera10+ 11.3 HTML511.3.1 与类相关的扩充getElementsByClassName()支持的浏览器有IE9+ Firefox3+ Safari3.1+ Chrome Opera9.5+classList属性，用于添加删除替换类名,支持的浏览器有Firefox3.6+ Chromediv.classList.remove(\"disabled\"); //删除类名div.classList.add(\"current\"); //添加类名div.classList.troggle(\"user\"); //切换类名 11.3.2 焦点管理 document.activeElement属性，始终会引用DOM中当前获得了焦点的元素 document.hasFocus()用于确定文档是否获得了焦点 11.3.3 HTMLDocument readyState属性，通过它来实现一个文档是否已加载完成 if(document.readyState == \"complete\")&#123; //执行操作&#125; 标准模式与混杂模式 if(document.compatMode == \"CSS1Compat\")&#123; //标准模式&#125;else&#123; //混杂模式&#125; insertAdjacentHTML(插入位置，要插入的HTML文本) element.insertAdjacentHTML(\"beforebegin\",\"&lt;p&gt;Hello world!&lt;/p&gt;\"); //在当前元素之前插入一个紧邻的同辈元素element.insertAdjacentHTML(\"afterend\",\"&lt;p&gt;Hello world!&lt;/p&gt;\"); //在当前元素之后插入一个紧邻的同辈元素element.insertAdjacentHTML(\"afterbegin\",\"&lt;p&gt;Hello world!&lt;/p&gt;\"); //在当前元素之下插入一个新的子元素element.insertAdjacentHTML(\"beforeend\",\"&lt;p&gt;Hello world!&lt;/p&gt;\"); //在当前元素之下插入一个新的子元素 11.3.7 scrollIntoView()可以在所有html元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中document.forms[0].scrollIntoView(true);//调用元素与视口顶部尽可能齐平document.forms[0].scrollIntoView(false);//调用元素与视口底部尽可能齐平 第十二章、DOM2和DOM312.2 样式任何支持style特性的html元素在javascript中都有一个对应的style属性，使用短划线的css属性必须转为驼峰大小写形式 特例 floatcssFloat //非IEstyleFloat //IE 12.2.1 DOM样式属性和方法 cssText:能够访问并重写style特性中的css代码 length:给定元素的css属性数量 parentRule:表示CSS信息的CSSRule对象 getPropertyCSSValue(propertyName):返回包含给定属性的CSSRule对象 getPropertyPriotrity(propertyName):如果给定的属性设置了important,则返回important，否则返回空字符串 getPropertyValue(propertyName):返回给定属性的字符串值 item(index):返回给定位置的CSS属性的名称 removeProperty(propertyName):从样式中删除给定属性 setProperty(propertyName,value,priority):将给定的属性设置为相应的值，并加上优先权标志 12.2.3 元素大小获得元素的左偏移量function getElementLeft(element)&#123; var actualLeft = element.offsetLeft(); var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125; 偏移量 offsetHeight():height+borderWidth+scrollbarHeight offsetWidth():width+borderwidth+scrollbarHeight offsetLeft():元素的左外边框至其父元素的左内边框之间的距离 offsetTop():元素的上外边框至其父元素的上内边框之间的距离 客户区大小 clientWidth()元素内容区宽度加上左右内边距宽度 clientHeight()元素内容区高度加上上下内边距高度 滚动大小 scrollLeft被隐藏在内容区左侧的像素宽度 scrollTop被隐藏才内容区上方的像素高度 第十三章、事件13.1事件流 事件冒泡即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点 事件捕获则与事件冒泡相反 事件流的三个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 13.2 事件处理程序13.2.1 HTML事件处理程序&lt;input type=&quot;button&quot; value=&quot;click Me&quot; onclick=&quot;alert(&#39;Clicked&#39;)&quot;/&gt;缺点： javascript还没加载完用户就点击，就会引发错误 这种扩展事件处理程序的作用域链在不同浏览器中会导致不同结果 HTML代码与javascript代码紧密耦合，不利于后期修改维护 13.2.2 DOM0级事件处理程序var btn = document.getElementById('mybtn');btn.onclick = function()&#123; alert(\"clicked\");&#125; 13.2.3 DOM2级事件处理程序处理指定事件程序addEventListener(事件名，事件处理程序函数，布尔值)var btn = document.getElementById('mybtn');var hander = function()&#123; alert(\"clicked\");&#125;;btn.addEventListener(\"click\",hander,false);//其他代码btn.removeEventListener(\"click\",hander,false); 布尔值为true表示在捕获阶段调用事件处理程序，布尔值为false表示在冒泡阶段调用事件处理程序，不建议在事件捕获阶段注册事件处理程序 删除事件处理程序removeEventListener(事件名，事件处理程序函数，布尔值) addEventListener()添加的事件处理程序只能使用removeEventListener()来移除 13.3 事件对象要阻止特定事件的默认行为，可以使用preventDefault()要阻止事件捕获或冒泡，可以使用stopPropagation() 13.3.3 跨浏览器的事件对象var EventUtil = &#123; addHandler: function(element, type, handler)&#123; if (element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent)&#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, removeHandler: function(element, type, handler)&#123; if (element.removeEventListener)&#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent)&#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;, preventDefault: function(event)&#123; if (event.preventDefault)&#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event)&#123; if (event.stopPropagation)&#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, getEvent: function(event)&#123; //返回对event对象的引用，IE中event未定义，返回window.event return event ? event : window.event; &#125;, getTarget: function(event)&#123; //返回事件的目标 return event.target || event.srcElement; &#125;, getButton: function(event)&#123; if (document.implementation.hasFeature(\"MouseEvents\", \"2.0\"))&#123; return event.button; &#125; else &#123; switch(event.button)&#123; case 0: case 1: case 3: case 5: case 7: return 0; case 2: case 6: return 2; case 4: return 1; &#125; &#125; &#125;, getCharCode: function(event)&#123; if (typeof event.charCode == \"number\")&#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;, getClipboardText: function(event)&#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData(\"text\"); &#125;, getRelatedTarget: function(event)&#123; if (event.relatedTarget)&#123; return event.relatedTarget; &#125; else if (event.toElement)&#123; return event.toElement; &#125; else if (event.fromElement)&#123; return event.fromElement; &#125; else &#123; return null; &#125; &#125;, getWheelDelta: function(event)&#123; if (event.wheelDelta)&#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); &#125; else &#123; return -event.detail * 40; &#125; &#125;, setClipboardText: function(event, value)&#123; if (event.clipboardData)&#123; event.clipboardData.setData(\"text/plain\", value); &#125; else if (window.clipboardData)&#123; window.clipboardData.setData(\"text\", value); &#125; &#125;&#125;; 13.4 事件类型13.4.1 UI事件 load upload 当页面完全卸载后在window上触发 abort select 当用户选择文本框中的一个或多个字符时触发 error 当发生JS错误时在window上触发 resize 当窗口或框架的大小变化时在window或框架上触发 scroll 当用户滚动带滚动条的元素中的内容时，在该元素上触发 13.4.2 焦点事件blur在元素失去焦点时触发，不冒泡focusout在元素失去焦点时触发，冒泡focus在元素获得焦点时触发，不冒泡focusin在元素获得焦点时触发，冒泡 13.4.3 鼠标与滚轮事件 click dbclick mousedown mouseup mousemove mouseenter 鼠标光标从目标元素外部首次移动到元素范围之内时触发，不冒泡，光标移到其后代元素上也不会触发 mouseleave 鼠标光标从目标元素上方首次移动到元素范围之外时触发，不冒泡，光标移到其后代元素上也不会触发 mouseover 鼠标光标从目标元素外部首次移动到相关元素范围之内时触发，相关元素可以是目标元素的外部元素或子元素 mouseout 鼠标光标从目标元素上方首次移动到相关元素范围之内时触发，相关元素可以是目标元素的外部元素或子元素 13.4.7 HTML5事件contextmenu() 通过点击鼠标右键可以调出上下文菜单beforeunload()在浏览器页面卸载前触发DOMContentLoaded()在形成完整的DOM树之后触发readystatechange()pageshow() pagehide()hashchange() 13.4.8 设备事件orientationchange()横竖屏切换时触发 13.4.9 触摸与手势事件触摸事件 touchstart touchmove touchend touchcancel 手势事件 gesturestart gesturechange gestureend 属性 rotation 手势变化引起的旋转角度，负值表示逆时针旋转，正值表示顺时针旋转 scale 两个手指间距离的变化情况 13.5 内存和性能事件委托，利用了事件冒泡，只指定一个事件处理程序，就可以管理一类型所有事件var list = document.getElementById(\"myLinks\");EventUtil.addHandler(list, \"click\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id)&#123; case \"doSomething\": document.title = \"I changed the document's title\"; break; case \"goSomewhere\": location.href = \"http://www.wrox.com\"; break; case \"sayHi\": alert(\"hi\"); break; &#125;&#125;); 优点： document很快就可以访问，在页面生命周期任何时间点上添加事件处理程序 只添加一个事件处理程序所需的DOM引用更少 整个页面占用内存更少 最适合采用事件委托技术的事件包括click mousedown mouseuo keydown keyup keypress 13.5.2 移除事件处理程序在页面卸载之前，先通过onunload事件处理程序移除所有事件 第十四章、表单脚本14.1 表单基础知识常用的表单提交按钮&lt;input type=\"submit\" value=\"Submit from\"&gt; //通用提交按钮&lt;button type=\"submit\"&gt;submit from&lt;\\/button&gt; //自定义提交按钮&lt;input type=\"image\" src=\"graphic.gif\"&gt; //图像按钮 14.1.3 表单字段每个表单都有elements属性，该属性时表单中所有表单元素的集合，可以按照位置和name属性来访问var filed = form.elements['textbox1'];//避免多次提交表单EventUtil.addHandler(form,\"submit\",function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var btn = target.elements[\"submit-btn\"]; btn.dsiabled = true;&#125;) 14.2 文本框脚本 size指定文本框中能够显示的字符， maxlength指定文本框可以接受的最大字符数 select()方法用于选择文本框中的所有文本 select事件，只有用户选择了文本，才会触发select事件 14.2.1 选择文本 取得选择的文本 function getSelectedText(textbox)&#123; if(typeof textbox.selectionStart == \"number\")&#123; return textbox.value.substring(textbox.selectionStart,textbox.selectionEnd); &#125;else if(document.selection)&#123; return document.selection.createRange().text; &#125;&#125; 选择部分文本 function selectText(textbox, startIndex, stopIndex)&#123; if (textbox.setSelectionRange)&#123; textbox.setSelectionRange(startIndex, stopIndex); &#125; else if (textbox.createTextRange)&#123; var range = textbox.createTextRange(); range.collapse(true); range.moveStart(\"character\", startIndex); range.moveEnd(\"character\", stopIndex - startIndex); range.select(); &#125; textbox.focus();&#125; 操作剪贴板 14.2.3 自动切换焦点在自动切换焦点之前必须知道用户已经输入了既定长度的数据maxlength&lt;input type=\"text\" name=\"tel1\" id=\"txtTel1\" size=\"3\" maxlength=\"3\" &gt;&lt;input type=\"text\" name=\"tel2\" id=\"txtTel2\" size=\"3\" maxlength=\"3\" &gt;&lt;input type=\"text\" name=\"tel3\" id=\"txtTel3\" size=\"4\" maxlength=\"4\" &gt;(function()&#123; function tabForward(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.value.length == target.maxLength)&#123; var form = target.form; for (var i=0, len=form.elements.length; i &lt; len; i++) &#123; if (form.elements[i] == target) &#123; if (form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125; &#125; var textbox1 = document.getElementById(\"txtTel1\"), textbox2 = document.getElementById(\"txtTel2\"), textbox3 = document.getElementById(\"txtTel3\"); EventUtil.addHandler(textbox1, \"keyup\", tabForward); EventUtil.addHandler(textbox2, \"keyup\", tabForward); EventUtil.addHandler(textbox3, \"keyup\", tabForward); &#125;)(); 14.2.4 HTML5 约束验证API 必填字段 required属性 input新类型email url pattern属性&lt;input type=&quot;text&quot; pattern=&quot;\\d+&quot; name=&quot;count&quot;&gt; 第十五章、使用Canvas绘图15.1 基本用法IE9+,firefox1.5+,safari2+,chrome支持&lt;canvas&gt;要使用&lt;canvas&gt;元素，必须先设置其width和height属性，指定可以绘图的区域的大小在使用&lt;canvas&gt;元素之前，首先要检测getContext()方法是否存在if(drawing.getContext)&#123; var context = drawing.getContext('2d'); //more code&#125; 使用toDataURL()方法可以导出在canvas元素上绘制的图像 15.2 2D上下文15.2.2 绘制矩形fillRect(x,y,width,height)方法在画布上绘制的矩形会填充指定的颜色context.fillStyle = \"rgba(0,255,0,0.5)\";context.fillRect(10,10,50,50); var drawing = document.getElementById(‘drawing’); if(drawing.getContext){ var context = drawing.getContext(‘2d’); context.fillStyle = “rgba(0,255,0,0.5)”; context.fillRect(10,10,50,50); }strokeRect()方法在画布上绘制的矩形会使用指定的颜色描边context.strokeStyle = \"red\";context.strokeRect(10,10,50,50); var drawing = document.getElementById(‘drawing1’); if(drawing.getContext){ var context = drawing.getContext(‘2d’); context.strokeStyle = “red”; context.strokeRect(10,10,50,50); }clearRect()方法用于清除画布上的矩形区域，本质上可以把绘制上下文中的某一矩形区域变透明context.clearRect(40,40,10,10); var drawing = document.getElementById(‘drawing2’); if(drawing.getContext){ var context = drawing.getContext(‘2d’); context.fillStyle = “rgba(0,255,0,0.5)”; context.fillRect(10,10,50,50); context.clearRect(40,40,15,15); } 15.2.3 绘制路径要绘制路径首先必须调用beginPath()方法，表示开始绘制路径 arc(x,y,radius,startAngle,endAngle,counterclockwise) acrTo(x1,y1,x2,y2,radius)从上一点开始绘制一条弧线，到(x2,y2)为止，并以给定的半径穿过(x1,y1) bezierCurveTo(c1x,c1y,c2x,c2y,x,y) lineTo(x,y)从上一点开始绘制一条直线，到(x,y)为止 moveTo(x,y)将绘图游标移动到(x,y),不画线 quadraticCurveTo(cx,cy,x,y) rect(x,y,width,height) closePath()闭合路径 fill()填充路径 stroke()描边路径 clip()创建剪切区域 var drawing = document.getElementById(‘drawing3’); if(drawing.getContext){ var context = drawing.getContext(‘2d’); context.beginPath(); context.arc(100, 100, 99, 0, 2 Math.PI, false); context.moveTo(194, 100); context.arc(100, 100, 94, 0, 2 Math.PI, false); context.moveTo(100,100); context.lineTo(100,30); context.moveTo(100,100); context.lineTo(45,100); context.strokeStyle = “red”; context.font = “bold 14px Arial”; context.textAlign = “center”; context.textBaseline = “middle”; context.fillText(“12”,100,20); context.stroke(); } 15.2.4 绘制文本fillText(str,x,y); 15.2.5 变换 rotate(angle):围绕原点旋转图像angle弧度 scale(scalex,scaley):缩放图像 translate(x,y):将坐标原点移动到(x,y) save()方法保存的只是对绘图上下文的设置和变换","tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://jesse121.github.io/tags/javascript/"}]}]